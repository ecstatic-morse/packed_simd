var searchIndex={};
searchIndex["cfg_if"] = {"doc":"A macro for defining `#[cfg]` if-else statements.","i":[[14,"cfg_if","cfg_if","The main macro provided by this crate. See crate…",null,null]],"p":[]};
searchIndex["libm"] = {"doc":"libm in pure Rust","i":[[5,"acos","libm","Arccosine (f64)",null,[[["f64"]],["f64"]]],[5,"acosf","","Arccosine (f32)",null,[[["f32"]],["f32"]]],[5,"acosh","","Inverse hyperbolic cosine (f64)",null,[[["f64"]],["f64"]]],[5,"acoshf","","Inverse hyperbolic cosine (f32)",null,[[["f32"]],["f32"]]],[5,"asin","","Arcsine (f64)",null,[[["f64"]],["f64"]]],[5,"asinf","","Arcsine (f32)",null,[[["f32"]],["f32"]]],[5,"asinh","","Inverse hyperbolic sine (f64)",null,[[["f64"]],["f64"]]],[5,"asinhf","","Inverse hyperbolic sine (f32)",null,[[["f32"]],["f32"]]],[5,"atan","","Arctangent (f64)",null,[[["f64"]],["f64"]]],[5,"atan2","","Arctangent of y/x (f64)",null,[[["f64"]],["f64"]]],[5,"atan2f","","Arctangent of y/x (f32)",null,[[["f32"]],["f32"]]],[5,"atanf","","Arctangent (f32)",null,[[["f32"]],["f32"]]],[5,"atanh","","Inverse hyperbolic tangent (f64)",null,[[["f64"]],["f64"]]],[5,"atanhf","","Inverse hyperbolic tangent (f32)",null,[[["f32"]],["f32"]]],[5,"cbrt","","Computes the cube root of the argument.",null,[[["f64"]],["f64"]]],[5,"cbrtf","","Cube root (f32)",null,[[["f32"]],["f32"]]],[5,"ceil","","Ceil (f64)",null,[[["f64"]],["f64"]]],[5,"ceilf","","Ceil (f32)",null,[[["f32"]],["f32"]]],[5,"copysign","","Sign of Y, magnitude of X (f64)",null,[[["f64"]],["f64"]]],[5,"copysignf","","Sign of Y, magnitude of X (f32)",null,[[["f32"]],["f32"]]],[5,"cos","","",null,[[["f64"]],["f64"]]],[5,"cosf","","",null,[[["f32"]],["f32"]]],[5,"cosh","","Hyperbolic cosine (f64)",null,[[["f64"]],["f64"]]],[5,"coshf","","Hyperbolic cosine (f64)",null,[[["f32"]],["f32"]]],[5,"erf","","Error function (f64)",null,[[["f64"]],["f64"]]],[5,"erfc","","Error function (f64)",null,[[["f64"]],["f64"]]],[5,"erfcf","","Error function (f32)",null,[[["f32"]],["f32"]]],[5,"erff","","Error function (f32)",null,[[["f32"]],["f32"]]],[5,"exp","","Exponential, base e (f64)",null,[[["f64"]],["f64"]]],[5,"exp10","","",null,[[["f64"]],["f64"]]],[5,"exp10f","","",null,[[["f32"]],["f32"]]],[5,"exp2","","Exponential, base 2 (f64)",null,[[["f64"]],["f64"]]],[5,"exp2f","","Exponential, base 2 (f32)",null,[[["f32"]],["f32"]]],[5,"expf","","Exponential, base e (f32)",null,[[["f32"]],["f32"]]],[5,"expm1","","Exponential, base e, of x-1 (f64)",null,[[["f64"]],["f64"]]],[5,"expm1f","","Exponential, base e, of x-1 (f32)",null,[[["f32"]],["f32"]]],[5,"fabs","","Absolute value (magnitude) (f64) Calculates the absolute…",null,[[["f64"]],["f64"]]],[5,"fabsf","","Absolute value (magnitude) (f32) Calculates the absolute…",null,[[["f32"]],["f32"]]],[5,"fdim","","Positive difference (f64)",null,[[["f64"]],["f64"]]],[5,"fdimf","","Positive difference (f32)",null,[[["f32"]],["f32"]]],[5,"floor","","Floor (f64)",null,[[["f64"]],["f64"]]],[5,"floorf","","Floor (f64)",null,[[["f32"]],["f32"]]],[5,"fma","","Floating multiply add (f64)",null,[[["f64"]],["f64"]]],[5,"fmaf","","Floating multiply add (f32)",null,[[["f32"]],["f32"]]],[5,"fmax","","",null,[[["f64"]],["f64"]]],[5,"fmaxf","","",null,[[["f32"]],["f32"]]],[5,"fmin","","",null,[[["f64"]],["f64"]]],[5,"fminf","","",null,[[["f32"]],["f32"]]],[5,"fmod","","",null,[[["f64"]],["f64"]]],[5,"fmodf","","",null,[[["f32"]],["f32"]]],[5,"frexp","","",null,[[["f64"]]]],[5,"frexpf","","",null,[[["f32"]]]],[5,"hypot","","",null,[[["f64"]],["f64"]]],[5,"hypotf","","",null,[[["f32"]],["f32"]]],[5,"ilogb","","",null,[[["f64"]],["i32"]]],[5,"ilogbf","","",null,[[["f32"]],["i32"]]],[5,"j0","","",null,[[["f64"]],["f64"]]],[5,"y0","","",null,[[["f64"]],["f64"]]],[5,"j0f","","",null,[[["f32"]],["f32"]]],[5,"y0f","","",null,[[["f32"]],["f32"]]],[5,"j1","","",null,[[["f64"]],["f64"]]],[5,"y1","","",null,[[["f64"]],["f64"]]],[5,"j1f","","",null,[[["f32"]],["f32"]]],[5,"y1f","","",null,[[["f32"]],["f32"]]],[5,"jn","","",null,[[["f64"],["i32"]],["f64"]]],[5,"yn","","",null,[[["f64"],["i32"]],["f64"]]],[5,"jnf","","",null,[[["f32"],["i32"]],["f32"]]],[5,"ynf","","",null,[[["f32"],["i32"]],["f32"]]],[5,"ldexp","","",null,[[["f64"],["i32"]],["f64"]]],[5,"ldexpf","","",null,[[["f32"],["i32"]],["f32"]]],[5,"lgamma","","",null,[[["f64"]],["f64"]]],[5,"lgamma_r","","",null,[[["f64"]]]],[5,"lgammaf","","",null,[[["f32"]],["f32"]]],[5,"lgammaf_r","","",null,[[["f32"]]]],[5,"log","","",null,[[["f64"]],["f64"]]],[5,"log10","","",null,[[["f64"]],["f64"]]],[5,"log10f","","",null,[[["f32"]],["f32"]]],[5,"log1p","","",null,[[["f64"]],["f64"]]],[5,"log1pf","","",null,[[["f32"]],["f32"]]],[5,"log2","","",null,[[["f64"]],["f64"]]],[5,"log2f","","",null,[[["f32"]],["f32"]]],[5,"logf","","",null,[[["f32"]],["f32"]]],[5,"modf","","",null,[[["f64"]]]],[5,"modff","","",null,[[["f32"]]]],[5,"pow","","",null,[[["f64"]],["f64"]]],[5,"powf","","",null,[[["f32"]],["f32"]]],[5,"remquo","","",null,[[["f64"]]]],[5,"remquof","","",null,[[["f32"]]]],[5,"round","","",null,[[["f64"]],["f64"]]],[5,"roundf","","",null,[[["f32"]],["f32"]]],[5,"scalbn","","",null,[[["f64"],["i32"]],["f64"]]],[5,"scalbnf","","",null,[[["f32"],["i32"]],["f32"]]],[5,"sin","","",null,[[["f64"]],["f64"]]],[5,"sincos","","",null,[[["f64"]]]],[5,"sincosf","","",null,[[["f32"]]]],[5,"sinf","","",null,[[["f32"]],["f32"]]],[5,"sinh","","",null,[[["f64"]],["f64"]]],[5,"sinhf","","",null,[[["f32"]],["f32"]]],[5,"sqrt","","",null,[[["f64"]],["f64"]]],[5,"sqrtf","","",null,[[["f32"]],["f32"]]],[5,"tan","","",null,[[["f64"]],["f64"]]],[5,"tanf","","",null,[[["f32"]],["f32"]]],[5,"tanh","","",null,[[["f64"]],["f64"]]],[5,"tanhf","","",null,[[["f32"]],["f32"]]],[5,"tgamma","","",null,[[["f64"]],["f64"]]],[5,"tgammaf","","",null,[[["f32"]],["f32"]]],[5,"trunc","","",null,[[["f64"]],["f64"]]],[5,"truncf","","",null,[[["f32"]],["f32"]]],[8,"F32Ext","","Math support for `f32`",null,null],[10,"floor","","",0,[[],["self"]]],[10,"ceil","","",0,[[],["self"]]],[10,"round","","",0,[[],["self"]]],[10,"trunc","","",0,[[],["self"]]],[10,"fdim","","",0,[[],["self"]]],[10,"fract","","",0,[[],["self"]]],[10,"abs","","",0,[[],["self"]]],[10,"mul_add","","",0,[[],["self"]]],[10,"div_euc","","",0,[[],["self"]]],[10,"mod_euc","","",0,[[],["self"]]],[10,"powf","","",0,[[],["self"]]],[10,"sqrt","","",0,[[],["self"]]],[10,"exp","","",0,[[],["self"]]],[10,"exp2","","",0,[[],["self"]]],[10,"ln","","",0,[[],["self"]]],[10,"log","","",0,[[],["self"]]],[10,"log2","","",0,[[],["self"]]],[10,"log10","","",0,[[],["self"]]],[10,"cbrt","","",0,[[],["self"]]],[10,"hypot","","",0,[[],["self"]]],[10,"sin","","",0,[[],["self"]]],[10,"cos","","",0,[[],["self"]]],[10,"tan","","",0,[[],["self"]]],[10,"asin","","",0,[[],["self"]]],[10,"acos","","",0,[[],["self"]]],[10,"atan","","",0,[[],["self"]]],[10,"atan2","","",0,[[],["self"]]],[10,"sin_cos","","",0,[[]]],[10,"exp_m1","","",0,[[],["self"]]],[10,"ln_1p","","",0,[[],["self"]]],[10,"sinh","","",0,[[],["self"]]],[10,"cosh","","",0,[[],["self"]]],[10,"tanh","","",0,[[],["self"]]],[10,"asinh","","",0,[[],["self"]]],[10,"acosh","","",0,[[],["self"]]],[10,"atanh","","",0,[[],["self"]]],[10,"min","","",0,[[],["self"]]],[10,"max","","",0,[[],["self"]]],[8,"F64Ext","","Math support for `f64`",null,null],[10,"floor","","",1,[[],["self"]]],[10,"ceil","","",1,[[],["self"]]],[10,"round","","",1,[[],["self"]]],[10,"trunc","","",1,[[],["self"]]],[10,"fdim","","",1,[[],["self"]]],[10,"fract","","",1,[[],["self"]]],[10,"abs","","",1,[[],["self"]]],[10,"mul_add","","",1,[[],["self"]]],[10,"div_euc","","",1,[[],["self"]]],[10,"mod_euc","","",1,[[],["self"]]],[10,"powf","","",1,[[],["self"]]],[10,"sqrt","","",1,[[],["self"]]],[10,"exp","","",1,[[],["self"]]],[10,"exp2","","",1,[[],["self"]]],[10,"ln","","",1,[[],["self"]]],[10,"log","","",1,[[],["self"]]],[10,"log2","","",1,[[],["self"]]],[10,"log10","","",1,[[],["self"]]],[10,"cbrt","","",1,[[],["self"]]],[10,"hypot","","",1,[[],["self"]]],[10,"sin","","",1,[[],["self"]]],[10,"cos","","",1,[[],["self"]]],[10,"tan","","",1,[[],["self"]]],[10,"asin","","",1,[[],["self"]]],[10,"acos","","",1,[[],["self"]]],[10,"atan","","",1,[[],["self"]]],[10,"atan2","","",1,[[],["self"]]],[10,"sin_cos","","",1,[[]]],[10,"exp_m1","","",1,[[],["self"]]],[10,"ln_1p","","",1,[[],["self"]]],[10,"sinh","","",1,[[],["self"]]],[10,"cosh","","",1,[[],["self"]]],[10,"tanh","","",1,[[],["self"]]],[10,"asinh","","",1,[[],["self"]]],[10,"acosh","","",1,[[],["self"]]],[10,"atanh","","",1,[[],["self"]]],[10,"min","","",1,[[],["self"]]],[10,"max","","",1,[[],["self"]]]],"p":[[8,"F32Ext"],[8,"F64Ext"]]};
searchIndex["packed_simd"] = {"doc":"Portable packed SIMD vectors","i":[[3,"Simd","packed_simd","Packed SIMD vector type.",null,null],[3,"LexicographicallyOrdered","","Wrapper over `T` implementing a lexicoraphical order via…",null,null],[3,"m8","","8-bit wide mask.",null,null],[3,"m16","","16-bit wide mask.",null,null],[3,"m32","","32-bit wide mask.",null,null],[3,"m64","","64-bit wide mask.",null,null],[3,"m128","","128-bit wide mask.",null,null],[3,"msize","","isize-wide mask.",null,null],[11,"new","","Instantiate a mask with `value`",0,[[["bool"]],["self"]]],[11,"test","","Test if the mask is set",0,[[["self"]],["bool"]]],[11,"new","","Instantiate a mask with `value`",1,[[["bool"]],["self"]]],[11,"test","","Test if the mask is set",1,[[["self"]],["bool"]]],[11,"new","","Instantiate a mask with `value`",2,[[["bool"]],["self"]]],[11,"test","","Test if the mask is set",2,[[["self"]],["bool"]]],[11,"new","","Instantiate a mask with `value`",3,[[["bool"]],["self"]]],[11,"test","","Test if the mask is set",3,[[["self"]],["bool"]]],[11,"new","","Instantiate a mask with `value`",4,[[["bool"]],["self"]]],[11,"test","","Test if the mask is set",4,[[["self"]],["bool"]]],[11,"new","","Instantiate a mask with `value`",5,[[["bool"]],["self"]]],[11,"test","","Test if the mask is set",5,[[["self"]],["bool"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[["i8"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[["i8"]],["self"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]],["i8"]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]],["i8"]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["i8"],["usize"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["i8"],["usize"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["i8x2"]],["i8x2"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["i8x2"]],["i8x2"]]],[11,"min","","Minimum of two vectors.",6,[[],["self"]]],[11,"max","","Maximum of two vectors.",6,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[],["i8"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[],["i8"]]],[11,"max_element","","Largest vector element value.",6,[[],["i8"]]],[11,"min_element","","Smallest vector element value.",6,[[],["i8"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[],["i8"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[],["i8"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[],["i8"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",6,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",6,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",6,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",6,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m8x2"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m8x2"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m8x2"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m8x2"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m8x2"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m8x2"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[["self"]],[["lexicographicallyordered",["i8x2"]],["i8x2"]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[["self"]],[["lexicographicallyordered",["i8x2"]],["i8x2"]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[["u8"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[["u8"]],["self"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]],["u8"]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]],["u8"]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["usize"],["u8"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["usize"],["u8"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["u8x2"]],["u8x2"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["u8x2"]],["u8x2"]]],[11,"min","","Minimum of two vectors.",6,[[],["self"]]],[11,"max","","Maximum of two vectors.",6,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[],["u8"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[],["u8"]]],[11,"max_element","","Largest vector element value.",6,[[],["u8"]]],[11,"min_element","","Smallest vector element value.",6,[[],["u8"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[],["u8"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[],["u8"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[],["u8"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",6,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",6,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",6,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",6,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m8x2"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m8x2"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m8x2"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m8x2"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m8x2"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m8x2"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[["self"]],[["u8x2"],["lexicographicallyordered",["u8x2"]]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[["self"]],[["u8x2"],["lexicographicallyordered",["u8x2"]]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[["bool"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[["bool"]],["self"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]],["bool"]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]],["bool"]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["usize"],["bool"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["usize"],["bool"]],["self"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[],["bool"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[],["bool"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[],["bool"]]],[11,"all","","Are `all` vector lanes `true`?",6,[[],["bool"]]],[11,"any","","Is `any` vector lane `true`?",6,[[],["bool"]]],[11,"none","","Are `all` vector lanes `false`?",6,[[],["bool"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m8x2"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m8x2"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m8x2"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m8x2"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m8x2"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m8x2"]]],[11,"select","","Selects elements of `a` and `b` using mask.",6,[[["simd"]],["simd"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[["self"]],[["m8x2"],["lexicographicallyordered",["m8x2"]]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[["self"]],[["m8x2"],["lexicographicallyordered",["m8x2"]]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[["i8"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[["i8"]],["self"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]],["i8"]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]],["i8"]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["i8"],["usize"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["i8"],["usize"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["i8x4"]],["i8x4"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["i8x4"]],["i8x4"]]],[11,"min","","Minimum of two vectors.",6,[[],["self"]]],[11,"max","","Maximum of two vectors.",6,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[],["i8"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[],["i8"]]],[11,"max_element","","Largest vector element value.",6,[[],["i8"]]],[11,"min_element","","Smallest vector element value.",6,[[],["i8"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[],["i8"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[],["i8"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[],["i8"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",6,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",6,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",6,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",6,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m8x4"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m8x4"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m8x4"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m8x4"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m8x4"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m8x4"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[["self"]],[["lexicographicallyordered",["i8x4"]],["i8x4"]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[["self"]],[["lexicographicallyordered",["i8x4"]],["i8x4"]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[["u8"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[["u8"]],["self"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]],["u8"]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]],["u8"]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["usize"],["u8"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["usize"],["u8"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["u8x4"]],["u8x4"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["u8x4"]],["u8x4"]]],[11,"min","","Minimum of two vectors.",6,[[],["self"]]],[11,"max","","Maximum of two vectors.",6,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[],["u8"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[],["u8"]]],[11,"max_element","","Largest vector element value.",6,[[],["u8"]]],[11,"min_element","","Smallest vector element value.",6,[[],["u8"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[],["u8"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[],["u8"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[],["u8"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",6,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",6,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",6,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",6,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m8x4"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m8x4"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m8x4"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m8x4"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m8x4"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m8x4"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[["self"]],[["lexicographicallyordered",["u8x4"]],["u8x4"]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[["self"]],[["lexicographicallyordered",["u8x4"]],["u8x4"]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[["bool"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[["bool"]],["self"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]],["bool"]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]],["bool"]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["usize"],["bool"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["usize"],["bool"]],["self"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[],["bool"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[],["bool"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[],["bool"]]],[11,"all","","Are `all` vector lanes `true`?",6,[[],["bool"]]],[11,"any","","Is `any` vector lane `true`?",6,[[],["bool"]]],[11,"none","","Are `all` vector lanes `false`?",6,[[],["bool"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m8x4"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m8x4"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m8x4"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m8x4"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m8x4"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m8x4"]]],[11,"select","","Selects elements of `a` and `b` using mask.",6,[[["simd"]],["simd"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[["self"]],[["lexicographicallyordered",["m8x4"]],["m8x4"]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[["self"]],[["lexicographicallyordered",["m8x4"]],["m8x4"]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[["i16"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[["i16"]],["self"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]],["i16"]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]],["i16"]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["usize"],["i16"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["usize"],["i16"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["i16x2"]],["i16x2"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["i16x2"]],["i16x2"]]],[11,"min","","Minimum of two vectors.",6,[[],["self"]]],[11,"max","","Maximum of two vectors.",6,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[],["i16"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[],["i16"]]],[11,"max_element","","Largest vector element value.",6,[[],["i16"]]],[11,"min_element","","Smallest vector element value.",6,[[],["i16"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[],["i16"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[],["i16"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[],["i16"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",6,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",6,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",6,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",6,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m16x2"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m16x2"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m16x2"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m16x2"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m16x2"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m16x2"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[["self"]],[["i16x2"],["lexicographicallyordered",["i16x2"]]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[["self"]],[["i16x2"],["lexicographicallyordered",["i16x2"]]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[["u16"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[["u16"]],["self"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]],["u16"]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]],["u16"]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["u16"],["usize"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["u16"],["usize"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["u16x2"]],["u16x2"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["u16x2"]],["u16x2"]]],[11,"min","","Minimum of two vectors.",6,[[],["self"]]],[11,"max","","Maximum of two vectors.",6,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[],["u16"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[],["u16"]]],[11,"max_element","","Largest vector element value.",6,[[],["u16"]]],[11,"min_element","","Smallest vector element value.",6,[[],["u16"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[],["u16"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[],["u16"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[],["u16"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",6,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",6,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",6,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",6,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m16x2"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m16x2"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m16x2"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m16x2"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m16x2"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m16x2"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[["self"]],[["u16x2"],["lexicographicallyordered",["u16x2"]]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[["self"]],[["u16x2"],["lexicographicallyordered",["u16x2"]]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[["bool"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[["bool"]],["self"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]],["bool"]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]],["bool"]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["usize"],["bool"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["usize"],["bool"]],["self"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[],["bool"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[],["bool"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[],["bool"]]],[11,"all","","Are `all` vector lanes `true`?",6,[[],["bool"]]],[11,"any","","Is `any` vector lane `true`?",6,[[],["bool"]]],[11,"none","","Are `all` vector lanes `false`?",6,[[],["bool"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m16x2"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m16x2"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m16x2"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m16x2"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m16x2"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m16x2"]]],[11,"select","","Selects elements of `a` and `b` using mask.",6,[[["simd"]],["simd"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[["self"]],[["m16x2"],["lexicographicallyordered",["m16x2"]]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[["self"]],[["m16x2"],["lexicographicallyordered",["m16x2"]]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[["i8"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[["i8"]],["self"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]],["i8"]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]],["i8"]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["i8"],["usize"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["i8"],["usize"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["i8x8"]],["i8x8"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["i8x8"]],["i8x8"]]],[11,"min","","Minimum of two vectors.",6,[[],["self"]]],[11,"max","","Maximum of two vectors.",6,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[],["i8"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[],["i8"]]],[11,"max_element","","Largest vector element value.",6,[[],["i8"]]],[11,"min_element","","Smallest vector element value.",6,[[],["i8"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[],["i8"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[],["i8"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[],["i8"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",6,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",6,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",6,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",6,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m8x8"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m8x8"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m8x8"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m8x8"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m8x8"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m8x8"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[["self"]],[["lexicographicallyordered",["i8x8"]],["i8x8"]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[["self"]],[["lexicographicallyordered",["i8x8"]],["i8x8"]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[["u8"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[["u8"]],["self"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]],["u8"]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]],["u8"]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["usize"],["u8"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["usize"],["u8"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["u8x8"]],["u8x8"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["u8x8"]],["u8x8"]]],[11,"min","","Minimum of two vectors.",6,[[],["self"]]],[11,"max","","Maximum of two vectors.",6,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[],["u8"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[],["u8"]]],[11,"max_element","","Largest vector element value.",6,[[],["u8"]]],[11,"min_element","","Smallest vector element value.",6,[[],["u8"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[],["u8"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[],["u8"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[],["u8"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",6,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",6,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",6,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",6,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m8x8"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m8x8"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m8x8"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m8x8"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m8x8"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m8x8"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[["self"]],[["lexicographicallyordered",["u8x8"]],["u8x8"]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[["self"]],[["lexicographicallyordered",["u8x8"]],["u8x8"]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[["bool"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[["bool"]],["self"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]],["bool"]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]],["bool"]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["usize"],["bool"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["usize"],["bool"]],["self"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[],["bool"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[],["bool"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[],["bool"]]],[11,"all","","Are `all` vector lanes `true`?",6,[[],["bool"]]],[11,"any","","Is `any` vector lane `true`?",6,[[],["bool"]]],[11,"none","","Are `all` vector lanes `false`?",6,[[],["bool"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m8x8"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m8x8"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m8x8"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m8x8"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m8x8"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m8x8"]]],[11,"select","","Selects elements of `a` and `b` using mask.",6,[[["simd"]],["simd"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[["self"]],[["lexicographicallyordered",["m8x8"]],["m8x8"]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[["self"]],[["lexicographicallyordered",["m8x8"]],["m8x8"]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[["i16"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[["i16"]],["self"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]],["i16"]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]],["i16"]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["usize"],["i16"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["usize"],["i16"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["i16x4"]],["i16x4"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["i16x4"]],["i16x4"]]],[11,"min","","Minimum of two vectors.",6,[[],["self"]]],[11,"max","","Maximum of two vectors.",6,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[],["i16"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[],["i16"]]],[11,"max_element","","Largest vector element value.",6,[[],["i16"]]],[11,"min_element","","Smallest vector element value.",6,[[],["i16"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[],["i16"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[],["i16"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[],["i16"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",6,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",6,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",6,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",6,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m16x4"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m16x4"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m16x4"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m16x4"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m16x4"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m16x4"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[["self"]],[["lexicographicallyordered",["i16x4"]],["i16x4"]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[["self"]],[["lexicographicallyordered",["i16x4"]],["i16x4"]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[["u16"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[["u16"]],["self"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]],["u16"]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]],["u16"]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["u16"],["usize"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["u16"],["usize"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["u16x4"]],["u16x4"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["u16x4"]],["u16x4"]]],[11,"min","","Minimum of two vectors.",6,[[],["self"]]],[11,"max","","Maximum of two vectors.",6,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[],["u16"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[],["u16"]]],[11,"max_element","","Largest vector element value.",6,[[],["u16"]]],[11,"min_element","","Smallest vector element value.",6,[[],["u16"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[],["u16"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[],["u16"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[],["u16"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",6,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",6,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",6,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",6,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m16x4"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m16x4"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m16x4"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m16x4"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m16x4"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m16x4"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[["self"]],[["lexicographicallyordered",["u16x4"]],["u16x4"]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[["self"]],[["lexicographicallyordered",["u16x4"]],["u16x4"]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[["bool"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[["bool"]],["self"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]],["bool"]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]],["bool"]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["usize"],["bool"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["usize"],["bool"]],["self"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[],["bool"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[],["bool"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[],["bool"]]],[11,"all","","Are `all` vector lanes `true`?",6,[[],["bool"]]],[11,"any","","Is `any` vector lane `true`?",6,[[],["bool"]]],[11,"none","","Are `all` vector lanes `false`?",6,[[],["bool"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m16x4"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m16x4"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m16x4"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m16x4"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m16x4"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m16x4"]]],[11,"select","","Selects elements of `a` and `b` using mask.",6,[[["simd"]],["simd"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[["self"]],[["lexicographicallyordered",["m16x4"]],["m16x4"]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[["self"]],[["lexicographicallyordered",["m16x4"]],["m16x4"]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[["i32"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[["i32"]],["self"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]],["i32"]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]],["i32"]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["usize"],["i32"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["usize"],["i32"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["i32x2"]],["i32x2"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["i32x2"]],["i32x2"]]],[11,"min","","Minimum of two vectors.",6,[[],["self"]]],[11,"max","","Maximum of two vectors.",6,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[],["i32"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[],["i32"]]],[11,"max_element","","Largest vector element value.",6,[[],["i32"]]],[11,"min_element","","Smallest vector element value.",6,[[],["i32"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[],["i32"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[],["i32"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[],["i32"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",6,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",6,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",6,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",6,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m32x2"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m32x2"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m32x2"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m32x2"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m32x2"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m32x2"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[["self"]],[["i32x2"],["lexicographicallyordered",["i32x2"]]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[["self"]],[["i32x2"],["lexicographicallyordered",["i32x2"]]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[["u32"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[["u32"]],["self"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]],["u32"]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]],["u32"]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["u32"],["usize"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["u32"],["usize"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["u32x2"]],["u32x2"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["u32x2"]],["u32x2"]]],[11,"min","","Minimum of two vectors.",6,[[],["self"]]],[11,"max","","Maximum of two vectors.",6,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[],["u32"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[],["u32"]]],[11,"max_element","","Largest vector element value.",6,[[],["u32"]]],[11,"min_element","","Smallest vector element value.",6,[[],["u32"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[],["u32"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[],["u32"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[],["u32"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",6,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",6,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",6,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",6,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m32x2"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m32x2"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m32x2"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m32x2"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m32x2"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m32x2"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[["self"]],[["u32x2"],["lexicographicallyordered",["u32x2"]]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[["self"]],[["u32x2"],["lexicographicallyordered",["u32x2"]]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[["bool"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[["bool"]],["self"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]],["bool"]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]],["bool"]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["usize"],["bool"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["usize"],["bool"]],["self"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[],["bool"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[],["bool"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[],["bool"]]],[11,"all","","Are `all` vector lanes `true`?",6,[[],["bool"]]],[11,"any","","Is `any` vector lane `true`?",6,[[],["bool"]]],[11,"none","","Are `all` vector lanes `false`?",6,[[],["bool"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m32x2"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m32x2"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m32x2"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m32x2"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m32x2"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m32x2"]]],[11,"select","","Selects elements of `a` and `b` using mask.",6,[[["simd"]],["simd"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[["self"]],[["lexicographicallyordered",["m32x2"]],["m32x2"]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[["self"]],[["lexicographicallyordered",["m32x2"]],["m32x2"]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[["f32"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[["f32"]],["self"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]],["f32"]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]],["f32"]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["f32"],["usize"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["f32"],["usize"]],["self"]]],[11,"min","","Minimum of two vectors.",6,[[],["self"]]],[11,"max","","Maximum of two vectors.",6,[[],["self"]]],[11,"sum","","Horizontal sum of the vector elements.",6,[[],["f32"]]],[11,"product","","Horizontal product of the vector elements.",6,[[],["f32"]]],[11,"max_element","","Largest vector element value.",6,[[],["f32"]]],[11,"min_element","","Smallest vector element value.",6,[[],["f32"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[18,"EPSILON","","Machine epsilon value.",6,null],[18,"MIN","","Smallest finite value.",6,null],[18,"MIN_POSITIVE","","Smallest positive normal value.",6,null],[18,"MAX","","Largest finite value.",6,null],[18,"NAN","","Not a Number (NaN).",6,null],[18,"INFINITY","","Infinity (∞).",6,null],[18,"NEG_INFINITY","","Negative infinity (-∞).",6,null],[18,"PI","","Archimedes' constant (π)",6,null],[18,"FRAC_PI_2","","π/2",6,null],[18,"FRAC_PI_3","","π/3",6,null],[18,"FRAC_PI_4","","π/4",6,null],[18,"FRAC_PI_6","","π/6",6,null],[18,"FRAC_PI_8","","π/8",6,null],[18,"FRAC_1_PI","","1/π",6,null],[18,"FRAC_2_PI","","2/π",6,null],[18,"FRAC_2_SQRT_PI","","2/sqrt(π)",6,null],[18,"SQRT_2","","sqrt(2)",6,null],[18,"FRAC_1_SQRT_2","","1/sqrt(2)",6,null],[18,"E","","Euler's number (e)",6,null],[18,"LOG2_E","","log2(e)",6,null],[18,"LOG10_E","","log10(e)",6,null],[18,"LN_2","","ln(2)",6,null],[18,"LN_10","","ln(10)",6,null],[11,"is_nan","","",6,[[],["m32x2"]]],[11,"is_infinite","","",6,[[],["m32x2"]]],[11,"is_finite","","",6,[[],["m32x2"]]],[11,"abs","","Absolute value.",6,[[],["self"]]],[11,"cos","","Cosine.",6,[[],["self"]]],[11,"cos_pi","","Cosine of `self * PI`.",6,[[],["self"]]],[11,"exp","","Returns the exponential function of `self`: `e^(self)`.",6,[[],["self"]]],[11,"ln","","Returns the natural logarithm of `self`.",6,[[],["self"]]],[11,"mul_add","","Fused multiply add: `self * y + z`",6,[[],["self"]]],[11,"mul_adde","","Fused multiply add estimate: ~= `self * y + z`",6,[[],["self"]]],[11,"powf","","Raises `self` number to the floating point power of `x`.",6,[[],["self"]]],[11,"recpre","","Reciprocal estimate: `~= 1. / self`.",6,[[],["self"]]],[11,"rsqrte","","Reciprocal square-root estimate: `~= 1. / self.sqrt()`.",6,[[],["self"]]],[11,"sin","","Sine.",6,[[],["self"]]],[11,"sin_pi","","Sine of `self * PI`.",6,[[],["self"]]],[11,"sin_cos_pi","","Sine and cosine of `self * PI`.",6,[[]]],[11,"sqrt","","",6,[[],["self"]]],[11,"sqrte","","Square-root estimate.",6,[[],["self"]]],[11,"tanh","","Tanh.",6,[[],["self"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m32x2"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m32x2"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m32x2"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m32x2"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m32x2"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m32x2"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[["i8"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[["i8"]],["self"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]],["i8"]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]],["i8"]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["i8"],["usize"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["i8"],["usize"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["i8x16"]],["i8x16"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["i8x16"]],["i8x16"]]],[11,"min","","Minimum of two vectors.",6,[[],["self"]]],[11,"max","","Maximum of two vectors.",6,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[],["i8"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[],["i8"]]],[11,"max_element","","Largest vector element value.",6,[[],["i8"]]],[11,"min_element","","Smallest vector element value.",6,[[],["i8"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[],["i8"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[],["i8"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[],["i8"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",6,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",6,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",6,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",6,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m8x16"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m8x16"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m8x16"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m8x16"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m8x16"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m8x16"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[["self"]],[["i8x16"],["lexicographicallyordered",["i8x16"]]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[["self"]],[["i8x16"],["lexicographicallyordered",["i8x16"]]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[],["u16"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[["u8"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[["u8"]],["self"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]],["u8"]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]],["u8"]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["usize"],["u8"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["usize"],["u8"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["u8x16"]],["u8x16"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["u8x16"]],["u8x16"]]],[11,"min","","Minimum of two vectors.",6,[[],["self"]]],[11,"max","","Maximum of two vectors.",6,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[],["u8"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[],["u8"]]],[11,"max_element","","Largest vector element value.",6,[[],["u8"]]],[11,"min_element","","Smallest vector element value.",6,[[],["u8"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[],["u8"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[],["u8"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[],["u8"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",6,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",6,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",6,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",6,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m8x16"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m8x16"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m8x16"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m8x16"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m8x16"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m8x16"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[["self"]],[["lexicographicallyordered",["u8x16"]],["u8x16"]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[["self"]],[["lexicographicallyordered",["u8x16"]],["u8x16"]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[],["u16"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[["bool"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[["bool"]],["self"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]],["bool"]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]],["bool"]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["usize"],["bool"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["usize"],["bool"]],["self"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[],["bool"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[],["bool"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[],["bool"]]],[11,"all","","Are `all` vector lanes `true`?",6,[[],["bool"]]],[11,"any","","Is `any` vector lane `true`?",6,[[],["bool"]]],[11,"none","","Are `all` vector lanes `false`?",6,[[],["bool"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m8x16"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m8x16"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m8x16"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m8x16"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m8x16"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m8x16"]]],[11,"select","","Selects elements of `a` and `b` using mask.",6,[[["simd"]],["simd"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[["self"]],[["m8x16"],["lexicographicallyordered",["m8x16"]]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[["self"]],[["m8x16"],["lexicographicallyordered",["m8x16"]]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[],["u16"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[["i16"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[["i16"]],["self"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]],["i16"]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]],["i16"]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["usize"],["i16"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["usize"],["i16"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["i16x8"]],["i16x8"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["i16x8"]],["i16x8"]]],[11,"min","","Minimum of two vectors.",6,[[],["self"]]],[11,"max","","Maximum of two vectors.",6,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[],["i16"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[],["i16"]]],[11,"max_element","","Largest vector element value.",6,[[],["i16"]]],[11,"min_element","","Smallest vector element value.",6,[[],["i16"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[],["i16"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[],["i16"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[],["i16"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",6,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",6,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",6,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",6,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m16x8"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m16x8"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m16x8"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m16x8"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m16x8"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m16x8"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[["self"]],[["lexicographicallyordered",["i16x8"]],["i16x8"]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[["self"]],[["lexicographicallyordered",["i16x8"]],["i16x8"]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[["u16"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[["u16"]],["self"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]],["u16"]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]],["u16"]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["u16"],["usize"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["u16"],["usize"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["u16x8"]],["u16x8"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["u16x8"]],["u16x8"]]],[11,"min","","Minimum of two vectors.",6,[[],["self"]]],[11,"max","","Maximum of two vectors.",6,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[],["u16"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[],["u16"]]],[11,"max_element","","Largest vector element value.",6,[[],["u16"]]],[11,"min_element","","Smallest vector element value.",6,[[],["u16"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[],["u16"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[],["u16"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[],["u16"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",6,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",6,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",6,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",6,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m16x8"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m16x8"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m16x8"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m16x8"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m16x8"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m16x8"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[["self"]],[["lexicographicallyordered",["u16x8"]],["u16x8"]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[["self"]],[["lexicographicallyordered",["u16x8"]],["u16x8"]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[["bool"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[["bool"]],["self"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]],["bool"]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]],["bool"]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["usize"],["bool"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["usize"],["bool"]],["self"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[],["bool"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[],["bool"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[],["bool"]]],[11,"all","","Are `all` vector lanes `true`?",6,[[],["bool"]]],[11,"any","","Is `any` vector lane `true`?",6,[[],["bool"]]],[11,"none","","Are `all` vector lanes `false`?",6,[[],["bool"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m16x8"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m16x8"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m16x8"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m16x8"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m16x8"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m16x8"]]],[11,"select","","Selects elements of `a` and `b` using mask.",6,[[["simd"]],["simd"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[["self"]],[["m16x8"],["lexicographicallyordered",["m16x8"]]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[["self"]],[["m16x8"],["lexicographicallyordered",["m16x8"]]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[["i32"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[["i32"]],["self"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]],["i32"]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]],["i32"]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["usize"],["i32"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["usize"],["i32"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["i32x4"]],["i32x4"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["i32x4"]],["i32x4"]]],[11,"min","","Minimum of two vectors.",6,[[],["self"]]],[11,"max","","Maximum of two vectors.",6,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[],["i32"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[],["i32"]]],[11,"max_element","","Largest vector element value.",6,[[],["i32"]]],[11,"min_element","","Smallest vector element value.",6,[[],["i32"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[],["i32"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[],["i32"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[],["i32"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",6,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",6,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",6,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",6,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m32x4"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m32x4"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m32x4"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m32x4"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m32x4"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m32x4"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[["self"]],[["i32x4"],["lexicographicallyordered",["i32x4"]]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[["self"]],[["i32x4"],["lexicographicallyordered",["i32x4"]]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[["u32"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[["u32"]],["self"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]],["u32"]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]],["u32"]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["u32"],["usize"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["u32"],["usize"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["u32x4"]],["u32x4"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["u32x4"]],["u32x4"]]],[11,"min","","Minimum of two vectors.",6,[[],["self"]]],[11,"max","","Maximum of two vectors.",6,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[],["u32"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[],["u32"]]],[11,"max_element","","Largest vector element value.",6,[[],["u32"]]],[11,"min_element","","Smallest vector element value.",6,[[],["u32"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[],["u32"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[],["u32"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[],["u32"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",6,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",6,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",6,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",6,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m32x4"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m32x4"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m32x4"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m32x4"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m32x4"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m32x4"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[["self"]],[["u32x4"],["lexicographicallyordered",["u32x4"]]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[["self"]],[["u32x4"],["lexicographicallyordered",["u32x4"]]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[["f32"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[["f32"]],["self"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]],["f32"]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]],["f32"]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["f32"],["usize"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["f32"],["usize"]],["self"]]],[11,"min","","Minimum of two vectors.",6,[[],["self"]]],[11,"max","","Maximum of two vectors.",6,[[],["self"]]],[11,"sum","","Horizontal sum of the vector elements.",6,[[],["f32"]]],[11,"product","","Horizontal product of the vector elements.",6,[[],["f32"]]],[11,"max_element","","Largest vector element value.",6,[[],["f32"]]],[11,"min_element","","Smallest vector element value.",6,[[],["f32"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[18,"EPSILON","","Machine epsilon value.",6,null],[18,"MIN","","Smallest finite value.",6,null],[18,"MIN_POSITIVE","","Smallest positive normal value.",6,null],[18,"MAX","","Largest finite value.",6,null],[18,"NAN","","Not a Number (NaN).",6,null],[18,"INFINITY","","Infinity (∞).",6,null],[18,"NEG_INFINITY","","Negative infinity (-∞).",6,null],[18,"PI","","Archimedes' constant (π)",6,null],[18,"FRAC_PI_2","","π/2",6,null],[18,"FRAC_PI_3","","π/3",6,null],[18,"FRAC_PI_4","","π/4",6,null],[18,"FRAC_PI_6","","π/6",6,null],[18,"FRAC_PI_8","","π/8",6,null],[18,"FRAC_1_PI","","1/π",6,null],[18,"FRAC_2_PI","","2/π",6,null],[18,"FRAC_2_SQRT_PI","","2/sqrt(π)",6,null],[18,"SQRT_2","","sqrt(2)",6,null],[18,"FRAC_1_SQRT_2","","1/sqrt(2)",6,null],[18,"E","","Euler's number (e)",6,null],[18,"LOG2_E","","log2(e)",6,null],[18,"LOG10_E","","log10(e)",6,null],[18,"LN_2","","ln(2)",6,null],[18,"LN_10","","ln(10)",6,null],[11,"is_nan","","",6,[[],["m32x4"]]],[11,"is_infinite","","",6,[[],["m32x4"]]],[11,"is_finite","","",6,[[],["m32x4"]]],[11,"abs","","Absolute value.",6,[[],["self"]]],[11,"cos","","Cosine.",6,[[],["self"]]],[11,"cos_pi","","Cosine of `self * PI`.",6,[[],["self"]]],[11,"exp","","Returns the exponential function of `self`: `e^(self)`.",6,[[],["self"]]],[11,"ln","","Returns the natural logarithm of `self`.",6,[[],["self"]]],[11,"mul_add","","Fused multiply add: `self * y + z`",6,[[],["self"]]],[11,"mul_adde","","Fused multiply add estimate: ~= `self * y + z`",6,[[],["self"]]],[11,"powf","","Raises `self` number to the floating point power of `x`.",6,[[],["self"]]],[11,"recpre","","Reciprocal estimate: `~= 1. / self`.",6,[[],["self"]]],[11,"rsqrte","","Reciprocal square-root estimate: `~= 1. / self.sqrt()`.",6,[[],["self"]]],[11,"sin","","Sine.",6,[[],["self"]]],[11,"sin_pi","","Sine of `self * PI`.",6,[[],["self"]]],[11,"sin_cos_pi","","Sine and cosine of `self * PI`.",6,[[]]],[11,"sqrt","","",6,[[],["self"]]],[11,"sqrte","","Square-root estimate.",6,[[],["self"]]],[11,"tanh","","Tanh.",6,[[],["self"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m32x4"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m32x4"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m32x4"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m32x4"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m32x4"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m32x4"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[["bool"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[["bool"]],["self"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]],["bool"]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]],["bool"]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["usize"],["bool"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["usize"],["bool"]],["self"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[],["bool"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[],["bool"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[],["bool"]]],[11,"all","","Are `all` vector lanes `true`?",6,[[],["bool"]]],[11,"any","","Is `any` vector lane `true`?",6,[[],["bool"]]],[11,"none","","Are `all` vector lanes `false`?",6,[[],["bool"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m32x4"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m32x4"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m32x4"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m32x4"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m32x4"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m32x4"]]],[11,"select","","Selects elements of `a` and `b` using mask.",6,[[["simd"]],["simd"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[["self"]],[["lexicographicallyordered",["m32x4"]],["m32x4"]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[["self"]],[["lexicographicallyordered",["m32x4"]],["m32x4"]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[["i64"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[["i64"]],["self"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]],["i64"]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]],["i64"]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["i64"],["usize"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["i64"],["usize"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["i64x2"]],["i64x2"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["i64x2"]],["i64x2"]]],[11,"min","","Minimum of two vectors.",6,[[],["self"]]],[11,"max","","Maximum of two vectors.",6,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[],["i64"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[],["i64"]]],[11,"max_element","","Largest vector element value.",6,[[],["i64"]]],[11,"min_element","","Smallest vector element value.",6,[[],["i64"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[],["i64"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[],["i64"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[],["i64"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",6,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",6,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",6,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",6,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m64x2"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m64x2"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m64x2"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m64x2"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m64x2"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m64x2"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[["self"]],[["i64x2"],["lexicographicallyordered",["i64x2"]]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[["self"]],[["i64x2"],["lexicographicallyordered",["i64x2"]]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[["u64"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[["u64"]],["self"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]],["u64"]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]],["u64"]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["usize"],["u64"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["usize"],["u64"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["u64x2"]],["u64x2"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["u64x2"]],["u64x2"]]],[11,"min","","Minimum of two vectors.",6,[[],["self"]]],[11,"max","","Maximum of two vectors.",6,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[],["u64"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[],["u64"]]],[11,"max_element","","Largest vector element value.",6,[[],["u64"]]],[11,"min_element","","Smallest vector element value.",6,[[],["u64"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[],["u64"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[],["u64"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[],["u64"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",6,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",6,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",6,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",6,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m64x2"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m64x2"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m64x2"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m64x2"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m64x2"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m64x2"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[["self"]],[["u64x2"],["lexicographicallyordered",["u64x2"]]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[["self"]],[["u64x2"],["lexicographicallyordered",["u64x2"]]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[["f64"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[["f64"]],["self"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]],["f64"]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]],["f64"]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["f64"],["usize"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["f64"],["usize"]],["self"]]],[11,"min","","Minimum of two vectors.",6,[[],["self"]]],[11,"max","","Maximum of two vectors.",6,[[],["self"]]],[11,"sum","","Horizontal sum of the vector elements.",6,[[],["f64"]]],[11,"product","","Horizontal product of the vector elements.",6,[[],["f64"]]],[11,"max_element","","Largest vector element value.",6,[[],["f64"]]],[11,"min_element","","Smallest vector element value.",6,[[],["f64"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[18,"EPSILON","","Machine epsilon value.",6,null],[18,"MIN","","Smallest finite value.",6,null],[18,"MIN_POSITIVE","","Smallest positive normal value.",6,null],[18,"MAX","","Largest finite value.",6,null],[18,"NAN","","Not a Number (NaN).",6,null],[18,"INFINITY","","Infinity (∞).",6,null],[18,"NEG_INFINITY","","Negative infinity (-∞).",6,null],[18,"PI","","Archimedes' constant (π)",6,null],[18,"FRAC_PI_2","","π/2",6,null],[18,"FRAC_PI_3","","π/3",6,null],[18,"FRAC_PI_4","","π/4",6,null],[18,"FRAC_PI_6","","π/6",6,null],[18,"FRAC_PI_8","","π/8",6,null],[18,"FRAC_1_PI","","1/π",6,null],[18,"FRAC_2_PI","","2/π",6,null],[18,"FRAC_2_SQRT_PI","","2/sqrt(π)",6,null],[18,"SQRT_2","","sqrt(2)",6,null],[18,"FRAC_1_SQRT_2","","1/sqrt(2)",6,null],[18,"E","","Euler's number (e)",6,null],[18,"LOG2_E","","log2(e)",6,null],[18,"LOG10_E","","log10(e)",6,null],[18,"LN_2","","ln(2)",6,null],[18,"LN_10","","ln(10)",6,null],[11,"is_nan","","",6,[[],["m64x2"]]],[11,"is_infinite","","",6,[[],["m64x2"]]],[11,"is_finite","","",6,[[],["m64x2"]]],[11,"abs","","Absolute value.",6,[[],["self"]]],[11,"cos","","Cosine.",6,[[],["self"]]],[11,"cos_pi","","Cosine of `self * PI`.",6,[[],["self"]]],[11,"exp","","Returns the exponential function of `self`: `e^(self)`.",6,[[],["self"]]],[11,"ln","","Returns the natural logarithm of `self`.",6,[[],["self"]]],[11,"mul_add","","Fused multiply add: `self * y + z`",6,[[],["self"]]],[11,"mul_adde","","Fused multiply add estimate: ~= `self * y + z`",6,[[],["self"]]],[11,"powf","","Raises `self` number to the floating point power of `x`.",6,[[],["self"]]],[11,"recpre","","Reciprocal estimate: `~= 1. / self`.",6,[[],["self"]]],[11,"rsqrte","","Reciprocal square-root estimate: `~= 1. / self.sqrt()`.",6,[[],["self"]]],[11,"sin","","Sine.",6,[[],["self"]]],[11,"sin_pi","","Sine of `self * PI`.",6,[[],["self"]]],[11,"sin_cos_pi","","Sine and cosine of `self * PI`.",6,[[]]],[11,"sqrt","","",6,[[],["self"]]],[11,"sqrte","","Square-root estimate.",6,[[],["self"]]],[11,"tanh","","Tanh.",6,[[],["self"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m64x2"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m64x2"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m64x2"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m64x2"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m64x2"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m64x2"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[["bool"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[["bool"]],["self"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]],["bool"]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]],["bool"]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["usize"],["bool"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["usize"],["bool"]],["self"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[],["bool"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[],["bool"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[],["bool"]]],[11,"all","","Are `all` vector lanes `true`?",6,[[],["bool"]]],[11,"any","","Is `any` vector lane `true`?",6,[[],["bool"]]],[11,"none","","Are `all` vector lanes `false`?",6,[[],["bool"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m64x2"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m64x2"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m64x2"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m64x2"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m64x2"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m64x2"]]],[11,"select","","Selects elements of `a` and `b` using mask.",6,[[["simd"]],["simd"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[["self"]],[["m64x2"],["lexicographicallyordered",["m64x2"]]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[["self"]],[["m64x2"],["lexicographicallyordered",["m64x2"]]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[["i128"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[["i128"]],["self"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]],["i128"]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]],["i128"]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["i128"],["usize"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["i128"],["usize"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["i128x1"]],["i128x1"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["i128x1"]],["i128x1"]]],[11,"min","","Minimum of two vectors.",6,[[],["self"]]],[11,"max","","Maximum of two vectors.",6,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[],["i128"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[],["i128"]]],[11,"max_element","","Largest vector element value.",6,[[],["i128"]]],[11,"min_element","","Smallest vector element value.",6,[[],["i128"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[],["i128"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[],["i128"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[],["i128"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",6,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",6,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",6,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",6,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m128x1"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m128x1"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m128x1"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m128x1"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m128x1"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m128x1"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[["self"]],[["lexicographicallyordered",["i128x1"]],["i128x1"]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[["self"]],[["lexicographicallyordered",["i128x1"]],["i128x1"]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[["u128"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[["u128"]],["self"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]],["u128"]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]],["u128"]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["usize"],["u128"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["usize"],["u128"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["u128x1"]],["u128x1"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["u128x1"]],["u128x1"]]],[11,"min","","Minimum of two vectors.",6,[[],["self"]]],[11,"max","","Maximum of two vectors.",6,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[],["u128"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[],["u128"]]],[11,"max_element","","Largest vector element value.",6,[[],["u128"]]],[11,"min_element","","Smallest vector element value.",6,[[],["u128"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[],["u128"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[],["u128"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[],["u128"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",6,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",6,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",6,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",6,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m128x1"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m128x1"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m128x1"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m128x1"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m128x1"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m128x1"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[["self"]],[["u128x1"],["lexicographicallyordered",["u128x1"]]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[["self"]],[["u128x1"],["lexicographicallyordered",["u128x1"]]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[["bool"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[["bool"]],["self"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]],["bool"]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]],["bool"]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["usize"],["bool"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["usize"],["bool"]],["self"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[],["bool"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[],["bool"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[],["bool"]]],[11,"all","","Are `all` vector lanes `true`?",6,[[],["bool"]]],[11,"any","","Is `any` vector lane `true`?",6,[[],["bool"]]],[11,"none","","Are `all` vector lanes `false`?",6,[[],["bool"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m128x1"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m128x1"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m128x1"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m128x1"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m128x1"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m128x1"]]],[11,"select","","Selects elements of `a` and `b` using mask.",6,[[["simd"]],["simd"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[["self"]],[["m128x1"],["lexicographicallyordered",["m128x1"]]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[["self"]],[["m128x1"],["lexicographicallyordered",["m128x1"]]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[["i8"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[["i8"]],["self"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]],["i8"]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]],["i8"]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["i8"],["usize"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["i8"],["usize"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["i8x32"]],["i8x32"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["i8x32"]],["i8x32"]]],[11,"min","","Minimum of two vectors.",6,[[],["self"]]],[11,"max","","Maximum of two vectors.",6,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[],["i8"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[],["i8"]]],[11,"max_element","","Largest vector element value.",6,[[],["i8"]]],[11,"min_element","","Smallest vector element value.",6,[[],["i8"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[],["i8"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[],["i8"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[],["i8"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",6,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",6,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",6,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",6,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m8x32"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m8x32"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m8x32"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m8x32"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m8x32"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m8x32"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[["self"]],[["i8x32"],["lexicographicallyordered",["i8x32"]]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[["self"]],[["i8x32"],["lexicographicallyordered",["i8x32"]]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[],["u32"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[["u8"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[["u8"]],["self"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]],["u8"]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]],["u8"]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["usize"],["u8"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["usize"],["u8"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["u8x32"]],["u8x32"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["u8x32"]],["u8x32"]]],[11,"min","","Minimum of two vectors.",6,[[],["self"]]],[11,"max","","Maximum of two vectors.",6,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[],["u8"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[],["u8"]]],[11,"max_element","","Largest vector element value.",6,[[],["u8"]]],[11,"min_element","","Smallest vector element value.",6,[[],["u8"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[],["u8"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[],["u8"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[],["u8"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",6,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",6,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",6,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",6,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m8x32"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m8x32"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m8x32"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m8x32"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m8x32"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m8x32"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[["self"]],[["lexicographicallyordered",["u8x32"]],["u8x32"]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[["self"]],[["lexicographicallyordered",["u8x32"]],["u8x32"]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[],["u32"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[["bool"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[["bool"]],["self"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]],["bool"]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]],["bool"]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["usize"],["bool"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["usize"],["bool"]],["self"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[],["bool"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[],["bool"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[],["bool"]]],[11,"all","","Are `all` vector lanes `true`?",6,[[],["bool"]]],[11,"any","","Is `any` vector lane `true`?",6,[[],["bool"]]],[11,"none","","Are `all` vector lanes `false`?",6,[[],["bool"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m8x32"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m8x32"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m8x32"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m8x32"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m8x32"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m8x32"]]],[11,"select","","Selects elements of `a` and `b` using mask.",6,[[["simd"]],["simd"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[["self"]],[["m8x32"],["lexicographicallyordered",["m8x32"]]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[["self"]],[["m8x32"],["lexicographicallyordered",["m8x32"]]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[],["u32"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[["i16"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[["i16"]],["self"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]],["i16"]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]],["i16"]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["usize"],["i16"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["usize"],["i16"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["i16x16"]],["i16x16"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["i16x16"]],["i16x16"]]],[11,"min","","Minimum of two vectors.",6,[[],["self"]]],[11,"max","","Maximum of two vectors.",6,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[],["i16"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[],["i16"]]],[11,"max_element","","Largest vector element value.",6,[[],["i16"]]],[11,"min_element","","Smallest vector element value.",6,[[],["i16"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[],["i16"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[],["i16"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[],["i16"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",6,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",6,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",6,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",6,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m16x16"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m16x16"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m16x16"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m16x16"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m16x16"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m16x16"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[["self"]],[["lexicographicallyordered",["i16x16"]],["i16x16"]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[["self"]],[["lexicographicallyordered",["i16x16"]],["i16x16"]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[],["u16"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[["u16"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[["u16"]],["self"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]],["u16"]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]],["u16"]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["u16"],["usize"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["u16"],["usize"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["u16x16"]],["u16x16"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["u16x16"]],["u16x16"]]],[11,"min","","Minimum of two vectors.",6,[[],["self"]]],[11,"max","","Maximum of two vectors.",6,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[],["u16"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[],["u16"]]],[11,"max_element","","Largest vector element value.",6,[[],["u16"]]],[11,"min_element","","Smallest vector element value.",6,[[],["u16"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[],["u16"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[],["u16"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[],["u16"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",6,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",6,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",6,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",6,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m16x16"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m16x16"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m16x16"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m16x16"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m16x16"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m16x16"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[["self"]],[["u16x16"],["lexicographicallyordered",["u16x16"]]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[["self"]],[["u16x16"],["lexicographicallyordered",["u16x16"]]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[],["u16"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[["bool"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[["bool"]],["self"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]],["bool"]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]],["bool"]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["usize"],["bool"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["usize"],["bool"]],["self"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[],["bool"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[],["bool"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[],["bool"]]],[11,"all","","Are `all` vector lanes `true`?",6,[[],["bool"]]],[11,"any","","Is `any` vector lane `true`?",6,[[],["bool"]]],[11,"none","","Are `all` vector lanes `false`?",6,[[],["bool"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m16x16"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m16x16"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m16x16"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m16x16"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m16x16"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m16x16"]]],[11,"select","","Selects elements of `a` and `b` using mask.",6,[[["simd"]],["simd"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[["self"]],[["lexicographicallyordered",["m16x16"]],["m16x16"]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[["self"]],[["lexicographicallyordered",["m16x16"]],["m16x16"]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[],["u16"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[["i32"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[["i32"]],["self"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]],["i32"]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]],["i32"]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["usize"],["i32"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["usize"],["i32"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["i32x8"]],["i32x8"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["i32x8"]],["i32x8"]]],[11,"min","","Minimum of two vectors.",6,[[],["self"]]],[11,"max","","Maximum of two vectors.",6,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[],["i32"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[],["i32"]]],[11,"max_element","","Largest vector element value.",6,[[],["i32"]]],[11,"min_element","","Smallest vector element value.",6,[[],["i32"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[],["i32"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[],["i32"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[],["i32"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",6,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",6,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",6,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",6,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m32x8"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m32x8"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m32x8"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m32x8"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m32x8"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m32x8"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[["self"]],[["i32x8"],["lexicographicallyordered",["i32x8"]]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[["self"]],[["i32x8"],["lexicographicallyordered",["i32x8"]]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[["u32"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[["u32"]],["self"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]],["u32"]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]],["u32"]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["u32"],["usize"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["u32"],["usize"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["u32x8"]],["u32x8"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["u32x8"]],["u32x8"]]],[11,"min","","Minimum of two vectors.",6,[[],["self"]]],[11,"max","","Maximum of two vectors.",6,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[],["u32"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[],["u32"]]],[11,"max_element","","Largest vector element value.",6,[[],["u32"]]],[11,"min_element","","Smallest vector element value.",6,[[],["u32"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[],["u32"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[],["u32"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[],["u32"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",6,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",6,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",6,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",6,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m32x8"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m32x8"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m32x8"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m32x8"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m32x8"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m32x8"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[["self"]],[["lexicographicallyordered",["u32x8"]],["u32x8"]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[["self"]],[["lexicographicallyordered",["u32x8"]],["u32x8"]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[["f32"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[["f32"]],["self"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]],["f32"]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]],["f32"]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["f32"],["usize"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["f32"],["usize"]],["self"]]],[11,"min","","Minimum of two vectors.",6,[[],["self"]]],[11,"max","","Maximum of two vectors.",6,[[],["self"]]],[11,"sum","","Horizontal sum of the vector elements.",6,[[],["f32"]]],[11,"product","","Horizontal product of the vector elements.",6,[[],["f32"]]],[11,"max_element","","Largest vector element value.",6,[[],["f32"]]],[11,"min_element","","Smallest vector element value.",6,[[],["f32"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[18,"EPSILON","","Machine epsilon value.",6,null],[18,"MIN","","Smallest finite value.",6,null],[18,"MIN_POSITIVE","","Smallest positive normal value.",6,null],[18,"MAX","","Largest finite value.",6,null],[18,"NAN","","Not a Number (NaN).",6,null],[18,"INFINITY","","Infinity (∞).",6,null],[18,"NEG_INFINITY","","Negative infinity (-∞).",6,null],[18,"PI","","Archimedes' constant (π)",6,null],[18,"FRAC_PI_2","","π/2",6,null],[18,"FRAC_PI_3","","π/3",6,null],[18,"FRAC_PI_4","","π/4",6,null],[18,"FRAC_PI_6","","π/6",6,null],[18,"FRAC_PI_8","","π/8",6,null],[18,"FRAC_1_PI","","1/π",6,null],[18,"FRAC_2_PI","","2/π",6,null],[18,"FRAC_2_SQRT_PI","","2/sqrt(π)",6,null],[18,"SQRT_2","","sqrt(2)",6,null],[18,"FRAC_1_SQRT_2","","1/sqrt(2)",6,null],[18,"E","","Euler's number (e)",6,null],[18,"LOG2_E","","log2(e)",6,null],[18,"LOG10_E","","log10(e)",6,null],[18,"LN_2","","ln(2)",6,null],[18,"LN_10","","ln(10)",6,null],[11,"is_nan","","",6,[[],["m32x8"]]],[11,"is_infinite","","",6,[[],["m32x8"]]],[11,"is_finite","","",6,[[],["m32x8"]]],[11,"abs","","Absolute value.",6,[[],["self"]]],[11,"cos","","Cosine.",6,[[],["self"]]],[11,"cos_pi","","Cosine of `self * PI`.",6,[[],["self"]]],[11,"exp","","Returns the exponential function of `self`: `e^(self)`.",6,[[],["self"]]],[11,"ln","","Returns the natural logarithm of `self`.",6,[[],["self"]]],[11,"mul_add","","Fused multiply add: `self * y + z`",6,[[],["self"]]],[11,"mul_adde","","Fused multiply add estimate: ~= `self * y + z`",6,[[],["self"]]],[11,"powf","","Raises `self` number to the floating point power of `x`.",6,[[],["self"]]],[11,"recpre","","Reciprocal estimate: `~= 1. / self`.",6,[[],["self"]]],[11,"rsqrte","","Reciprocal square-root estimate: `~= 1. / self.sqrt()`.",6,[[],["self"]]],[11,"sin","","Sine.",6,[[],["self"]]],[11,"sin_pi","","Sine of `self * PI`.",6,[[],["self"]]],[11,"sin_cos_pi","","Sine and cosine of `self * PI`.",6,[[]]],[11,"sqrt","","",6,[[],["self"]]],[11,"sqrte","","Square-root estimate.",6,[[],["self"]]],[11,"tanh","","Tanh.",6,[[],["self"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m32x8"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m32x8"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m32x8"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m32x8"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m32x8"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m32x8"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[["bool"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[["bool"]],["self"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]],["bool"]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]],["bool"]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["usize"],["bool"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["usize"],["bool"]],["self"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[],["bool"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[],["bool"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[],["bool"]]],[11,"all","","Are `all` vector lanes `true`?",6,[[],["bool"]]],[11,"any","","Is `any` vector lane `true`?",6,[[],["bool"]]],[11,"none","","Are `all` vector lanes `false`?",6,[[],["bool"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m32x8"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m32x8"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m32x8"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m32x8"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m32x8"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m32x8"]]],[11,"select","","Selects elements of `a` and `b` using mask.",6,[[["simd"]],["simd"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[["self"]],[["m32x8"],["lexicographicallyordered",["m32x8"]]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[["self"]],[["m32x8"],["lexicographicallyordered",["m32x8"]]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[["i64"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[["i64"]],["self"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]],["i64"]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]],["i64"]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["i64"],["usize"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["i64"],["usize"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["i64x4"]],["i64x4"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["i64x4"]],["i64x4"]]],[11,"min","","Minimum of two vectors.",6,[[],["self"]]],[11,"max","","Maximum of two vectors.",6,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[],["i64"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[],["i64"]]],[11,"max_element","","Largest vector element value.",6,[[],["i64"]]],[11,"min_element","","Smallest vector element value.",6,[[],["i64"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[],["i64"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[],["i64"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[],["i64"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",6,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",6,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",6,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",6,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m64x4"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m64x4"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m64x4"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m64x4"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m64x4"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m64x4"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[["self"]],[["i64x4"],["lexicographicallyordered",["i64x4"]]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[["self"]],[["i64x4"],["lexicographicallyordered",["i64x4"]]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[["u64"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[["u64"]],["self"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]],["u64"]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]],["u64"]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["usize"],["u64"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["usize"],["u64"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["u64x4"]],["u64x4"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["u64x4"]],["u64x4"]]],[11,"min","","Minimum of two vectors.",6,[[],["self"]]],[11,"max","","Maximum of two vectors.",6,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[],["u64"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[],["u64"]]],[11,"max_element","","Largest vector element value.",6,[[],["u64"]]],[11,"min_element","","Smallest vector element value.",6,[[],["u64"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[],["u64"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[],["u64"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[],["u64"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",6,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",6,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",6,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",6,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m64x4"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m64x4"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m64x4"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m64x4"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m64x4"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m64x4"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[["self"]],[["u64x4"],["lexicographicallyordered",["u64x4"]]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[["self"]],[["u64x4"],["lexicographicallyordered",["u64x4"]]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[["f64"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[["f64"]],["self"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]],["f64"]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]],["f64"]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["f64"],["usize"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["f64"],["usize"]],["self"]]],[11,"min","","Minimum of two vectors.",6,[[],["self"]]],[11,"max","","Maximum of two vectors.",6,[[],["self"]]],[11,"sum","","Horizontal sum of the vector elements.",6,[[],["f64"]]],[11,"product","","Horizontal product of the vector elements.",6,[[],["f64"]]],[11,"max_element","","Largest vector element value.",6,[[],["f64"]]],[11,"min_element","","Smallest vector element value.",6,[[],["f64"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[18,"EPSILON","","Machine epsilon value.",6,null],[18,"MIN","","Smallest finite value.",6,null],[18,"MIN_POSITIVE","","Smallest positive normal value.",6,null],[18,"MAX","","Largest finite value.",6,null],[18,"NAN","","Not a Number (NaN).",6,null],[18,"INFINITY","","Infinity (∞).",6,null],[18,"NEG_INFINITY","","Negative infinity (-∞).",6,null],[18,"PI","","Archimedes' constant (π)",6,null],[18,"FRAC_PI_2","","π/2",6,null],[18,"FRAC_PI_3","","π/3",6,null],[18,"FRAC_PI_4","","π/4",6,null],[18,"FRAC_PI_6","","π/6",6,null],[18,"FRAC_PI_8","","π/8",6,null],[18,"FRAC_1_PI","","1/π",6,null],[18,"FRAC_2_PI","","2/π",6,null],[18,"FRAC_2_SQRT_PI","","2/sqrt(π)",6,null],[18,"SQRT_2","","sqrt(2)",6,null],[18,"FRAC_1_SQRT_2","","1/sqrt(2)",6,null],[18,"E","","Euler's number (e)",6,null],[18,"LOG2_E","","log2(e)",6,null],[18,"LOG10_E","","log10(e)",6,null],[18,"LN_2","","ln(2)",6,null],[18,"LN_10","","ln(10)",6,null],[11,"is_nan","","",6,[[],["m64x4"]]],[11,"is_infinite","","",6,[[],["m64x4"]]],[11,"is_finite","","",6,[[],["m64x4"]]],[11,"abs","","Absolute value.",6,[[],["self"]]],[11,"cos","","Cosine.",6,[[],["self"]]],[11,"cos_pi","","Cosine of `self * PI`.",6,[[],["self"]]],[11,"exp","","Returns the exponential function of `self`: `e^(self)`.",6,[[],["self"]]],[11,"ln","","Returns the natural logarithm of `self`.",6,[[],["self"]]],[11,"mul_add","","Fused multiply add: `self * y + z`",6,[[],["self"]]],[11,"mul_adde","","Fused multiply add estimate: ~= `self * y + z`",6,[[],["self"]]],[11,"powf","","Raises `self` number to the floating point power of `x`.",6,[[],["self"]]],[11,"recpre","","Reciprocal estimate: `~= 1. / self`.",6,[[],["self"]]],[11,"rsqrte","","Reciprocal square-root estimate: `~= 1. / self.sqrt()`.",6,[[],["self"]]],[11,"sin","","Sine.",6,[[],["self"]]],[11,"sin_pi","","Sine of `self * PI`.",6,[[],["self"]]],[11,"sin_cos_pi","","Sine and cosine of `self * PI`.",6,[[]]],[11,"sqrt","","",6,[[],["self"]]],[11,"sqrte","","Square-root estimate.",6,[[],["self"]]],[11,"tanh","","Tanh.",6,[[],["self"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m64x4"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m64x4"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m64x4"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m64x4"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m64x4"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m64x4"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[["bool"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[["bool"]],["self"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]],["bool"]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]],["bool"]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["usize"],["bool"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["usize"],["bool"]],["self"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[],["bool"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[],["bool"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[],["bool"]]],[11,"all","","Are `all` vector lanes `true`?",6,[[],["bool"]]],[11,"any","","Is `any` vector lane `true`?",6,[[],["bool"]]],[11,"none","","Are `all` vector lanes `false`?",6,[[],["bool"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m64x4"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m64x4"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m64x4"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m64x4"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m64x4"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m64x4"]]],[11,"select","","Selects elements of `a` and `b` using mask.",6,[[["simd"]],["simd"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[["self"]],[["lexicographicallyordered",["m64x4"]],["m64x4"]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[["self"]],[["lexicographicallyordered",["m64x4"]],["m64x4"]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[["i128"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[["i128"]],["self"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]],["i128"]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]],["i128"]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["i128"],["usize"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["i128"],["usize"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["i128x2"]],["i128x2"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["i128x2"]],["i128x2"]]],[11,"min","","Minimum of two vectors.",6,[[],["self"]]],[11,"max","","Maximum of two vectors.",6,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[],["i128"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[],["i128"]]],[11,"max_element","","Largest vector element value.",6,[[],["i128"]]],[11,"min_element","","Smallest vector element value.",6,[[],["i128"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[],["i128"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[],["i128"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[],["i128"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",6,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",6,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",6,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",6,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m128x2"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m128x2"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m128x2"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m128x2"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m128x2"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m128x2"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[["self"]],[["lexicographicallyordered",["i128x2"]],["i128x2"]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[["self"]],[["lexicographicallyordered",["i128x2"]],["i128x2"]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[["u128"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[["u128"]],["self"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]],["u128"]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]],["u128"]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["usize"],["u128"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["usize"],["u128"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["u128x2"]],["u128x2"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["u128x2"]],["u128x2"]]],[11,"min","","Minimum of two vectors.",6,[[],["self"]]],[11,"max","","Maximum of two vectors.",6,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[],["u128"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[],["u128"]]],[11,"max_element","","Largest vector element value.",6,[[],["u128"]]],[11,"min_element","","Smallest vector element value.",6,[[],["u128"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[],["u128"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[],["u128"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[],["u128"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",6,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",6,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",6,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",6,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m128x2"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m128x2"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m128x2"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m128x2"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m128x2"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m128x2"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[["self"]],[["u128x2"],["lexicographicallyordered",["u128x2"]]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[["self"]],[["u128x2"],["lexicographicallyordered",["u128x2"]]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[["bool"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[["bool"]],["self"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]],["bool"]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]],["bool"]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["usize"],["bool"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["usize"],["bool"]],["self"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[],["bool"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[],["bool"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[],["bool"]]],[11,"all","","Are `all` vector lanes `true`?",6,[[],["bool"]]],[11,"any","","Is `any` vector lane `true`?",6,[[],["bool"]]],[11,"none","","Are `all` vector lanes `false`?",6,[[],["bool"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m128x2"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m128x2"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m128x2"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m128x2"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m128x2"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m128x2"]]],[11,"select","","Selects elements of `a` and `b` using mask.",6,[[["simd"]],["simd"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[["self"]],[["lexicographicallyordered",["m128x2"]],["m128x2"]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[["self"]],[["lexicographicallyordered",["m128x2"]],["m128x2"]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[["i8"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[["i8"]],["self"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]],["i8"]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]],["i8"]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["i8"],["usize"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["i8"],["usize"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["i8x64"]],["i8x64"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["i8x64"]],["i8x64"]]],[11,"min","","Minimum of two vectors.",6,[[],["self"]]],[11,"max","","Maximum of two vectors.",6,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[],["i8"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[],["i8"]]],[11,"max_element","","Largest vector element value.",6,[[],["i8"]]],[11,"min_element","","Smallest vector element value.",6,[[],["i8"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[],["i8"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[],["i8"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[],["i8"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",6,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",6,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",6,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",6,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m8x64"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m8x64"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m8x64"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m8x64"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m8x64"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m8x64"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[["self"]],[["lexicographicallyordered",["i8x64"]],["i8x64"]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[["self"]],[["lexicographicallyordered",["i8x64"]],["i8x64"]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[],["u64"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[["u8"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[["u8"]],["self"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]],["u8"]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]],["u8"]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["usize"],["u8"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["usize"],["u8"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["u8x64"]],["u8x64"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["u8x64"]],["u8x64"]]],[11,"min","","Minimum of two vectors.",6,[[],["self"]]],[11,"max","","Maximum of two vectors.",6,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[],["u8"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[],["u8"]]],[11,"max_element","","Largest vector element value.",6,[[],["u8"]]],[11,"min_element","","Smallest vector element value.",6,[[],["u8"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[],["u8"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[],["u8"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[],["u8"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",6,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",6,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",6,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",6,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m8x64"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m8x64"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m8x64"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m8x64"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m8x64"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m8x64"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[["self"]],[["lexicographicallyordered",["u8x64"]],["u8x64"]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[["self"]],[["lexicographicallyordered",["u8x64"]],["u8x64"]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[],["u64"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[["bool"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[["bool"]],["self"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]],["bool"]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]],["bool"]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["usize"],["bool"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["usize"],["bool"]],["self"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[],["bool"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[],["bool"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[],["bool"]]],[11,"all","","Are `all` vector lanes `true`?",6,[[],["bool"]]],[11,"any","","Is `any` vector lane `true`?",6,[[],["bool"]]],[11,"none","","Are `all` vector lanes `false`?",6,[[],["bool"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m8x64"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m8x64"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m8x64"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m8x64"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m8x64"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m8x64"]]],[11,"select","","Selects elements of `a` and `b` using mask.",6,[[["simd"]],["simd"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[["self"]],[["lexicographicallyordered",["m8x64"]],["m8x64"]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[["self"]],[["lexicographicallyordered",["m8x64"]],["m8x64"]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[],["u64"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[["i16"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[["i16"]],["self"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]],["i16"]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]],["i16"]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["usize"],["i16"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["usize"],["i16"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["i16x32"]],["i16x32"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["i16x32"]],["i16x32"]]],[11,"min","","Minimum of two vectors.",6,[[],["self"]]],[11,"max","","Maximum of two vectors.",6,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[],["i16"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[],["i16"]]],[11,"max_element","","Largest vector element value.",6,[[],["i16"]]],[11,"min_element","","Smallest vector element value.",6,[[],["i16"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[],["i16"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[],["i16"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[],["i16"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",6,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",6,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",6,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",6,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m16x32"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m16x32"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m16x32"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m16x32"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m16x32"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m16x32"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[["self"]],[["lexicographicallyordered",["i16x32"]],["i16x32"]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[["self"]],[["lexicographicallyordered",["i16x32"]],["i16x32"]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[],["u32"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[["u16"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[["u16"]],["self"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]],["u16"]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]],["u16"]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["u16"],["usize"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["u16"],["usize"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["u16x32"]],["u16x32"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["u16x32"]],["u16x32"]]],[11,"min","","Minimum of two vectors.",6,[[],["self"]]],[11,"max","","Maximum of two vectors.",6,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[],["u16"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[],["u16"]]],[11,"max_element","","Largest vector element value.",6,[[],["u16"]]],[11,"min_element","","Smallest vector element value.",6,[[],["u16"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[],["u16"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[],["u16"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[],["u16"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",6,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",6,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",6,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",6,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m16x32"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m16x32"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m16x32"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m16x32"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m16x32"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m16x32"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[["self"]],[["lexicographicallyordered",["u16x32"]],["u16x32"]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[["self"]],[["lexicographicallyordered",["u16x32"]],["u16x32"]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[],["u32"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[["bool"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[["bool"]],["self"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]],["bool"]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]],["bool"]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["usize"],["bool"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["usize"],["bool"]],["self"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[],["bool"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[],["bool"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[],["bool"]]],[11,"all","","Are `all` vector lanes `true`?",6,[[],["bool"]]],[11,"any","","Is `any` vector lane `true`?",6,[[],["bool"]]],[11,"none","","Are `all` vector lanes `false`?",6,[[],["bool"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m16x32"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m16x32"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m16x32"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m16x32"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m16x32"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m16x32"]]],[11,"select","","Selects elements of `a` and `b` using mask.",6,[[["simd"]],["simd"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[["self"]],[["lexicographicallyordered",["m16x32"]],["m16x32"]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[["self"]],[["lexicographicallyordered",["m16x32"]],["m16x32"]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[],["u32"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[["i32"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[["i32"]],["self"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]],["i32"]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]],["i32"]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["usize"],["i32"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["usize"],["i32"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["i32x16"]],["i32x16"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["i32x16"]],["i32x16"]]],[11,"min","","Minimum of two vectors.",6,[[],["self"]]],[11,"max","","Maximum of two vectors.",6,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[],["i32"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[],["i32"]]],[11,"max_element","","Largest vector element value.",6,[[],["i32"]]],[11,"min_element","","Smallest vector element value.",6,[[],["i32"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[],["i32"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[],["i32"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[],["i32"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",6,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",6,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",6,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",6,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m32x16"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m32x16"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m32x16"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m32x16"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m32x16"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m32x16"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[["self"]],[["i32x16"],["lexicographicallyordered",["i32x16"]]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[["self"]],[["i32x16"],["lexicographicallyordered",["i32x16"]]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[],["u16"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[["u32"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[["u32"]],["self"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]],["u32"]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]],["u32"]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["u32"],["usize"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["u32"],["usize"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["u32x16"]],["u32x16"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["u32x16"]],["u32x16"]]],[11,"min","","Minimum of two vectors.",6,[[],["self"]]],[11,"max","","Maximum of two vectors.",6,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[],["u32"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[],["u32"]]],[11,"max_element","","Largest vector element value.",6,[[],["u32"]]],[11,"min_element","","Smallest vector element value.",6,[[],["u32"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[],["u32"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[],["u32"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[],["u32"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",6,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",6,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",6,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",6,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m32x16"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m32x16"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m32x16"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m32x16"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m32x16"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m32x16"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[["self"]],[["lexicographicallyordered",["u32x16"]],["u32x16"]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[["self"]],[["lexicographicallyordered",["u32x16"]],["u32x16"]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[],["u16"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[["f32"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[["f32"]],["self"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]],["f32"]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]],["f32"]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["f32"],["usize"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["f32"],["usize"]],["self"]]],[11,"min","","Minimum of two vectors.",6,[[],["self"]]],[11,"max","","Maximum of two vectors.",6,[[],["self"]]],[11,"sum","","Horizontal sum of the vector elements.",6,[[],["f32"]]],[11,"product","","Horizontal product of the vector elements.",6,[[],["f32"]]],[11,"max_element","","Largest vector element value.",6,[[],["f32"]]],[11,"min_element","","Smallest vector element value.",6,[[],["f32"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[18,"EPSILON","","Machine epsilon value.",6,null],[18,"MIN","","Smallest finite value.",6,null],[18,"MIN_POSITIVE","","Smallest positive normal value.",6,null],[18,"MAX","","Largest finite value.",6,null],[18,"NAN","","Not a Number (NaN).",6,null],[18,"INFINITY","","Infinity (∞).",6,null],[18,"NEG_INFINITY","","Negative infinity (-∞).",6,null],[18,"PI","","Archimedes' constant (π)",6,null],[18,"FRAC_PI_2","","π/2",6,null],[18,"FRAC_PI_3","","π/3",6,null],[18,"FRAC_PI_4","","π/4",6,null],[18,"FRAC_PI_6","","π/6",6,null],[18,"FRAC_PI_8","","π/8",6,null],[18,"FRAC_1_PI","","1/π",6,null],[18,"FRAC_2_PI","","2/π",6,null],[18,"FRAC_2_SQRT_PI","","2/sqrt(π)",6,null],[18,"SQRT_2","","sqrt(2)",6,null],[18,"FRAC_1_SQRT_2","","1/sqrt(2)",6,null],[18,"E","","Euler's number (e)",6,null],[18,"LOG2_E","","log2(e)",6,null],[18,"LOG10_E","","log10(e)",6,null],[18,"LN_2","","ln(2)",6,null],[18,"LN_10","","ln(10)",6,null],[11,"is_nan","","",6,[[],["m32x16"]]],[11,"is_infinite","","",6,[[],["m32x16"]]],[11,"is_finite","","",6,[[],["m32x16"]]],[11,"abs","","Absolute value.",6,[[],["self"]]],[11,"cos","","Cosine.",6,[[],["self"]]],[11,"cos_pi","","Cosine of `self * PI`.",6,[[],["self"]]],[11,"exp","","Returns the exponential function of `self`: `e^(self)`.",6,[[],["self"]]],[11,"ln","","Returns the natural logarithm of `self`.",6,[[],["self"]]],[11,"mul_add","","Fused multiply add: `self * y + z`",6,[[],["self"]]],[11,"mul_adde","","Fused multiply add estimate: ~= `self * y + z`",6,[[],["self"]]],[11,"powf","","Raises `self` number to the floating point power of `x`.",6,[[],["self"]]],[11,"recpre","","Reciprocal estimate: `~= 1. / self`.",6,[[],["self"]]],[11,"rsqrte","","Reciprocal square-root estimate: `~= 1. / self.sqrt()`.",6,[[],["self"]]],[11,"sin","","Sine.",6,[[],["self"]]],[11,"sin_pi","","Sine of `self * PI`.",6,[[],["self"]]],[11,"sin_cos_pi","","Sine and cosine of `self * PI`.",6,[[]]],[11,"sqrt","","",6,[[],["self"]]],[11,"sqrte","","Square-root estimate.",6,[[],["self"]]],[11,"tanh","","Tanh.",6,[[],["self"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m32x16"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m32x16"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m32x16"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m32x16"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m32x16"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m32x16"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[["bool"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[["bool"]],["self"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]],["bool"]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]],["bool"]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["usize"],["bool"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["usize"],["bool"]],["self"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[],["bool"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[],["bool"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[],["bool"]]],[11,"all","","Are `all` vector lanes `true`?",6,[[],["bool"]]],[11,"any","","Is `any` vector lane `true`?",6,[[],["bool"]]],[11,"none","","Are `all` vector lanes `false`?",6,[[],["bool"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m32x16"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m32x16"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m32x16"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m32x16"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m32x16"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m32x16"]]],[11,"select","","Selects elements of `a` and `b` using mask.",6,[[["simd"]],["simd"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[["self"]],[["lexicographicallyordered",["m32x16"]],["m32x16"]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[["self"]],[["lexicographicallyordered",["m32x16"]],["m32x16"]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[],["u16"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[["i64"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[["i64"]],["self"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]],["i64"]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]],["i64"]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["i64"],["usize"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["i64"],["usize"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["i64x8"]],["i64x8"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["i64x8"]],["i64x8"]]],[11,"min","","Minimum of two vectors.",6,[[],["self"]]],[11,"max","","Maximum of two vectors.",6,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[],["i64"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[],["i64"]]],[11,"max_element","","Largest vector element value.",6,[[],["i64"]]],[11,"min_element","","Smallest vector element value.",6,[[],["i64"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[],["i64"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[],["i64"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[],["i64"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",6,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",6,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",6,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",6,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m64x8"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m64x8"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m64x8"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m64x8"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m64x8"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m64x8"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[["self"]],[["i64x8"],["lexicographicallyordered",["i64x8"]]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[["self"]],[["i64x8"],["lexicographicallyordered",["i64x8"]]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[["u64"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[["u64"]],["self"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]],["u64"]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]],["u64"]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["usize"],["u64"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["usize"],["u64"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["u64x8"]],["u64x8"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["u64x8"]],["u64x8"]]],[11,"min","","Minimum of two vectors.",6,[[],["self"]]],[11,"max","","Maximum of two vectors.",6,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[],["u64"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[],["u64"]]],[11,"max_element","","Largest vector element value.",6,[[],["u64"]]],[11,"min_element","","Smallest vector element value.",6,[[],["u64"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[],["u64"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[],["u64"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[],["u64"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",6,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",6,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",6,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",6,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m64x8"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m64x8"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m64x8"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m64x8"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m64x8"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m64x8"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[["self"]],[["lexicographicallyordered",["u64x8"]],["u64x8"]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[["self"]],[["lexicographicallyordered",["u64x8"]],["u64x8"]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[["f64"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[["f64"]],["self"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]],["f64"]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]],["f64"]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["f64"],["usize"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["f64"],["usize"]],["self"]]],[11,"min","","Minimum of two vectors.",6,[[],["self"]]],[11,"max","","Maximum of two vectors.",6,[[],["self"]]],[11,"sum","","Horizontal sum of the vector elements.",6,[[],["f64"]]],[11,"product","","Horizontal product of the vector elements.",6,[[],["f64"]]],[11,"max_element","","Largest vector element value.",6,[[],["f64"]]],[11,"min_element","","Smallest vector element value.",6,[[],["f64"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[18,"EPSILON","","Machine epsilon value.",6,null],[18,"MIN","","Smallest finite value.",6,null],[18,"MIN_POSITIVE","","Smallest positive normal value.",6,null],[18,"MAX","","Largest finite value.",6,null],[18,"NAN","","Not a Number (NaN).",6,null],[18,"INFINITY","","Infinity (∞).",6,null],[18,"NEG_INFINITY","","Negative infinity (-∞).",6,null],[18,"PI","","Archimedes' constant (π)",6,null],[18,"FRAC_PI_2","","π/2",6,null],[18,"FRAC_PI_3","","π/3",6,null],[18,"FRAC_PI_4","","π/4",6,null],[18,"FRAC_PI_6","","π/6",6,null],[18,"FRAC_PI_8","","π/8",6,null],[18,"FRAC_1_PI","","1/π",6,null],[18,"FRAC_2_PI","","2/π",6,null],[18,"FRAC_2_SQRT_PI","","2/sqrt(π)",6,null],[18,"SQRT_2","","sqrt(2)",6,null],[18,"FRAC_1_SQRT_2","","1/sqrt(2)",6,null],[18,"E","","Euler's number (e)",6,null],[18,"LOG2_E","","log2(e)",6,null],[18,"LOG10_E","","log10(e)",6,null],[18,"LN_2","","ln(2)",6,null],[18,"LN_10","","ln(10)",6,null],[11,"is_nan","","",6,[[],["m64x8"]]],[11,"is_infinite","","",6,[[],["m64x8"]]],[11,"is_finite","","",6,[[],["m64x8"]]],[11,"abs","","Absolute value.",6,[[],["self"]]],[11,"cos","","Cosine.",6,[[],["self"]]],[11,"cos_pi","","Cosine of `self * PI`.",6,[[],["self"]]],[11,"exp","","Returns the exponential function of `self`: `e^(self)`.",6,[[],["self"]]],[11,"ln","","Returns the natural logarithm of `self`.",6,[[],["self"]]],[11,"mul_add","","Fused multiply add: `self * y + z`",6,[[],["self"]]],[11,"mul_adde","","Fused multiply add estimate: ~= `self * y + z`",6,[[],["self"]]],[11,"powf","","Raises `self` number to the floating point power of `x`.",6,[[],["self"]]],[11,"recpre","","Reciprocal estimate: `~= 1. / self`.",6,[[],["self"]]],[11,"rsqrte","","Reciprocal square-root estimate: `~= 1. / self.sqrt()`.",6,[[],["self"]]],[11,"sin","","Sine.",6,[[],["self"]]],[11,"sin_pi","","Sine of `self * PI`.",6,[[],["self"]]],[11,"sin_cos_pi","","Sine and cosine of `self * PI`.",6,[[]]],[11,"sqrt","","",6,[[],["self"]]],[11,"sqrte","","Square-root estimate.",6,[[],["self"]]],[11,"tanh","","Tanh.",6,[[],["self"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m64x8"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m64x8"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m64x8"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m64x8"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m64x8"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m64x8"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[["bool"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[["bool"]],["self"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]],["bool"]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]],["bool"]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["usize"],["bool"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["usize"],["bool"]],["self"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[],["bool"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[],["bool"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[],["bool"]]],[11,"all","","Are `all` vector lanes `true`?",6,[[],["bool"]]],[11,"any","","Is `any` vector lane `true`?",6,[[],["bool"]]],[11,"none","","Are `all` vector lanes `false`?",6,[[],["bool"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m64x8"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m64x8"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m64x8"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m64x8"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m64x8"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m64x8"]]],[11,"select","","Selects elements of `a` and `b` using mask.",6,[[["simd"]],["simd"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[["self"]],[["lexicographicallyordered",["m64x8"]],["m64x8"]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[["self"]],[["lexicographicallyordered",["m64x8"]],["m64x8"]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[["i128"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[["i128"]],["self"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]],["i128"]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]],["i128"]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["i128"],["usize"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["i128"],["usize"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["i128x4"]],["i128x4"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["i128x4"]],["i128x4"]]],[11,"min","","Minimum of two vectors.",6,[[],["self"]]],[11,"max","","Maximum of two vectors.",6,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[],["i128"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[],["i128"]]],[11,"max_element","","Largest vector element value.",6,[[],["i128"]]],[11,"min_element","","Smallest vector element value.",6,[[],["i128"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[],["i128"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[],["i128"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[],["i128"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",6,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",6,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",6,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",6,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m128x4"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m128x4"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m128x4"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m128x4"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m128x4"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m128x4"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[["self"]],[["i128x4"],["lexicographicallyordered",["i128x4"]]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[["self"]],[["i128x4"],["lexicographicallyordered",["i128x4"]]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[["u128"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[["u128"]],["self"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]],["u128"]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]],["u128"]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["usize"],["u128"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["usize"],["u128"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["u128x4"]],["u128x4"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["u128x4"]],["u128x4"]]],[11,"min","","Minimum of two vectors.",6,[[],["self"]]],[11,"max","","Maximum of two vectors.",6,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[],["u128"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[],["u128"]]],[11,"max_element","","Largest vector element value.",6,[[],["u128"]]],[11,"min_element","","Smallest vector element value.",6,[[],["u128"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[],["u128"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[],["u128"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[],["u128"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",6,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",6,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",6,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",6,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m128x4"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m128x4"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m128x4"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m128x4"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m128x4"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m128x4"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[["self"]],[["u128x4"],["lexicographicallyordered",["u128x4"]]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[["self"]],[["u128x4"],["lexicographicallyordered",["u128x4"]]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[["bool"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[["bool"]],["self"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]],["bool"]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]],["bool"]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["usize"],["bool"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["usize"],["bool"]],["self"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[],["bool"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[],["bool"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[],["bool"]]],[11,"all","","Are `all` vector lanes `true`?",6,[[],["bool"]]],[11,"any","","Is `any` vector lane `true`?",6,[[],["bool"]]],[11,"none","","Are `all` vector lanes `false`?",6,[[],["bool"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["m128x4"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["m128x4"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["m128x4"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["m128x4"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["m128x4"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["m128x4"]]],[11,"select","","Selects elements of `a` and `b` using mask.",6,[[["simd"]],["simd"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[["self"]],[["lexicographicallyordered",["m128x4"]],["m128x4"]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[["self"]],[["lexicographicallyordered",["m128x4"]],["m128x4"]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[["isize"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[["isize"]],["self"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]],["isize"]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]],["isize"]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["isize"],["usize"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["isize"],["usize"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["isizex2"]],["isizex2"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["isizex2"]],["isizex2"]]],[11,"min","","Minimum of two vectors.",6,[[],["self"]]],[11,"max","","Maximum of two vectors.",6,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[],["isize"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[],["isize"]]],[11,"max_element","","Largest vector element value.",6,[[],["isize"]]],[11,"min_element","","Smallest vector element value.",6,[[],["isize"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[],["isize"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[],["isize"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[],["isize"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",6,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",6,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",6,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",6,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["msizex2"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["msizex2"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["msizex2"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["msizex2"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["msizex2"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["msizex2"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[["self"]],[["isizex2"],["lexicographicallyordered",["isizex2"]]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[["self"]],[["isizex2"],["lexicographicallyordered",["isizex2"]]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[["usize"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[["usize"]],["self"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]],["usize"]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]],["usize"]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["usize"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["usize"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["usizex2"]],["usizex2"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["usizex2"]],["usizex2"]]],[11,"min","","Minimum of two vectors.",6,[[],["self"]]],[11,"max","","Maximum of two vectors.",6,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[],["usize"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[],["usize"]]],[11,"max_element","","Largest vector element value.",6,[[],["usize"]]],[11,"min_element","","Smallest vector element value.",6,[[],["usize"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[],["usize"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[],["usize"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[],["usize"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",6,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",6,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",6,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",6,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["msizex2"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["msizex2"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["msizex2"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["msizex2"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["msizex2"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["msizex2"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[["self"]],[["usizex2"],["lexicographicallyordered",["usizex2"]]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[["self"]],[["usizex2"],["lexicographicallyordered",["usizex2"]]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[["bool"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[["bool"]],["self"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]],["bool"]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]],["bool"]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["usize"],["bool"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["usize"],["bool"]],["self"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[],["bool"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[],["bool"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[],["bool"]]],[11,"all","","Are `all` vector lanes `true`?",6,[[],["bool"]]],[11,"any","","Is `any` vector lane `true`?",6,[[],["bool"]]],[11,"none","","Are `all` vector lanes `false`?",6,[[],["bool"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["msizex2"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["msizex2"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["msizex2"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["msizex2"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["msizex2"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["msizex2"]]],[11,"select","","Selects elements of `a` and `b` using mask.",6,[[["simd"]],["simd"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[["self"]],[["lexicographicallyordered",["msizex2"]],["msizex2"]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[["self"]],[["lexicographicallyordered",["msizex2"]],["msizex2"]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[["isize"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[["isize"]],["self"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]],["isize"]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]],["isize"]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["isize"],["usize"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["isize"],["usize"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["isizex4"]],["isizex4"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["isizex4"]],["isizex4"]]],[11,"min","","Minimum of two vectors.",6,[[],["self"]]],[11,"max","","Maximum of two vectors.",6,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[],["isize"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[],["isize"]]],[11,"max_element","","Largest vector element value.",6,[[],["isize"]]],[11,"min_element","","Smallest vector element value.",6,[[],["isize"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[],["isize"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[],["isize"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[],["isize"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",6,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",6,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",6,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",6,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["msizex4"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["msizex4"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["msizex4"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["msizex4"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["msizex4"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["msizex4"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[["self"]],[["isizex4"],["lexicographicallyordered",["isizex4"]]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[["self"]],[["isizex4"],["lexicographicallyordered",["isizex4"]]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[["usize"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[["usize"]],["self"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]],["usize"]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]],["usize"]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["usize"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["usize"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["usizex4"]],["usizex4"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["usizex4"]],["usizex4"]]],[11,"min","","Minimum of two vectors.",6,[[],["self"]]],[11,"max","","Maximum of two vectors.",6,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[],["usize"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[],["usize"]]],[11,"max_element","","Largest vector element value.",6,[[],["usize"]]],[11,"min_element","","Smallest vector element value.",6,[[],["usize"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[],["usize"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[],["usize"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[],["usize"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",6,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",6,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",6,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",6,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["msizex4"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["msizex4"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["msizex4"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["msizex4"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["msizex4"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["msizex4"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[["self"]],[["usizex4"],["lexicographicallyordered",["usizex4"]]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[["self"]],[["usizex4"],["lexicographicallyordered",["usizex4"]]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[["bool"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[["bool"]],["self"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]],["bool"]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]],["bool"]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["usize"],["bool"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["usize"],["bool"]],["self"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[],["bool"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[],["bool"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[],["bool"]]],[11,"all","","Are `all` vector lanes `true`?",6,[[],["bool"]]],[11,"any","","Is `any` vector lane `true`?",6,[[],["bool"]]],[11,"none","","Are `all` vector lanes `false`?",6,[[],["bool"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["msizex4"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["msizex4"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["msizex4"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["msizex4"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["msizex4"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["msizex4"]]],[11,"select","","Selects elements of `a` and `b` using mask.",6,[[["simd"]],["simd"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[["self"]],[["lexicographicallyordered",["msizex4"]],["msizex4"]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[["self"]],[["lexicographicallyordered",["msizex4"]],["msizex4"]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[["isize"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[["isize"]],["self"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]],["isize"]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]],["isize"]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["isize"],["usize"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["isize"],["usize"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["isizex8"]],["isizex8"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["isizex8"]],["isizex8"]]],[11,"min","","Minimum of two vectors.",6,[[],["self"]]],[11,"max","","Maximum of two vectors.",6,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[],["isize"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[],["isize"]]],[11,"max_element","","Largest vector element value.",6,[[],["isize"]]],[11,"min_element","","Smallest vector element value.",6,[[],["isize"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[],["isize"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[],["isize"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[],["isize"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",6,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",6,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",6,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",6,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["msizex8"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["msizex8"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["msizex8"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["msizex8"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["msizex8"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["msizex8"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[["self"]],[["lexicographicallyordered",["isizex8"]],["isizex8"]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[["self"]],[["lexicographicallyordered",["isizex8"]],["isizex8"]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[["usize"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[["usize"]],["self"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]],["usize"]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]],["usize"]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["usize"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["usize"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",6,[[["usizex8"]],["usizex8"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",6,[[["usizex8"]],["usizex8"]]],[11,"min","","Minimum of two vectors.",6,[[],["self"]]],[11,"max","","Maximum of two vectors.",6,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",6,[[],["usize"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",6,[[],["usize"]]],[11,"max_element","","Largest vector element value.",6,[[],["usize"]]],[11,"min_element","","Smallest vector element value.",6,[[],["usize"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[],["usize"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[],["usize"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[],["usize"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",6,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",6,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",6,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",6,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",6,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",6,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",6,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",6,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",6,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["msizex8"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["msizex8"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["msizex8"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["msizex8"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["msizex8"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["msizex8"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[["self"]],[["usizex8"],["lexicographicallyordered",["usizex8"]]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[["self"]],[["usizex8"],["lexicographicallyordered",["usizex8"]]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[["bool"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[["bool"]],["self"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]],["bool"]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]],["bool"]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["usize"],["bool"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["usize"],["bool"]],["self"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",6,[[],["bool"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",6,[[],["bool"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",6,[[],["bool"]]],[11,"all","","Are `all` vector lanes `true`?",6,[[],["bool"]]],[11,"any","","Is `any` vector lane `true`?",6,[[],["bool"]]],[11,"none","","Are `all` vector lanes `false`?",6,[[],["bool"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["msizex8"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["msizex8"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["msizex8"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["msizex8"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["msizex8"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["msizex8"]]],[11,"select","","Selects elements of `a` and `b` using mask.",6,[[["simd"]],["simd"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",6,[[["self"]],[["lexicographicallyordered",["msizex8"]],["msizex8"]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",6,[[["self"]],[["lexicographicallyordered",["msizex8"]],["msizex8"]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",6,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[],["self"]]],[11,"null","","Constructs a new instance with each element initialized to…",6,[[],["self"]]],[11,"is_null","","Returns a mask that selects those lanes that contain…",6,[[],["msizex2"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["usize"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["usize"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["msizex2"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["msizex2"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["msizex2"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["msizex2"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["msizex2"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["msizex2"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"offset","","Calculates the offset from a pointer.",6,[[["isizex2"]],["self"]]],[11,"wrapping_offset","","Calculates the offset from a pointer using wrapping…",6,[[["isizex2"]],["self"]]],[11,"offset_from","","Calculates the distance between two pointers.",6,[[],["isizex2"]]],[11,"wrapping_offset_from","","Calculates the distance between two pointers.",6,[[],["isizex2"]]],[11,"add","","Calculates the offset from a pointer (convenience for…",6,[[["usizex2"]],["self"]]],[11,"sub","","Calculates the offset from a pointer (convenience for…",6,[[["usizex2"]],["self"]]],[11,"wrapping_add","","Calculates the offset from a pointer using wrapping…",6,[[["usizex2"]],["self"]]],[11,"wrapping_sub","","Calculates the offset from a pointer using wrapping…",6,[[["usizex2"]],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[11,"read","","Reads selected vector elements from memory.",6,[[["simd"],["simd"]],["simd"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[],["self"]]],[11,"null","","Constructs a new instance with each element initialized to…",6,[[],["self"]]],[11,"is_null","","Returns a mask that selects those lanes that contain…",6,[[],["msizex2"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["usize"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["usize"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["msizex2"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["msizex2"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["msizex2"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["msizex2"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["msizex2"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["msizex2"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"offset","","Calculates the offset from a pointer.",6,[[["isizex2"]],["self"]]],[11,"wrapping_offset","","Calculates the offset from a pointer using wrapping…",6,[[["isizex2"]],["self"]]],[11,"offset_from","","Calculates the distance between two pointers.",6,[[],["isizex2"]]],[11,"wrapping_offset_from","","Calculates the distance between two pointers.",6,[[],["isizex2"]]],[11,"add","","Calculates the offset from a pointer (convenience for…",6,[[["usizex2"]],["self"]]],[11,"sub","","Calculates the offset from a pointer (convenience for…",6,[[["usizex2"]],["self"]]],[11,"wrapping_add","","Calculates the offset from a pointer using wrapping…",6,[[["usizex2"]],["self"]]],[11,"wrapping_sub","","Calculates the offset from a pointer using wrapping…",6,[[["usizex2"]],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[11,"read","","Reads selected vector elements from memory.",6,[[["simd"],["simd"]],["simd"]]],[11,"write","","Writes selected vector elements to memory.",6,[[["simd"],["simd"]]]],[11,"new","","Creates a new instance with each vector elements…",6,[[],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[],["self"]]],[11,"null","","Constructs a new instance with each element initialized to…",6,[[],["self"]]],[11,"is_null","","Returns a mask that selects those lanes that contain…",6,[[],["msizex4"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["usize"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["usize"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["msizex4"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["msizex4"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["msizex4"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["msizex4"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["msizex4"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["msizex4"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"offset","","Calculates the offset from a pointer.",6,[[["isizex4"]],["self"]]],[11,"wrapping_offset","","Calculates the offset from a pointer using wrapping…",6,[[["isizex4"]],["self"]]],[11,"offset_from","","Calculates the distance between two pointers.",6,[[],["isizex4"]]],[11,"wrapping_offset_from","","Calculates the distance between two pointers.",6,[[],["isizex4"]]],[11,"add","","Calculates the offset from a pointer (convenience for…",6,[[["usizex4"]],["self"]]],[11,"sub","","Calculates the offset from a pointer (convenience for…",6,[[["usizex4"]],["self"]]],[11,"wrapping_add","","Calculates the offset from a pointer using wrapping…",6,[[["usizex4"]],["self"]]],[11,"wrapping_sub","","Calculates the offset from a pointer using wrapping…",6,[[["usizex4"]],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[11,"read","","Reads selected vector elements from memory.",6,[[["simd"],["simd"]],["simd"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[],["self"]]],[11,"null","","Constructs a new instance with each element initialized to…",6,[[],["self"]]],[11,"is_null","","Returns a mask that selects those lanes that contain…",6,[[],["msizex4"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["usize"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["usize"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["msizex4"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["msizex4"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["msizex4"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["msizex4"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["msizex4"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["msizex4"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"offset","","Calculates the offset from a pointer.",6,[[["isizex4"]],["self"]]],[11,"wrapping_offset","","Calculates the offset from a pointer using wrapping…",6,[[["isizex4"]],["self"]]],[11,"offset_from","","Calculates the distance between two pointers.",6,[[],["isizex4"]]],[11,"wrapping_offset_from","","Calculates the distance between two pointers.",6,[[],["isizex4"]]],[11,"add","","Calculates the offset from a pointer (convenience for…",6,[[["usizex4"]],["self"]]],[11,"sub","","Calculates the offset from a pointer (convenience for…",6,[[["usizex4"]],["self"]]],[11,"wrapping_add","","Calculates the offset from a pointer using wrapping…",6,[[["usizex4"]],["self"]]],[11,"wrapping_sub","","Calculates the offset from a pointer using wrapping…",6,[[["usizex4"]],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[11,"read","","Reads selected vector elements from memory.",6,[[["simd"],["simd"]],["simd"]]],[11,"write","","Writes selected vector elements to memory.",6,[[["simd"],["simd"]]]],[11,"new","","Creates a new instance with each vector elements…",6,[[],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[],["self"]]],[11,"null","","Constructs a new instance with each element initialized to…",6,[[],["self"]]],[11,"is_null","","Returns a mask that selects those lanes that contain…",6,[[],["msizex8"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["usize"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["usize"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["msizex8"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["msizex8"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["msizex8"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["msizex8"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["msizex8"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["msizex8"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"offset","","Calculates the offset from a pointer.",6,[[["isizex8"]],["self"]]],[11,"wrapping_offset","","Calculates the offset from a pointer using wrapping…",6,[[["isizex8"]],["self"]]],[11,"offset_from","","Calculates the distance between two pointers.",6,[[],["isizex8"]]],[11,"wrapping_offset_from","","Calculates the distance between two pointers.",6,[[],["isizex8"]]],[11,"add","","Calculates the offset from a pointer (convenience for…",6,[[["usizex8"]],["self"]]],[11,"sub","","Calculates the offset from a pointer (convenience for…",6,[[["usizex8"]],["self"]]],[11,"wrapping_add","","Calculates the offset from a pointer using wrapping…",6,[[["usizex8"]],["self"]]],[11,"wrapping_sub","","Calculates the offset from a pointer using wrapping…",6,[[["usizex8"]],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[11,"read","","Reads selected vector elements from memory.",6,[[["simd"],["simd"]],["simd"]]],[11,"new","","Creates a new instance with each vector elements…",6,[[],["self"]]],[11,"lanes","","Returns the number of vector lanes.",6,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",6,[[],["self"]]],[11,"null","","Constructs a new instance with each element initialized to…",6,[[],["self"]]],[11,"is_null","","Returns a mask that selects those lanes that contain…",6,[[],["msizex8"]]],[11,"extract","","Extracts the value at `index`.",6,[[["usize"]]]],[11,"extract_unchecked","","Extracts the value at `index`.",6,[[["usize"]]]],[11,"replace","","Returns a new vector where the value at `index` is…",6,[[["usize"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",6,[[["usize"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",6,[[],["msizex8"]]],[11,"ne","","Lane-wise inequality comparison.",6,[[],["msizex8"]]],[11,"lt","","Lane-wise less-than comparison.",6,[[],["msizex8"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",6,[[],["msizex8"]]],[11,"gt","","Lane-wise greater-than comparison.",6,[[],["msizex8"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",6,[[],["msizex8"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",6,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",6,[[]]],[11,"offset","","Calculates the offset from a pointer.",6,[[["isizex8"]],["self"]]],[11,"wrapping_offset","","Calculates the offset from a pointer using wrapping…",6,[[["isizex8"]],["self"]]],[11,"offset_from","","Calculates the distance between two pointers.",6,[[],["isizex8"]]],[11,"wrapping_offset_from","","Calculates the distance between two pointers.",6,[[],["isizex8"]]],[11,"add","","Calculates the offset from a pointer (convenience for…",6,[[["usizex8"]],["self"]]],[11,"sub","","Calculates the offset from a pointer (convenience for…",6,[[["usizex8"]],["self"]]],[11,"wrapping_add","","Calculates the offset from a pointer using wrapping…",6,[[["usizex8"]],["self"]]],[11,"wrapping_sub","","Calculates the offset from a pointer using wrapping…",6,[[["usizex8"]],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",6,[[["i"]],["self"]]],[11,"read","","Reads selected vector elements from memory.",6,[[["simd"],["simd"]],["simd"]]],[11,"write","","Writes selected vector elements to memory.",6,[[["simd"],["simd"]]]],[6,"i8x2","","A 16-bit vector with 2 `i8` lanes.",null,null],[6,"u8x2","","A 16-bit vector with 2 `u8` lanes.",null,null],[6,"m8x2","","A 16-bit vector mask with 2 `m8` lanes.",null,null],[6,"i8x4","","A 32-bit vector with 4 `i8` lanes.",null,null],[6,"u8x4","","A 32-bit vector with 4 `u8` lanes.",null,null],[6,"m8x4","","A 32-bit vector mask with 4 `m8` lanes.",null,null],[6,"i16x2","","A 32-bit vector with 2 `i16` lanes.",null,null],[6,"u16x2","","A 32-bit vector with 2 `u16` lanes.",null,null],[6,"m16x2","","A 32-bit vector mask with 2 `m16` lanes.",null,null],[6,"i8x8","","A 64-bit vector with 8 `i8` lanes.",null,null],[6,"u8x8","","A 64-bit vector with 8 `u8` lanes.",null,null],[6,"m8x8","","A 64-bit vector mask with 8 `m8` lanes.",null,null],[6,"i16x4","","A 64-bit vector with 4 `i16` lanes.",null,null],[6,"u16x4","","A 64-bit vector with 4 `u16` lanes.",null,null],[6,"m16x4","","A 64-bit vector mask with 4 `m16` lanes.",null,null],[6,"i32x2","","A 64-bit vector with 2 `i32` lanes.",null,null],[6,"u32x2","","A 64-bit vector with 2 `u32` lanes.",null,null],[6,"m32x2","","A 64-bit vector mask with 2 `m32` lanes.",null,null],[6,"f32x2","","A 64-bit vector with 2 `f32` lanes.",null,null],[6,"i8x16","","A 128-bit vector with 16 `i8` lanes.",null,null],[6,"u8x16","","A 128-bit vector with 16 `u8` lanes.",null,null],[6,"m8x16","","A 128-bit vector mask with 16 `m8` lanes.",null,null],[6,"i16x8","","A 128-bit vector with 8 `i16` lanes.",null,null],[6,"u16x8","","A 128-bit vector with 8 `u16` lanes.",null,null],[6,"m16x8","","A 128-bit vector mask with 8 `m16` lanes.",null,null],[6,"i32x4","","A 128-bit vector with 4 `i32` lanes.",null,null],[6,"u32x4","","A 128-bit vector with 4 `u32` lanes.",null,null],[6,"f32x4","","A 128-bit vector with 4 `f32` lanes.",null,null],[6,"m32x4","","A 128-bit vector mask with 4 `m32` lanes.",null,null],[6,"i64x2","","A 128-bit vector with 2 `i64` lanes.",null,null],[6,"u64x2","","A 128-bit vector with 2 `u64` lanes.",null,null],[6,"f64x2","","A 128-bit vector with 2 `f64` lanes.",null,null],[6,"m64x2","","A 128-bit vector mask with 2 `m64` lanes.",null,null],[6,"i128x1","","A 128-bit vector with 1 `i128` lane.",null,null],[6,"u128x1","","A 128-bit vector with 1 `u128` lane.",null,null],[6,"m128x1","","A 128-bit vector mask with 1 `m128` lane.",null,null],[6,"i8x32","","A 256-bit vector with 32 `i8` lanes.",null,null],[6,"u8x32","","A 256-bit vector with 32 `u8` lanes.",null,null],[6,"m8x32","","A 256-bit vector mask with 32 `m8` lanes.",null,null],[6,"i16x16","","A 256-bit vector with 16 `i16` lanes.",null,null],[6,"u16x16","","A 256-bit vector with 16 `u16` lanes.",null,null],[6,"m16x16","","A 256-bit vector mask with 16 `m16` lanes.",null,null],[6,"i32x8","","A 256-bit vector with 8 `i32` lanes.",null,null],[6,"u32x8","","A 256-bit vector with 8 `u32` lanes.",null,null],[6,"f32x8","","A 256-bit vector with 8 `f32` lanes.",null,null],[6,"m32x8","","A 256-bit vector mask with 8 `m32` lanes.",null,null],[6,"i64x4","","A 256-bit vector with 4 `i64` lanes.",null,null],[6,"u64x4","","A 256-bit vector with 4 `u64` lanes.",null,null],[6,"f64x4","","A 256-bit vector with 4 `f64` lanes.",null,null],[6,"m64x4","","A 256-bit vector mask with 4 `m64` lanes.",null,null],[6,"i128x2","","A 256-bit vector with 2 `i128` lanes.",null,null],[6,"u128x2","","A 256-bit vector with 2 `u128` lanes.",null,null],[6,"m128x2","","A 256-bit vector mask with 2 `m128` lanes.",null,null],[6,"i8x64","","A 512-bit vector with 64 `i8` lanes.",null,null],[6,"u8x64","","A 512-bit vector with 64 `u8` lanes.",null,null],[6,"m8x64","","A 512-bit vector mask with 64 `m8` lanes.",null,null],[6,"i16x32","","A 512-bit vector with 32 `i16` lanes.",null,null],[6,"u16x32","","A 512-bit vector with 32 `u16` lanes.",null,null],[6,"m16x32","","A 512-bit vector mask with 32 `m16` lanes.",null,null],[6,"i32x16","","A 512-bit vector with 16 `i32` lanes.",null,null],[6,"u32x16","","A 512-bit vector with 16 `u32` lanes.",null,null],[6,"f32x16","","A 512-bit vector with 16 `f32` lanes.",null,null],[6,"m32x16","","A 512-bit vector mask with 16 `m32` lanes.",null,null],[6,"i64x8","","A 512-bit vector with 8 `i64` lanes.",null,null],[6,"u64x8","","A 512-bit vector with 8 `u64` lanes.",null,null],[6,"f64x8","","A 512-bit vector with 8 `f64` lanes.",null,null],[6,"m64x8","","A 512-bit vector mask with 8 `m64` lanes.",null,null],[6,"i128x4","","A 512-bit vector with 4 `i128` lanes.",null,null],[6,"u128x4","","A 512-bit vector with 4 `u128` lanes.",null,null],[6,"m128x4","","A 512-bit vector mask with 4 `m128` lanes.",null,null],[6,"isizex2","","A vector with 2 `isize` lanes.",null,null],[6,"usizex2","","A vector with 2 `usize` lanes.",null,null],[6,"msizex2","","A vector mask with 2 `msize` lanes.",null,null],[6,"isizex4","","A vector with 4 `isize` lanes.",null,null],[6,"usizex4","","A vector with 4 `usize` lanes.",null,null],[6,"msizex4","","A vector mask with 4 `msize` lanes.",null,null],[6,"isizex8","","A vector with 4 `isize` lanes.",null,null],[6,"usizex8","","A vector with 8 `usize` lanes.",null,null],[6,"msizex8","","A vector mask with 8 `msize` lanes.",null,null],[6,"cptrx2","","A vector with 2 `*const T` lanes",null,null],[6,"mptrx2","","A vector with 2 `*mut T` lanes",null,null],[6,"cptrx4","","A vector with 4 `*const T` lanes",null,null],[6,"mptrx4","","A vector with 4 `*mut T` lanes",null,null],[6,"cptrx8","","A vector with 8 `*const T` lanes",null,null],[6,"mptrx8","","A vector with 8 `*mut T` lanes",null,null],[8,"SimdVector","","This trait is implemented by all SIMD vector types.",null,null],[16,"Element","","Element type of the SIMD vector",7,null],[18,"LANES","","The number of elements in the SIMD vector.",7,null],[16,"LanesType","","The type: `[u32; Self::N]`.",7,null],[8,"SimdArray","","Trait implemented by arrays that can be SIMD types.",null,null],[16,"Tuple","","The type of the #[repr(simd)] type.",8,null],[16,"T","","The element type of the vector.",8,null],[18,"N","","The number of elements in the array.",8,null],[16,"NT","","The type: `[u32; Self::N]`.",8,null],[8,"Mask","","This trait is implemented by all mask types",null,null],[10,"test","","",9,[[["self"]],["bool"]]],[8,"FromCast","","Numeric cast from `T` to `Self`.",null,null],[10,"from_cast","","Numeric cast from `T` to `Self`.",10,[[["t"]],["self"]]],[8,"Cast","","Numeric cast from `Self` to `T`.",null,null],[10,"cast","","Numeric cast from `self` to `T`.",11,[[],["t"]]],[8,"FromBits","","Safe lossless bitwise conversion from `T` to `Self`.",null,null],[10,"from_bits","","Safe lossless bitwise transmute from `T` to `Self`.",12,[[["t"]],["self"]]],[8,"IntoBits","","Safe lossless bitwise conversion from `Self` to `T`.",null,null],[10,"into_bits","","Safe lossless bitwise transmute from `self` to `T`.",13,[[],["t"]]],[14,"shuffle","","Shuffles vector elements.",null,null],[11,"from","","",6,[[["t"]],["t"]]],[11,"try_from","","",6,[[["u"]],["result"]]],[11,"into","","",6,[[],["u"]]],[11,"try_into","","",6,[[],["result"]]],[11,"borrow","","",6,[[["self"]],["t"]]],[11,"borrow_mut","","",6,[[["self"]],["t"]]],[11,"type_id","","",6,[[["self"]],["typeid"]]],[11,"from","","",14,[[["t"]],["t"]]],[11,"try_from","","",14,[[["u"]],["result"]]],[11,"into","","",14,[[],["u"]]],[11,"try_into","","",14,[[],["result"]]],[11,"borrow","","",14,[[["self"]],["t"]]],[11,"borrow_mut","","",14,[[["self"]],["t"]]],[11,"type_id","","",14,[[["self"]],["typeid"]]],[11,"from","","",0,[[["t"]],["t"]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"into","","",0,[[],["u"]]],[11,"try_into","","",0,[[],["result"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"type_id","","",0,[[["self"]],["typeid"]]],[11,"from","","",1,[[["t"]],["t"]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"into","","",1,[[],["u"]]],[11,"try_into","","",1,[[],["result"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"type_id","","",1,[[["self"]],["typeid"]]],[11,"from","","",2,[[["t"]],["t"]]],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"into","","",2,[[],["u"]]],[11,"try_into","","",2,[[],["result"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"type_id","","",2,[[["self"]],["typeid"]]],[11,"from","","",3,[[["t"]],["t"]]],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"into","","",3,[[],["u"]]],[11,"try_into","","",3,[[],["result"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"type_id","","",3,[[["self"]],["typeid"]]],[11,"from","","",4,[[["t"]],["t"]]],[11,"try_from","","",4,[[["u"]],["result"]]],[11,"into","","",4,[[],["u"]]],[11,"try_into","","",4,[[],["result"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"type_id","","",4,[[["self"]],["typeid"]]],[11,"from","","",5,[[["t"]],["t"]]],[11,"try_from","","",5,[[["u"]],["result"]]],[11,"into","","",5,[[],["u"]]],[11,"try_into","","",5,[[],["result"]]],[11,"borrow","","",5,[[["self"]],["t"]]],[11,"borrow_mut","","",5,[[["self"]],["t"]]],[11,"type_id","","",5,[[["self"]],["typeid"]]],[11,"from_cast","","",15,[[["u8x2"]],["self"]]],[11,"from_cast","","",15,[[["m8x2"]],["self"]]],[11,"from_cast","","",15,[[["i16x2"]],["self"]]],[11,"from_cast","","",15,[[["u16x2"]],["self"]]],[11,"from_cast","","",15,[[["m16x2"]],["self"]]],[11,"from_cast","","",15,[[["i32x2"]],["self"]]],[11,"from_cast","","",15,[[["u32x2"]],["self"]]],[11,"from_cast","","",15,[[["f32x2"]],["self"]]],[11,"from_cast","","",15,[[["m32x2"]],["self"]]],[11,"from_cast","","",15,[[["i64x2"]],["self"]]],[11,"from_cast","","",15,[[["u64x2"]],["self"]]],[11,"from_cast","","",15,[[["f64x2"]],["self"]]],[11,"from_cast","","",15,[[["m64x2"]],["self"]]],[11,"from_cast","","",15,[[["i128x2"]],["self"]]],[11,"from_cast","","",15,[[["u128x2"]],["self"]]],[11,"from_cast","","",15,[[["m128x2"]],["self"]]],[11,"from_cast","","",15,[[["isizex2"]],["self"]]],[11,"from_cast","","",15,[[["usizex2"]],["self"]]],[11,"from_cast","","",15,[[["msizex2"]],["self"]]],[11,"from_cast","","",16,[[["i8x2"]],["self"]]],[11,"from_cast","","",16,[[["m8x2"]],["self"]]],[11,"from_cast","","",16,[[["i16x2"]],["self"]]],[11,"from_cast","","",16,[[["u16x2"]],["self"]]],[11,"from_cast","","",16,[[["m16x2"]],["self"]]],[11,"from_cast","","",16,[[["i32x2"]],["self"]]],[11,"from_cast","","",16,[[["u32x2"]],["self"]]],[11,"from_cast","","",16,[[["f32x2"]],["self"]]],[11,"from_cast","","",16,[[["m32x2"]],["self"]]],[11,"from_cast","","",16,[[["i64x2"]],["self"]]],[11,"from_cast","","",16,[[["u64x2"]],["self"]]],[11,"from_cast","","",16,[[["f64x2"]],["self"]]],[11,"from_cast","","",16,[[["m64x2"]],["self"]]],[11,"from_cast","","",16,[[["i128x2"]],["self"]]],[11,"from_cast","","",16,[[["u128x2"]],["self"]]],[11,"from_cast","","",16,[[["m128x2"]],["self"]]],[11,"from_cast","","",16,[[["isizex2"]],["self"]]],[11,"from_cast","","",16,[[["usizex2"]],["self"]]],[11,"from_cast","","",16,[[["msizex2"]],["self"]]],[11,"from_cast","","",17,[[["i8x2"]],["self"]]],[11,"from_cast","","",17,[[["u8x2"]],["self"]]],[11,"from_cast","","",17,[[["i16x2"]],["self"]]],[11,"from_cast","","",17,[[["u16x2"]],["self"]]],[11,"from_cast","","",17,[[["m16x2"]],["self"]]],[11,"from_cast","","",17,[[["i32x2"]],["self"]]],[11,"from_cast","","",17,[[["u32x2"]],["self"]]],[11,"from_cast","","",17,[[["f32x2"]],["self"]]],[11,"from_cast","","",17,[[["m32x2"]],["self"]]],[11,"from_cast","","",17,[[["i64x2"]],["self"]]],[11,"from_cast","","",17,[[["u64x2"]],["self"]]],[11,"from_cast","","",17,[[["f64x2"]],["self"]]],[11,"from_cast","","",17,[[["m64x2"]],["self"]]],[11,"from_cast","","",17,[[["i128x2"]],["self"]]],[11,"from_cast","","",17,[[["u128x2"]],["self"]]],[11,"from_cast","","",17,[[["m128x2"]],["self"]]],[11,"from_cast","","",17,[[["isizex2"]],["self"]]],[11,"from_cast","","",17,[[["usizex2"]],["self"]]],[11,"from_cast","","",17,[[["msizex2"]],["self"]]],[11,"from_cast","","",18,[[["u8x4"]],["self"]]],[11,"from_cast","","",18,[[["m8x4"]],["self"]]],[11,"from_cast","","",18,[[["i16x4"]],["self"]]],[11,"from_cast","","",18,[[["u16x4"]],["self"]]],[11,"from_cast","","",18,[[["m16x4"]],["self"]]],[11,"from_cast","","",18,[[["i32x4"]],["self"]]],[11,"from_cast","","",18,[[["u32x4"]],["self"]]],[11,"from_cast","","",18,[[["f32x4"]],["self"]]],[11,"from_cast","","",18,[[["m32x4"]],["self"]]],[11,"from_cast","","",18,[[["i64x4"]],["self"]]],[11,"from_cast","","",18,[[["u64x4"]],["self"]]],[11,"from_cast","","",18,[[["f64x4"]],["self"]]],[11,"from_cast","","",18,[[["m64x4"]],["self"]]],[11,"from_cast","","",18,[[["i128x4"]],["self"]]],[11,"from_cast","","",18,[[["u128x4"]],["self"]]],[11,"from_cast","","",18,[[["m128x4"]],["self"]]],[11,"from_cast","","",18,[[["isizex4"]],["self"]]],[11,"from_cast","","",18,[[["usizex4"]],["self"]]],[11,"from_cast","","",18,[[["msizex4"]],["self"]]],[11,"from_cast","","",19,[[["i8x4"]],["self"]]],[11,"from_cast","","",19,[[["m8x4"]],["self"]]],[11,"from_cast","","",19,[[["i16x4"]],["self"]]],[11,"from_cast","","",19,[[["u16x4"]],["self"]]],[11,"from_cast","","",19,[[["m16x4"]],["self"]]],[11,"from_cast","","",19,[[["i32x4"]],["self"]]],[11,"from_cast","","",19,[[["u32x4"]],["self"]]],[11,"from_cast","","",19,[[["f32x4"]],["self"]]],[11,"from_cast","","",19,[[["m32x4"]],["self"]]],[11,"from_cast","","",19,[[["i64x4"]],["self"]]],[11,"from_cast","","",19,[[["u64x4"]],["self"]]],[11,"from_cast","","",19,[[["f64x4"]],["self"]]],[11,"from_cast","","",19,[[["m64x4"]],["self"]]],[11,"from_cast","","",19,[[["i128x4"]],["self"]]],[11,"from_cast","","",19,[[["u128x4"]],["self"]]],[11,"from_cast","","",19,[[["m128x4"]],["self"]]],[11,"from_cast","","",19,[[["isizex4"]],["self"]]],[11,"from_cast","","",19,[[["usizex4"]],["self"]]],[11,"from_cast","","",19,[[["msizex4"]],["self"]]],[11,"from_cast","","",20,[[["i8x4"]],["self"]]],[11,"from_cast","","",20,[[["u8x4"]],["self"]]],[11,"from_cast","","",20,[[["i16x4"]],["self"]]],[11,"from_cast","","",20,[[["u16x4"]],["self"]]],[11,"from_cast","","",20,[[["m16x4"]],["self"]]],[11,"from_cast","","",20,[[["i32x4"]],["self"]]],[11,"from_cast","","",20,[[["u32x4"]],["self"]]],[11,"from_cast","","",20,[[["f32x4"]],["self"]]],[11,"from_cast","","",20,[[["m32x4"]],["self"]]],[11,"from_cast","","",20,[[["i64x4"]],["self"]]],[11,"from_cast","","",20,[[["u64x4"]],["self"]]],[11,"from_cast","","",20,[[["f64x4"]],["self"]]],[11,"from_cast","","",20,[[["m64x4"]],["self"]]],[11,"from_cast","","",20,[[["i128x4"]],["self"]]],[11,"from_cast","","",20,[[["u128x4"]],["self"]]],[11,"from_cast","","",20,[[["m128x4"]],["self"]]],[11,"from_cast","","",20,[[["isizex4"]],["self"]]],[11,"from_cast","","",20,[[["usizex4"]],["self"]]],[11,"from_cast","","",20,[[["msizex4"]],["self"]]],[11,"from_cast","","",21,[[["i8x2"]],["self"]]],[11,"from_cast","","",21,[[["u8x2"]],["self"]]],[11,"from_cast","","",21,[[["m8x2"]],["self"]]],[11,"from_cast","","",21,[[["u16x2"]],["self"]]],[11,"from_cast","","",21,[[["m16x2"]],["self"]]],[11,"from_cast","","",21,[[["i32x2"]],["self"]]],[11,"from_cast","","",21,[[["u32x2"]],["self"]]],[11,"from_cast","","",21,[[["f32x2"]],["self"]]],[11,"from_cast","","",21,[[["m32x2"]],["self"]]],[11,"from_cast","","",21,[[["i64x2"]],["self"]]],[11,"from_cast","","",21,[[["u64x2"]],["self"]]],[11,"from_cast","","",21,[[["f64x2"]],["self"]]],[11,"from_cast","","",21,[[["m64x2"]],["self"]]],[11,"from_cast","","",21,[[["i128x2"]],["self"]]],[11,"from_cast","","",21,[[["u128x2"]],["self"]]],[11,"from_cast","","",21,[[["m128x2"]],["self"]]],[11,"from_cast","","",21,[[["isizex2"]],["self"]]],[11,"from_cast","","",21,[[["usizex2"]],["self"]]],[11,"from_cast","","",21,[[["msizex2"]],["self"]]],[11,"from_cast","","",22,[[["i8x2"]],["self"]]],[11,"from_cast","","",22,[[["u8x2"]],["self"]]],[11,"from_cast","","",22,[[["m8x2"]],["self"]]],[11,"from_cast","","",22,[[["i16x2"]],["self"]]],[11,"from_cast","","",22,[[["m16x2"]],["self"]]],[11,"from_cast","","",22,[[["i32x2"]],["self"]]],[11,"from_cast","","",22,[[["u32x2"]],["self"]]],[11,"from_cast","","",22,[[["f32x2"]],["self"]]],[11,"from_cast","","",22,[[["m32x2"]],["self"]]],[11,"from_cast","","",22,[[["i64x2"]],["self"]]],[11,"from_cast","","",22,[[["u64x2"]],["self"]]],[11,"from_cast","","",22,[[["f64x2"]],["self"]]],[11,"from_cast","","",22,[[["m64x2"]],["self"]]],[11,"from_cast","","",22,[[["i128x2"]],["self"]]],[11,"from_cast","","",22,[[["u128x2"]],["self"]]],[11,"from_cast","","",22,[[["m128x2"]],["self"]]],[11,"from_cast","","",22,[[["isizex2"]],["self"]]],[11,"from_cast","","",22,[[["usizex2"]],["self"]]],[11,"from_cast","","",22,[[["msizex2"]],["self"]]],[11,"from_cast","","",23,[[["i8x2"]],["self"]]],[11,"from_cast","","",23,[[["u8x2"]],["self"]]],[11,"from_cast","","",23,[[["m8x2"]],["self"]]],[11,"from_cast","","",23,[[["i16x2"]],["self"]]],[11,"from_cast","","",23,[[["u16x2"]],["self"]]],[11,"from_cast","","",23,[[["i32x2"]],["self"]]],[11,"from_cast","","",23,[[["u32x2"]],["self"]]],[11,"from_cast","","",23,[[["f32x2"]],["self"]]],[11,"from_cast","","",23,[[["m32x2"]],["self"]]],[11,"from_cast","","",23,[[["i64x2"]],["self"]]],[11,"from_cast","","",23,[[["u64x2"]],["self"]]],[11,"from_cast","","",23,[[["f64x2"]],["self"]]],[11,"from_cast","","",23,[[["m64x2"]],["self"]]],[11,"from_cast","","",23,[[["i128x2"]],["self"]]],[11,"from_cast","","",23,[[["u128x2"]],["self"]]],[11,"from_cast","","",23,[[["m128x2"]],["self"]]],[11,"from_cast","","",23,[[["isizex2"]],["self"]]],[11,"from_cast","","",23,[[["usizex2"]],["self"]]],[11,"from_cast","","",23,[[["msizex2"]],["self"]]],[11,"from_cast","","",24,[[["u8x8"]],["self"]]],[11,"from_cast","","",24,[[["m8x8"]],["self"]]],[11,"from_cast","","",24,[[["i16x8"]],["self"]]],[11,"from_cast","","",24,[[["u16x8"]],["self"]]],[11,"from_cast","","",24,[[["m16x8"]],["self"]]],[11,"from_cast","","",24,[[["i32x8"]],["self"]]],[11,"from_cast","","",24,[[["u32x8"]],["self"]]],[11,"from_cast","","",24,[[["f32x8"]],["self"]]],[11,"from_cast","","",24,[[["m32x8"]],["self"]]],[11,"from_cast","","",24,[[["i64x8"]],["self"]]],[11,"from_cast","","",24,[[["u64x8"]],["self"]]],[11,"from_cast","","",24,[[["f64x8"]],["self"]]],[11,"from_cast","","",24,[[["m64x8"]],["self"]]],[11,"from_cast","","",24,[[["isizex8"]],["self"]]],[11,"from_cast","","",24,[[["usizex8"]],["self"]]],[11,"from_cast","","",24,[[["msizex8"]],["self"]]],[11,"from_cast","","",25,[[["i8x8"]],["self"]]],[11,"from_cast","","",25,[[["m8x8"]],["self"]]],[11,"from_cast","","",25,[[["i16x8"]],["self"]]],[11,"from_cast","","",25,[[["u16x8"]],["self"]]],[11,"from_cast","","",25,[[["m16x8"]],["self"]]],[11,"from_cast","","",25,[[["i32x8"]],["self"]]],[11,"from_cast","","",25,[[["u32x8"]],["self"]]],[11,"from_cast","","",25,[[["f32x8"]],["self"]]],[11,"from_cast","","",25,[[["m32x8"]],["self"]]],[11,"from_cast","","",25,[[["i64x8"]],["self"]]],[11,"from_cast","","",25,[[["u64x8"]],["self"]]],[11,"from_cast","","",25,[[["f64x8"]],["self"]]],[11,"from_cast","","",25,[[["m64x8"]],["self"]]],[11,"from_cast","","",25,[[["isizex8"]],["self"]]],[11,"from_cast","","",25,[[["usizex8"]],["self"]]],[11,"from_cast","","",25,[[["msizex8"]],["self"]]],[11,"from_cast","","",26,[[["i8x8"]],["self"]]],[11,"from_cast","","",26,[[["u8x8"]],["self"]]],[11,"from_cast","","",26,[[["i16x8"]],["self"]]],[11,"from_cast","","",26,[[["u16x8"]],["self"]]],[11,"from_cast","","",26,[[["m16x8"]],["self"]]],[11,"from_cast","","",26,[[["i32x8"]],["self"]]],[11,"from_cast","","",26,[[["u32x8"]],["self"]]],[11,"from_cast","","",26,[[["f32x8"]],["self"]]],[11,"from_cast","","",26,[[["m32x8"]],["self"]]],[11,"from_cast","","",26,[[["i64x8"]],["self"]]],[11,"from_cast","","",26,[[["u64x8"]],["self"]]],[11,"from_cast","","",26,[[["f64x8"]],["self"]]],[11,"from_cast","","",26,[[["m64x8"]],["self"]]],[11,"from_cast","","",26,[[["isizex8"]],["self"]]],[11,"from_cast","","",26,[[["usizex8"]],["self"]]],[11,"from_cast","","",26,[[["msizex8"]],["self"]]],[11,"from_cast","","",27,[[["i8x4"]],["self"]]],[11,"from_cast","","",27,[[["u8x4"]],["self"]]],[11,"from_cast","","",27,[[["m8x4"]],["self"]]],[11,"from_cast","","",27,[[["u16x4"]],["self"]]],[11,"from_cast","","",27,[[["m16x4"]],["self"]]],[11,"from_cast","","",27,[[["i32x4"]],["self"]]],[11,"from_cast","","",27,[[["u32x4"]],["self"]]],[11,"from_cast","","",27,[[["f32x4"]],["self"]]],[11,"from_cast","","",27,[[["m32x4"]],["self"]]],[11,"from_cast","","",27,[[["i64x4"]],["self"]]],[11,"from_cast","","",27,[[["u64x4"]],["self"]]],[11,"from_cast","","",27,[[["f64x4"]],["self"]]],[11,"from_cast","","",27,[[["m64x4"]],["self"]]],[11,"from_cast","","",27,[[["i128x4"]],["self"]]],[11,"from_cast","","",27,[[["u128x4"]],["self"]]],[11,"from_cast","","",27,[[["m128x4"]],["self"]]],[11,"from_cast","","",27,[[["isizex4"]],["self"]]],[11,"from_cast","","",27,[[["usizex4"]],["self"]]],[11,"from_cast","","",27,[[["msizex4"]],["self"]]],[11,"from_cast","","",28,[[["i8x4"]],["self"]]],[11,"from_cast","","",28,[[["u8x4"]],["self"]]],[11,"from_cast","","",28,[[["m8x4"]],["self"]]],[11,"from_cast","","",28,[[["i16x4"]],["self"]]],[11,"from_cast","","",28,[[["m16x4"]],["self"]]],[11,"from_cast","","",28,[[["i32x4"]],["self"]]],[11,"from_cast","","",28,[[["u32x4"]],["self"]]],[11,"from_cast","","",28,[[["f32x4"]],["self"]]],[11,"from_cast","","",28,[[["m32x4"]],["self"]]],[11,"from_cast","","",28,[[["i64x4"]],["self"]]],[11,"from_cast","","",28,[[["u64x4"]],["self"]]],[11,"from_cast","","",28,[[["f64x4"]],["self"]]],[11,"from_cast","","",28,[[["m64x4"]],["self"]]],[11,"from_cast","","",28,[[["i128x4"]],["self"]]],[11,"from_cast","","",28,[[["u128x4"]],["self"]]],[11,"from_cast","","",28,[[["m128x4"]],["self"]]],[11,"from_cast","","",28,[[["isizex4"]],["self"]]],[11,"from_cast","","",28,[[["usizex4"]],["self"]]],[11,"from_cast","","",28,[[["msizex4"]],["self"]]],[11,"from_cast","","",29,[[["i8x4"]],["self"]]],[11,"from_cast","","",29,[[["u8x4"]],["self"]]],[11,"from_cast","","",29,[[["m8x4"]],["self"]]],[11,"from_cast","","",29,[[["i16x4"]],["self"]]],[11,"from_cast","","",29,[[["u16x4"]],["self"]]],[11,"from_cast","","",29,[[["i32x4"]],["self"]]],[11,"from_cast","","",29,[[["u32x4"]],["self"]]],[11,"from_cast","","",29,[[["f32x4"]],["self"]]],[11,"from_cast","","",29,[[["m32x4"]],["self"]]],[11,"from_cast","","",29,[[["i64x4"]],["self"]]],[11,"from_cast","","",29,[[["u64x4"]],["self"]]],[11,"from_cast","","",29,[[["f64x4"]],["self"]]],[11,"from_cast","","",29,[[["m64x4"]],["self"]]],[11,"from_cast","","",29,[[["i128x4"]],["self"]]],[11,"from_cast","","",29,[[["u128x4"]],["self"]]],[11,"from_cast","","",29,[[["m128x4"]],["self"]]],[11,"from_cast","","",29,[[["isizex4"]],["self"]]],[11,"from_cast","","",29,[[["usizex4"]],["self"]]],[11,"from_cast","","",29,[[["msizex4"]],["self"]]],[11,"from_cast","","",30,[[["i8x2"]],["self"]]],[11,"from_cast","","",30,[[["u8x2"]],["self"]]],[11,"from_cast","","",30,[[["m8x2"]],["self"]]],[11,"from_cast","","",30,[[["i16x2"]],["self"]]],[11,"from_cast","","",30,[[["u16x2"]],["self"]]],[11,"from_cast","","",30,[[["m16x2"]],["self"]]],[11,"from_cast","","",30,[[["u32x2"]],["self"]]],[11,"from_cast","","",30,[[["f32x2"]],["self"]]],[11,"from_cast","","",30,[[["m32x2"]],["self"]]],[11,"from_cast","","",30,[[["i64x2"]],["self"]]],[11,"from_cast","","",30,[[["u64x2"]],["self"]]],[11,"from_cast","","",30,[[["f64x2"]],["self"]]],[11,"from_cast","","",30,[[["m64x2"]],["self"]]],[11,"from_cast","","",30,[[["i128x2"]],["self"]]],[11,"from_cast","","",30,[[["u128x2"]],["self"]]],[11,"from_cast","","",30,[[["m128x2"]],["self"]]],[11,"from_cast","","",30,[[["isizex2"]],["self"]]],[11,"from_cast","","",30,[[["usizex2"]],["self"]]],[11,"from_cast","","",30,[[["msizex2"]],["self"]]],[11,"from_cast","","",31,[[["i8x2"]],["self"]]],[11,"from_cast","","",31,[[["u8x2"]],["self"]]],[11,"from_cast","","",31,[[["m8x2"]],["self"]]],[11,"from_cast","","",31,[[["i16x2"]],["self"]]],[11,"from_cast","","",31,[[["u16x2"]],["self"]]],[11,"from_cast","","",31,[[["m16x2"]],["self"]]],[11,"from_cast","","",31,[[["i32x2"]],["self"]]],[11,"from_cast","","",31,[[["f32x2"]],["self"]]],[11,"from_cast","","",31,[[["m32x2"]],["self"]]],[11,"from_cast","","",31,[[["i64x2"]],["self"]]],[11,"from_cast","","",31,[[["u64x2"]],["self"]]],[11,"from_cast","","",31,[[["f64x2"]],["self"]]],[11,"from_cast","","",31,[[["m64x2"]],["self"]]],[11,"from_cast","","",31,[[["i128x2"]],["self"]]],[11,"from_cast","","",31,[[["u128x2"]],["self"]]],[11,"from_cast","","",31,[[["m128x2"]],["self"]]],[11,"from_cast","","",31,[[["isizex2"]],["self"]]],[11,"from_cast","","",31,[[["usizex2"]],["self"]]],[11,"from_cast","","",31,[[["msizex2"]],["self"]]],[11,"from_cast","","",32,[[["i8x2"]],["self"]]],[11,"from_cast","","",32,[[["u8x2"]],["self"]]],[11,"from_cast","","",32,[[["m8x2"]],["self"]]],[11,"from_cast","","",32,[[["i16x2"]],["self"]]],[11,"from_cast","","",32,[[["u16x2"]],["self"]]],[11,"from_cast","","",32,[[["m16x2"]],["self"]]],[11,"from_cast","","",32,[[["i32x2"]],["self"]]],[11,"from_cast","","",32,[[["u32x2"]],["self"]]],[11,"from_cast","","",32,[[["m32x2"]],["self"]]],[11,"from_cast","","",32,[[["i64x2"]],["self"]]],[11,"from_cast","","",32,[[["u64x2"]],["self"]]],[11,"from_cast","","",32,[[["f64x2"]],["self"]]],[11,"from_cast","","",32,[[["m64x2"]],["self"]]],[11,"from_cast","","",32,[[["i128x2"]],["self"]]],[11,"from_cast","","",32,[[["u128x2"]],["self"]]],[11,"from_cast","","",32,[[["m128x2"]],["self"]]],[11,"from_cast","","",32,[[["isizex2"]],["self"]]],[11,"from_cast","","",32,[[["usizex2"]],["self"]]],[11,"from_cast","","",32,[[["msizex2"]],["self"]]],[11,"from_cast","","",33,[[["i8x2"]],["self"]]],[11,"from_cast","","",33,[[["u8x2"]],["self"]]],[11,"from_cast","","",33,[[["m8x2"]],["self"]]],[11,"from_cast","","",33,[[["i16x2"]],["self"]]],[11,"from_cast","","",33,[[["u16x2"]],["self"]]],[11,"from_cast","","",33,[[["m16x2"]],["self"]]],[11,"from_cast","","",33,[[["i32x2"]],["self"]]],[11,"from_cast","","",33,[[["u32x2"]],["self"]]],[11,"from_cast","","",33,[[["f32x2"]],["self"]]],[11,"from_cast","","",33,[[["i64x2"]],["self"]]],[11,"from_cast","","",33,[[["u64x2"]],["self"]]],[11,"from_cast","","",33,[[["f64x2"]],["self"]]],[11,"from_cast","","",33,[[["m64x2"]],["self"]]],[11,"from_cast","","",33,[[["i128x2"]],["self"]]],[11,"from_cast","","",33,[[["u128x2"]],["self"]]],[11,"from_cast","","",33,[[["m128x2"]],["self"]]],[11,"from_cast","","",33,[[["isizex2"]],["self"]]],[11,"from_cast","","",33,[[["usizex2"]],["self"]]],[11,"from_cast","","",33,[[["msizex2"]],["self"]]],[11,"from_cast","","",34,[[["u8x16"]],["self"]]],[11,"from_cast","","",34,[[["m8x16"]],["self"]]],[11,"from_cast","","",34,[[["i16x16"]],["self"]]],[11,"from_cast","","",34,[[["u16x16"]],["self"]]],[11,"from_cast","","",34,[[["m16x16"]],["self"]]],[11,"from_cast","","",34,[[["i32x16"]],["self"]]],[11,"from_cast","","",34,[[["u32x16"]],["self"]]],[11,"from_cast","","",34,[[["f32x16"]],["self"]]],[11,"from_cast","","",34,[[["m32x16"]],["self"]]],[11,"from_cast","","",35,[[["i8x16"]],["self"]]],[11,"from_cast","","",35,[[["m8x16"]],["self"]]],[11,"from_cast","","",35,[[["i16x16"]],["self"]]],[11,"from_cast","","",35,[[["u16x16"]],["self"]]],[11,"from_cast","","",35,[[["m16x16"]],["self"]]],[11,"from_cast","","",35,[[["i32x16"]],["self"]]],[11,"from_cast","","",35,[[["u32x16"]],["self"]]],[11,"from_cast","","",35,[[["f32x16"]],["self"]]],[11,"from_cast","","",35,[[["m32x16"]],["self"]]],[11,"from_cast","","",36,[[["i8x16"]],["self"]]],[11,"from_cast","","",36,[[["u8x16"]],["self"]]],[11,"from_cast","","",36,[[["i16x16"]],["self"]]],[11,"from_cast","","",36,[[["u16x16"]],["self"]]],[11,"from_cast","","",36,[[["m16x16"]],["self"]]],[11,"from_cast","","",36,[[["i32x16"]],["self"]]],[11,"from_cast","","",36,[[["u32x16"]],["self"]]],[11,"from_cast","","",36,[[["f32x16"]],["self"]]],[11,"from_cast","","",36,[[["m32x16"]],["self"]]],[11,"from_cast","","",37,[[["i8x8"]],["self"]]],[11,"from_cast","","",37,[[["u8x8"]],["self"]]],[11,"from_cast","","",37,[[["m8x8"]],["self"]]],[11,"from_cast","","",37,[[["u16x8"]],["self"]]],[11,"from_cast","","",37,[[["m16x8"]],["self"]]],[11,"from_cast","","",37,[[["i32x8"]],["self"]]],[11,"from_cast","","",37,[[["u32x8"]],["self"]]],[11,"from_cast","","",37,[[["f32x8"]],["self"]]],[11,"from_cast","","",37,[[["m32x8"]],["self"]]],[11,"from_cast","","",37,[[["i64x8"]],["self"]]],[11,"from_cast","","",37,[[["u64x8"]],["self"]]],[11,"from_cast","","",37,[[["f64x8"]],["self"]]],[11,"from_cast","","",37,[[["m64x8"]],["self"]]],[11,"from_cast","","",37,[[["isizex8"]],["self"]]],[11,"from_cast","","",37,[[["usizex8"]],["self"]]],[11,"from_cast","","",37,[[["msizex8"]],["self"]]],[11,"from_cast","","",38,[[["i8x8"]],["self"]]],[11,"from_cast","","",38,[[["u8x8"]],["self"]]],[11,"from_cast","","",38,[[["m8x8"]],["self"]]],[11,"from_cast","","",38,[[["i16x8"]],["self"]]],[11,"from_cast","","",38,[[["m16x8"]],["self"]]],[11,"from_cast","","",38,[[["i32x8"]],["self"]]],[11,"from_cast","","",38,[[["u32x8"]],["self"]]],[11,"from_cast","","",38,[[["f32x8"]],["self"]]],[11,"from_cast","","",38,[[["m32x8"]],["self"]]],[11,"from_cast","","",38,[[["i64x8"]],["self"]]],[11,"from_cast","","",38,[[["u64x8"]],["self"]]],[11,"from_cast","","",38,[[["f64x8"]],["self"]]],[11,"from_cast","","",38,[[["m64x8"]],["self"]]],[11,"from_cast","","",38,[[["isizex8"]],["self"]]],[11,"from_cast","","",38,[[["usizex8"]],["self"]]],[11,"from_cast","","",38,[[["msizex8"]],["self"]]],[11,"from_cast","","",39,[[["i8x8"]],["self"]]],[11,"from_cast","","",39,[[["u8x8"]],["self"]]],[11,"from_cast","","",39,[[["m8x8"]],["self"]]],[11,"from_cast","","",39,[[["i16x8"]],["self"]]],[11,"from_cast","","",39,[[["u16x8"]],["self"]]],[11,"from_cast","","",39,[[["i32x8"]],["self"]]],[11,"from_cast","","",39,[[["u32x8"]],["self"]]],[11,"from_cast","","",39,[[["f32x8"]],["self"]]],[11,"from_cast","","",39,[[["m32x8"]],["self"]]],[11,"from_cast","","",39,[[["i64x8"]],["self"]]],[11,"from_cast","","",39,[[["u64x8"]],["self"]]],[11,"from_cast","","",39,[[["f64x8"]],["self"]]],[11,"from_cast","","",39,[[["m64x8"]],["self"]]],[11,"from_cast","","",39,[[["isizex8"]],["self"]]],[11,"from_cast","","",39,[[["usizex8"]],["self"]]],[11,"from_cast","","",39,[[["msizex8"]],["self"]]],[11,"from_cast","","",40,[[["i8x4"]],["self"]]],[11,"from_cast","","",40,[[["u8x4"]],["self"]]],[11,"from_cast","","",40,[[["m8x4"]],["self"]]],[11,"from_cast","","",40,[[["i16x4"]],["self"]]],[11,"from_cast","","",40,[[["u16x4"]],["self"]]],[11,"from_cast","","",40,[[["m16x4"]],["self"]]],[11,"from_cast","","",40,[[["u32x4"]],["self"]]],[11,"from_cast","","",40,[[["f32x4"]],["self"]]],[11,"from_cast","","",40,[[["m32x4"]],["self"]]],[11,"from_cast","","",40,[[["i64x4"]],["self"]]],[11,"from_cast","","",40,[[["u64x4"]],["self"]]],[11,"from_cast","","",40,[[["f64x4"]],["self"]]],[11,"from_cast","","",40,[[["m64x4"]],["self"]]],[11,"from_cast","","",40,[[["i128x4"]],["self"]]],[11,"from_cast","","",40,[[["u128x4"]],["self"]]],[11,"from_cast","","",40,[[["m128x4"]],["self"]]],[11,"from_cast","","",40,[[["isizex4"]],["self"]]],[11,"from_cast","","",40,[[["usizex4"]],["self"]]],[11,"from_cast","","",40,[[["msizex4"]],["self"]]],[11,"from_cast","","",41,[[["i8x4"]],["self"]]],[11,"from_cast","","",41,[[["u8x4"]],["self"]]],[11,"from_cast","","",41,[[["m8x4"]],["self"]]],[11,"from_cast","","",41,[[["i16x4"]],["self"]]],[11,"from_cast","","",41,[[["u16x4"]],["self"]]],[11,"from_cast","","",41,[[["m16x4"]],["self"]]],[11,"from_cast","","",41,[[["i32x4"]],["self"]]],[11,"from_cast","","",41,[[["f32x4"]],["self"]]],[11,"from_cast","","",41,[[["m32x4"]],["self"]]],[11,"from_cast","","",41,[[["i64x4"]],["self"]]],[11,"from_cast","","",41,[[["u64x4"]],["self"]]],[11,"from_cast","","",41,[[["f64x4"]],["self"]]],[11,"from_cast","","",41,[[["m64x4"]],["self"]]],[11,"from_cast","","",41,[[["i128x4"]],["self"]]],[11,"from_cast","","",41,[[["u128x4"]],["self"]]],[11,"from_cast","","",41,[[["m128x4"]],["self"]]],[11,"from_cast","","",41,[[["isizex4"]],["self"]]],[11,"from_cast","","",41,[[["usizex4"]],["self"]]],[11,"from_cast","","",41,[[["msizex4"]],["self"]]],[11,"from_cast","","",42,[[["i8x4"]],["self"]]],[11,"from_cast","","",42,[[["u8x4"]],["self"]]],[11,"from_cast","","",42,[[["m8x4"]],["self"]]],[11,"from_cast","","",42,[[["i16x4"]],["self"]]],[11,"from_cast","","",42,[[["u16x4"]],["self"]]],[11,"from_cast","","",42,[[["m16x4"]],["self"]]],[11,"from_cast","","",42,[[["i32x4"]],["self"]]],[11,"from_cast","","",42,[[["u32x4"]],["self"]]],[11,"from_cast","","",42,[[["m32x4"]],["self"]]],[11,"from_cast","","",42,[[["i64x4"]],["self"]]],[11,"from_cast","","",42,[[["u64x4"]],["self"]]],[11,"from_cast","","",42,[[["f64x4"]],["self"]]],[11,"from_cast","","",42,[[["m64x4"]],["self"]]],[11,"from_cast","","",42,[[["i128x4"]],["self"]]],[11,"from_cast","","",42,[[["u128x4"]],["self"]]],[11,"from_cast","","",42,[[["m128x4"]],["self"]]],[11,"from_cast","","",42,[[["isizex4"]],["self"]]],[11,"from_cast","","",42,[[["usizex4"]],["self"]]],[11,"from_cast","","",42,[[["msizex4"]],["self"]]],[11,"from_cast","","",43,[[["i8x4"]],["self"]]],[11,"from_cast","","",43,[[["u8x4"]],["self"]]],[11,"from_cast","","",43,[[["m8x4"]],["self"]]],[11,"from_cast","","",43,[[["i16x4"]],["self"]]],[11,"from_cast","","",43,[[["u16x4"]],["self"]]],[11,"from_cast","","",43,[[["m16x4"]],["self"]]],[11,"from_cast","","",43,[[["i32x4"]],["self"]]],[11,"from_cast","","",43,[[["u32x4"]],["self"]]],[11,"from_cast","","",43,[[["f32x4"]],["self"]]],[11,"from_cast","","",43,[[["i64x4"]],["self"]]],[11,"from_cast","","",43,[[["u64x4"]],["self"]]],[11,"from_cast","","",43,[[["f64x4"]],["self"]]],[11,"from_cast","","",43,[[["m64x4"]],["self"]]],[11,"from_cast","","",43,[[["i128x4"]],["self"]]],[11,"from_cast","","",43,[[["u128x4"]],["self"]]],[11,"from_cast","","",43,[[["m128x4"]],["self"]]],[11,"from_cast","","",43,[[["isizex4"]],["self"]]],[11,"from_cast","","",43,[[["usizex4"]],["self"]]],[11,"from_cast","","",43,[[["msizex4"]],["self"]]],[11,"from_cast","","",44,[[["i8x2"]],["self"]]],[11,"from_cast","","",44,[[["u8x2"]],["self"]]],[11,"from_cast","","",44,[[["m8x2"]],["self"]]],[11,"from_cast","","",44,[[["i16x2"]],["self"]]],[11,"from_cast","","",44,[[["u16x2"]],["self"]]],[11,"from_cast","","",44,[[["m16x2"]],["self"]]],[11,"from_cast","","",44,[[["i32x2"]],["self"]]],[11,"from_cast","","",44,[[["u32x2"]],["self"]]],[11,"from_cast","","",44,[[["f32x2"]],["self"]]],[11,"from_cast","","",44,[[["m32x2"]],["self"]]],[11,"from_cast","","",44,[[["u64x2"]],["self"]]],[11,"from_cast","","",44,[[["f64x2"]],["self"]]],[11,"from_cast","","",44,[[["m64x2"]],["self"]]],[11,"from_cast","","",44,[[["i128x2"]],["self"]]],[11,"from_cast","","",44,[[["u128x2"]],["self"]]],[11,"from_cast","","",44,[[["m128x2"]],["self"]]],[11,"from_cast","","",44,[[["isizex2"]],["self"]]],[11,"from_cast","","",44,[[["usizex2"]],["self"]]],[11,"from_cast","","",44,[[["msizex2"]],["self"]]],[11,"from_cast","","",45,[[["i8x2"]],["self"]]],[11,"from_cast","","",45,[[["u8x2"]],["self"]]],[11,"from_cast","","",45,[[["m8x2"]],["self"]]],[11,"from_cast","","",45,[[["i16x2"]],["self"]]],[11,"from_cast","","",45,[[["u16x2"]],["self"]]],[11,"from_cast","","",45,[[["m16x2"]],["self"]]],[11,"from_cast","","",45,[[["i32x2"]],["self"]]],[11,"from_cast","","",45,[[["u32x2"]],["self"]]],[11,"from_cast","","",45,[[["f32x2"]],["self"]]],[11,"from_cast","","",45,[[["m32x2"]],["self"]]],[11,"from_cast","","",45,[[["i64x2"]],["self"]]],[11,"from_cast","","",45,[[["f64x2"]],["self"]]],[11,"from_cast","","",45,[[["m64x2"]],["self"]]],[11,"from_cast","","",45,[[["i128x2"]],["self"]]],[11,"from_cast","","",45,[[["u128x2"]],["self"]]],[11,"from_cast","","",45,[[["m128x2"]],["self"]]],[11,"from_cast","","",45,[[["isizex2"]],["self"]]],[11,"from_cast","","",45,[[["usizex2"]],["self"]]],[11,"from_cast","","",45,[[["msizex2"]],["self"]]],[11,"from_cast","","",46,[[["i8x2"]],["self"]]],[11,"from_cast","","",46,[[["u8x2"]],["self"]]],[11,"from_cast","","",46,[[["m8x2"]],["self"]]],[11,"from_cast","","",46,[[["i16x2"]],["self"]]],[11,"from_cast","","",46,[[["u16x2"]],["self"]]],[11,"from_cast","","",46,[[["m16x2"]],["self"]]],[11,"from_cast","","",46,[[["i32x2"]],["self"]]],[11,"from_cast","","",46,[[["u32x2"]],["self"]]],[11,"from_cast","","",46,[[["f32x2"]],["self"]]],[11,"from_cast","","",46,[[["m32x2"]],["self"]]],[11,"from_cast","","",46,[[["i64x2"]],["self"]]],[11,"from_cast","","",46,[[["u64x2"]],["self"]]],[11,"from_cast","","",46,[[["m64x2"]],["self"]]],[11,"from_cast","","",46,[[["i128x2"]],["self"]]],[11,"from_cast","","",46,[[["u128x2"]],["self"]]],[11,"from_cast","","",46,[[["m128x2"]],["self"]]],[11,"from_cast","","",46,[[["isizex2"]],["self"]]],[11,"from_cast","","",46,[[["usizex2"]],["self"]]],[11,"from_cast","","",46,[[["msizex2"]],["self"]]],[11,"from_cast","","",47,[[["i8x2"]],["self"]]],[11,"from_cast","","",47,[[["u8x2"]],["self"]]],[11,"from_cast","","",47,[[["m8x2"]],["self"]]],[11,"from_cast","","",47,[[["i16x2"]],["self"]]],[11,"from_cast","","",47,[[["u16x2"]],["self"]]],[11,"from_cast","","",47,[[["m16x2"]],["self"]]],[11,"from_cast","","",47,[[["i32x2"]],["self"]]],[11,"from_cast","","",47,[[["u32x2"]],["self"]]],[11,"from_cast","","",47,[[["f32x2"]],["self"]]],[11,"from_cast","","",47,[[["m32x2"]],["self"]]],[11,"from_cast","","",47,[[["i64x2"]],["self"]]],[11,"from_cast","","",47,[[["u64x2"]],["self"]]],[11,"from_cast","","",47,[[["f64x2"]],["self"]]],[11,"from_cast","","",47,[[["i128x2"]],["self"]]],[11,"from_cast","","",47,[[["u128x2"]],["self"]]],[11,"from_cast","","",47,[[["m128x2"]],["self"]]],[11,"from_cast","","",47,[[["isizex2"]],["self"]]],[11,"from_cast","","",47,[[["usizex2"]],["self"]]],[11,"from_cast","","",47,[[["msizex2"]],["self"]]],[11,"from_cast","","",48,[[["i8x2"]],["self"]]],[11,"from_cast","","",48,[[["u8x2"]],["self"]]],[11,"from_cast","","",48,[[["m8x2"]],["self"]]],[11,"from_cast","","",48,[[["i16x2"]],["self"]]],[11,"from_cast","","",48,[[["u16x2"]],["self"]]],[11,"from_cast","","",48,[[["m16x2"]],["self"]]],[11,"from_cast","","",48,[[["i32x2"]],["self"]]],[11,"from_cast","","",48,[[["u32x2"]],["self"]]],[11,"from_cast","","",48,[[["f32x2"]],["self"]]],[11,"from_cast","","",48,[[["m32x2"]],["self"]]],[11,"from_cast","","",48,[[["i64x2"]],["self"]]],[11,"from_cast","","",48,[[["u64x2"]],["self"]]],[11,"from_cast","","",48,[[["f64x2"]],["self"]]],[11,"from_cast","","",48,[[["m64x2"]],["self"]]],[11,"from_cast","","",48,[[["i128x2"]],["self"]]],[11,"from_cast","","",48,[[["u128x2"]],["self"]]],[11,"from_cast","","",48,[[["m128x2"]],["self"]]],[11,"from_cast","","",48,[[["usizex2"]],["self"]]],[11,"from_cast","","",48,[[["msizex2"]],["self"]]],[11,"from_cast","","",49,[[["i8x2"]],["self"]]],[11,"from_cast","","",49,[[["u8x2"]],["self"]]],[11,"from_cast","","",49,[[["m8x2"]],["self"]]],[11,"from_cast","","",49,[[["i16x2"]],["self"]]],[11,"from_cast","","",49,[[["u16x2"]],["self"]]],[11,"from_cast","","",49,[[["m16x2"]],["self"]]],[11,"from_cast","","",49,[[["i32x2"]],["self"]]],[11,"from_cast","","",49,[[["u32x2"]],["self"]]],[11,"from_cast","","",49,[[["f32x2"]],["self"]]],[11,"from_cast","","",49,[[["m32x2"]],["self"]]],[11,"from_cast","","",49,[[["i64x2"]],["self"]]],[11,"from_cast","","",49,[[["u64x2"]],["self"]]],[11,"from_cast","","",49,[[["f64x2"]],["self"]]],[11,"from_cast","","",49,[[["m64x2"]],["self"]]],[11,"from_cast","","",49,[[["i128x2"]],["self"]]],[11,"from_cast","","",49,[[["u128x2"]],["self"]]],[11,"from_cast","","",49,[[["m128x2"]],["self"]]],[11,"from_cast","","",49,[[["isizex2"]],["self"]]],[11,"from_cast","","",49,[[["msizex2"]],["self"]]],[11,"from_cast","","",50,[[["i8x2"]],["self"]]],[11,"from_cast","","",50,[[["u8x2"]],["self"]]],[11,"from_cast","","",50,[[["m8x2"]],["self"]]],[11,"from_cast","","",50,[[["i16x2"]],["self"]]],[11,"from_cast","","",50,[[["u16x2"]],["self"]]],[11,"from_cast","","",50,[[["m16x2"]],["self"]]],[11,"from_cast","","",50,[[["i32x2"]],["self"]]],[11,"from_cast","","",50,[[["u32x2"]],["self"]]],[11,"from_cast","","",50,[[["f32x2"]],["self"]]],[11,"from_cast","","",50,[[["m32x2"]],["self"]]],[11,"from_cast","","",50,[[["i64x2"]],["self"]]],[11,"from_cast","","",50,[[["u64x2"]],["self"]]],[11,"from_cast","","",50,[[["f64x2"]],["self"]]],[11,"from_cast","","",50,[[["m64x2"]],["self"]]],[11,"from_cast","","",50,[[["i128x2"]],["self"]]],[11,"from_cast","","",50,[[["u128x2"]],["self"]]],[11,"from_cast","","",50,[[["m128x2"]],["self"]]],[11,"from_cast","","",50,[[["isizex2"]],["self"]]],[11,"from_cast","","",50,[[["usizex2"]],["self"]]],[11,"from_cast","","",51,[[["u128x1"]],["self"]]],[11,"from_cast","","",51,[[["m128x1"]],["self"]]],[11,"from_cast","","",52,[[["i128x1"]],["self"]]],[11,"from_cast","","",52,[[["m128x1"]],["self"]]],[11,"from_cast","","",53,[[["i128x1"]],["self"]]],[11,"from_cast","","",53,[[["u128x1"]],["self"]]],[11,"from_cast","","",54,[[["u8x32"]],["self"]]],[11,"from_cast","","",54,[[["m8x32"]],["self"]]],[11,"from_cast","","",54,[[["i16x32"]],["self"]]],[11,"from_cast","","",54,[[["u16x32"]],["self"]]],[11,"from_cast","","",54,[[["m16x32"]],["self"]]],[11,"from_cast","","",55,[[["i8x32"]],["self"]]],[11,"from_cast","","",55,[[["m8x32"]],["self"]]],[11,"from_cast","","",55,[[["i16x32"]],["self"]]],[11,"from_cast","","",55,[[["u16x32"]],["self"]]],[11,"from_cast","","",55,[[["m16x32"]],["self"]]],[11,"from_cast","","",56,[[["i8x32"]],["self"]]],[11,"from_cast","","",56,[[["u8x32"]],["self"]]],[11,"from_cast","","",56,[[["i16x32"]],["self"]]],[11,"from_cast","","",56,[[["u16x32"]],["self"]]],[11,"from_cast","","",56,[[["m16x32"]],["self"]]],[11,"from_cast","","",57,[[["i8x16"]],["self"]]],[11,"from_cast","","",57,[[["u8x16"]],["self"]]],[11,"from_cast","","",57,[[["m8x16"]],["self"]]],[11,"from_cast","","",57,[[["u16x16"]],["self"]]],[11,"from_cast","","",57,[[["m16x16"]],["self"]]],[11,"from_cast","","",57,[[["i32x16"]],["self"]]],[11,"from_cast","","",57,[[["u32x16"]],["self"]]],[11,"from_cast","","",57,[[["f32x16"]],["self"]]],[11,"from_cast","","",57,[[["m32x16"]],["self"]]],[11,"from_cast","","",58,[[["i8x16"]],["self"]]],[11,"from_cast","","",58,[[["u8x16"]],["self"]]],[11,"from_cast","","",58,[[["m8x16"]],["self"]]],[11,"from_cast","","",58,[[["i16x16"]],["self"]]],[11,"from_cast","","",58,[[["m16x16"]],["self"]]],[11,"from_cast","","",58,[[["i32x16"]],["self"]]],[11,"from_cast","","",58,[[["u32x16"]],["self"]]],[11,"from_cast","","",58,[[["f32x16"]],["self"]]],[11,"from_cast","","",58,[[["m32x16"]],["self"]]],[11,"from_cast","","",59,[[["i8x16"]],["self"]]],[11,"from_cast","","",59,[[["u8x16"]],["self"]]],[11,"from_cast","","",59,[[["m8x16"]],["self"]]],[11,"from_cast","","",59,[[["i16x16"]],["self"]]],[11,"from_cast","","",59,[[["u16x16"]],["self"]]],[11,"from_cast","","",59,[[["i32x16"]],["self"]]],[11,"from_cast","","",59,[[["u32x16"]],["self"]]],[11,"from_cast","","",59,[[["f32x16"]],["self"]]],[11,"from_cast","","",59,[[["m32x16"]],["self"]]],[11,"from_cast","","",60,[[["i8x8"]],["self"]]],[11,"from_cast","","",60,[[["u8x8"]],["self"]]],[11,"from_cast","","",60,[[["m8x8"]],["self"]]],[11,"from_cast","","",60,[[["i16x8"]],["self"]]],[11,"from_cast","","",60,[[["u16x8"]],["self"]]],[11,"from_cast","","",60,[[["m16x8"]],["self"]]],[11,"from_cast","","",60,[[["u32x8"]],["self"]]],[11,"from_cast","","",60,[[["f32x8"]],["self"]]],[11,"from_cast","","",60,[[["m32x8"]],["self"]]],[11,"from_cast","","",60,[[["i64x8"]],["self"]]],[11,"from_cast","","",60,[[["u64x8"]],["self"]]],[11,"from_cast","","",60,[[["f64x8"]],["self"]]],[11,"from_cast","","",60,[[["m64x8"]],["self"]]],[11,"from_cast","","",60,[[["isizex8"]],["self"]]],[11,"from_cast","","",60,[[["usizex8"]],["self"]]],[11,"from_cast","","",60,[[["msizex8"]],["self"]]],[11,"from_cast","","",61,[[["i8x8"]],["self"]]],[11,"from_cast","","",61,[[["u8x8"]],["self"]]],[11,"from_cast","","",61,[[["m8x8"]],["self"]]],[11,"from_cast","","",61,[[["i16x8"]],["self"]]],[11,"from_cast","","",61,[[["u16x8"]],["self"]]],[11,"from_cast","","",61,[[["m16x8"]],["self"]]],[11,"from_cast","","",61,[[["i32x8"]],["self"]]],[11,"from_cast","","",61,[[["f32x8"]],["self"]]],[11,"from_cast","","",61,[[["m32x8"]],["self"]]],[11,"from_cast","","",61,[[["i64x8"]],["self"]]],[11,"from_cast","","",61,[[["u64x8"]],["self"]]],[11,"from_cast","","",61,[[["f64x8"]],["self"]]],[11,"from_cast","","",61,[[["m64x8"]],["self"]]],[11,"from_cast","","",61,[[["isizex8"]],["self"]]],[11,"from_cast","","",61,[[["usizex8"]],["self"]]],[11,"from_cast","","",61,[[["msizex8"]],["self"]]],[11,"from_cast","","",62,[[["i8x8"]],["self"]]],[11,"from_cast","","",62,[[["u8x8"]],["self"]]],[11,"from_cast","","",62,[[["m8x8"]],["self"]]],[11,"from_cast","","",62,[[["i16x8"]],["self"]]],[11,"from_cast","","",62,[[["u16x8"]],["self"]]],[11,"from_cast","","",62,[[["m16x8"]],["self"]]],[11,"from_cast","","",62,[[["i32x8"]],["self"]]],[11,"from_cast","","",62,[[["u32x8"]],["self"]]],[11,"from_cast","","",62,[[["m32x8"]],["self"]]],[11,"from_cast","","",62,[[["i64x8"]],["self"]]],[11,"from_cast","","",62,[[["u64x8"]],["self"]]],[11,"from_cast","","",62,[[["f64x8"]],["self"]]],[11,"from_cast","","",62,[[["m64x8"]],["self"]]],[11,"from_cast","","",62,[[["isizex8"]],["self"]]],[11,"from_cast","","",62,[[["usizex8"]],["self"]]],[11,"from_cast","","",62,[[["msizex8"]],["self"]]],[11,"from_cast","","",63,[[["i8x8"]],["self"]]],[11,"from_cast","","",63,[[["u8x8"]],["self"]]],[11,"from_cast","","",63,[[["m8x8"]],["self"]]],[11,"from_cast","","",63,[[["i16x8"]],["self"]]],[11,"from_cast","","",63,[[["u16x8"]],["self"]]],[11,"from_cast","","",63,[[["m16x8"]],["self"]]],[11,"from_cast","","",63,[[["i32x8"]],["self"]]],[11,"from_cast","","",63,[[["u32x8"]],["self"]]],[11,"from_cast","","",63,[[["f32x8"]],["self"]]],[11,"from_cast","","",63,[[["i64x8"]],["self"]]],[11,"from_cast","","",63,[[["u64x8"]],["self"]]],[11,"from_cast","","",63,[[["f64x8"]],["self"]]],[11,"from_cast","","",63,[[["m64x8"]],["self"]]],[11,"from_cast","","",63,[[["isizex8"]],["self"]]],[11,"from_cast","","",63,[[["usizex8"]],["self"]]],[11,"from_cast","","",63,[[["msizex8"]],["self"]]],[11,"from_cast","","",64,[[["i8x4"]],["self"]]],[11,"from_cast","","",64,[[["u8x4"]],["self"]]],[11,"from_cast","","",64,[[["m8x4"]],["self"]]],[11,"from_cast","","",64,[[["i16x4"]],["self"]]],[11,"from_cast","","",64,[[["u16x4"]],["self"]]],[11,"from_cast","","",64,[[["m16x4"]],["self"]]],[11,"from_cast","","",64,[[["i32x4"]],["self"]]],[11,"from_cast","","",64,[[["u32x4"]],["self"]]],[11,"from_cast","","",64,[[["f32x4"]],["self"]]],[11,"from_cast","","",64,[[["m32x4"]],["self"]]],[11,"from_cast","","",64,[[["u64x4"]],["self"]]],[11,"from_cast","","",64,[[["f64x4"]],["self"]]],[11,"from_cast","","",64,[[["m64x4"]],["self"]]],[11,"from_cast","","",64,[[["i128x4"]],["self"]]],[11,"from_cast","","",64,[[["u128x4"]],["self"]]],[11,"from_cast","","",64,[[["m128x4"]],["self"]]],[11,"from_cast","","",64,[[["isizex4"]],["self"]]],[11,"from_cast","","",64,[[["usizex4"]],["self"]]],[11,"from_cast","","",64,[[["msizex4"]],["self"]]],[11,"from_cast","","",65,[[["i8x4"]],["self"]]],[11,"from_cast","","",65,[[["u8x4"]],["self"]]],[11,"from_cast","","",65,[[["m8x4"]],["self"]]],[11,"from_cast","","",65,[[["i16x4"]],["self"]]],[11,"from_cast","","",65,[[["u16x4"]],["self"]]],[11,"from_cast","","",65,[[["m16x4"]],["self"]]],[11,"from_cast","","",65,[[["i32x4"]],["self"]]],[11,"from_cast","","",65,[[["u32x4"]],["self"]]],[11,"from_cast","","",65,[[["f32x4"]],["self"]]],[11,"from_cast","","",65,[[["m32x4"]],["self"]]],[11,"from_cast","","",65,[[["i64x4"]],["self"]]],[11,"from_cast","","",65,[[["f64x4"]],["self"]]],[11,"from_cast","","",65,[[["m64x4"]],["self"]]],[11,"from_cast","","",65,[[["i128x4"]],["self"]]],[11,"from_cast","","",65,[[["u128x4"]],["self"]]],[11,"from_cast","","",65,[[["m128x4"]],["self"]]],[11,"from_cast","","",65,[[["isizex4"]],["self"]]],[11,"from_cast","","",65,[[["usizex4"]],["self"]]],[11,"from_cast","","",65,[[["msizex4"]],["self"]]],[11,"from_cast","","",66,[[["i8x4"]],["self"]]],[11,"from_cast","","",66,[[["u8x4"]],["self"]]],[11,"from_cast","","",66,[[["m8x4"]],["self"]]],[11,"from_cast","","",66,[[["i16x4"]],["self"]]],[11,"from_cast","","",66,[[["u16x4"]],["self"]]],[11,"from_cast","","",66,[[["m16x4"]],["self"]]],[11,"from_cast","","",66,[[["i32x4"]],["self"]]],[11,"from_cast","","",66,[[["u32x4"]],["self"]]],[11,"from_cast","","",66,[[["f32x4"]],["self"]]],[11,"from_cast","","",66,[[["m32x4"]],["self"]]],[11,"from_cast","","",66,[[["i64x4"]],["self"]]],[11,"from_cast","","",66,[[["u64x4"]],["self"]]],[11,"from_cast","","",66,[[["m64x4"]],["self"]]],[11,"from_cast","","",66,[[["i128x4"]],["self"]]],[11,"from_cast","","",66,[[["u128x4"]],["self"]]],[11,"from_cast","","",66,[[["m128x4"]],["self"]]],[11,"from_cast","","",66,[[["isizex4"]],["self"]]],[11,"from_cast","","",66,[[["usizex4"]],["self"]]],[11,"from_cast","","",66,[[["msizex4"]],["self"]]],[11,"from_cast","","",67,[[["i8x4"]],["self"]]],[11,"from_cast","","",67,[[["u8x4"]],["self"]]],[11,"from_cast","","",67,[[["m8x4"]],["self"]]],[11,"from_cast","","",67,[[["i16x4"]],["self"]]],[11,"from_cast","","",67,[[["u16x4"]],["self"]]],[11,"from_cast","","",67,[[["m16x4"]],["self"]]],[11,"from_cast","","",67,[[["i32x4"]],["self"]]],[11,"from_cast","","",67,[[["u32x4"]],["self"]]],[11,"from_cast","","",67,[[["f32x4"]],["self"]]],[11,"from_cast","","",67,[[["m32x4"]],["self"]]],[11,"from_cast","","",67,[[["i64x4"]],["self"]]],[11,"from_cast","","",67,[[["u64x4"]],["self"]]],[11,"from_cast","","",67,[[["f64x4"]],["self"]]],[11,"from_cast","","",67,[[["i128x4"]],["self"]]],[11,"from_cast","","",67,[[["u128x4"]],["self"]]],[11,"from_cast","","",67,[[["m128x4"]],["self"]]],[11,"from_cast","","",67,[[["isizex4"]],["self"]]],[11,"from_cast","","",67,[[["usizex4"]],["self"]]],[11,"from_cast","","",67,[[["msizex4"]],["self"]]],[11,"from_cast","","",68,[[["i8x2"]],["self"]]],[11,"from_cast","","",68,[[["u8x2"]],["self"]]],[11,"from_cast","","",68,[[["m8x2"]],["self"]]],[11,"from_cast","","",68,[[["i16x2"]],["self"]]],[11,"from_cast","","",68,[[["u16x2"]],["self"]]],[11,"from_cast","","",68,[[["m16x2"]],["self"]]],[11,"from_cast","","",68,[[["i32x2"]],["self"]]],[11,"from_cast","","",68,[[["u32x2"]],["self"]]],[11,"from_cast","","",68,[[["f32x2"]],["self"]]],[11,"from_cast","","",68,[[["m32x2"]],["self"]]],[11,"from_cast","","",68,[[["i64x2"]],["self"]]],[11,"from_cast","","",68,[[["u64x2"]],["self"]]],[11,"from_cast","","",68,[[["f64x2"]],["self"]]],[11,"from_cast","","",68,[[["m64x2"]],["self"]]],[11,"from_cast","","",68,[[["u128x2"]],["self"]]],[11,"from_cast","","",68,[[["m128x2"]],["self"]]],[11,"from_cast","","",68,[[["isizex2"]],["self"]]],[11,"from_cast","","",68,[[["usizex2"]],["self"]]],[11,"from_cast","","",68,[[["msizex2"]],["self"]]],[11,"from_cast","","",69,[[["i8x2"]],["self"]]],[11,"from_cast","","",69,[[["u8x2"]],["self"]]],[11,"from_cast","","",69,[[["m8x2"]],["self"]]],[11,"from_cast","","",69,[[["i16x2"]],["self"]]],[11,"from_cast","","",69,[[["u16x2"]],["self"]]],[11,"from_cast","","",69,[[["m16x2"]],["self"]]],[11,"from_cast","","",69,[[["i32x2"]],["self"]]],[11,"from_cast","","",69,[[["u32x2"]],["self"]]],[11,"from_cast","","",69,[[["f32x2"]],["self"]]],[11,"from_cast","","",69,[[["m32x2"]],["self"]]],[11,"from_cast","","",69,[[["i64x2"]],["self"]]],[11,"from_cast","","",69,[[["u64x2"]],["self"]]],[11,"from_cast","","",69,[[["f64x2"]],["self"]]],[11,"from_cast","","",69,[[["m64x2"]],["self"]]],[11,"from_cast","","",69,[[["i128x2"]],["self"]]],[11,"from_cast","","",69,[[["m128x2"]],["self"]]],[11,"from_cast","","",69,[[["isizex2"]],["self"]]],[11,"from_cast","","",69,[[["usizex2"]],["self"]]],[11,"from_cast","","",69,[[["msizex2"]],["self"]]],[11,"from_cast","","",70,[[["i8x2"]],["self"]]],[11,"from_cast","","",70,[[["u8x2"]],["self"]]],[11,"from_cast","","",70,[[["m8x2"]],["self"]]],[11,"from_cast","","",70,[[["i16x2"]],["self"]]],[11,"from_cast","","",70,[[["u16x2"]],["self"]]],[11,"from_cast","","",70,[[["m16x2"]],["self"]]],[11,"from_cast","","",70,[[["i32x2"]],["self"]]],[11,"from_cast","","",70,[[["u32x2"]],["self"]]],[11,"from_cast","","",70,[[["f32x2"]],["self"]]],[11,"from_cast","","",70,[[["m32x2"]],["self"]]],[11,"from_cast","","",70,[[["i64x2"]],["self"]]],[11,"from_cast","","",70,[[["u64x2"]],["self"]]],[11,"from_cast","","",70,[[["m64x2"]],["self"]]],[11,"from_cast","","",70,[[["f64x2"]],["self"]]],[11,"from_cast","","",70,[[["i128x2"]],["self"]]],[11,"from_cast","","",70,[[["u128x2"]],["self"]]],[11,"from_cast","","",70,[[["isizex2"]],["self"]]],[11,"from_cast","","",70,[[["usizex2"]],["self"]]],[11,"from_cast","","",70,[[["msizex2"]],["self"]]],[11,"from_cast","","",71,[[["i8x4"]],["self"]]],[11,"from_cast","","",71,[[["u8x4"]],["self"]]],[11,"from_cast","","",71,[[["m8x4"]],["self"]]],[11,"from_cast","","",71,[[["i16x4"]],["self"]]],[11,"from_cast","","",71,[[["u16x4"]],["self"]]],[11,"from_cast","","",71,[[["m16x4"]],["self"]]],[11,"from_cast","","",71,[[["i32x4"]],["self"]]],[11,"from_cast","","",71,[[["u32x4"]],["self"]]],[11,"from_cast","","",71,[[["f32x4"]],["self"]]],[11,"from_cast","","",71,[[["m32x4"]],["self"]]],[11,"from_cast","","",71,[[["i64x4"]],["self"]]],[11,"from_cast","","",71,[[["u64x4"]],["self"]]],[11,"from_cast","","",71,[[["f64x4"]],["self"]]],[11,"from_cast","","",71,[[["m64x4"]],["self"]]],[11,"from_cast","","",71,[[["i128x4"]],["self"]]],[11,"from_cast","","",71,[[["u128x4"]],["self"]]],[11,"from_cast","","",71,[[["m128x4"]],["self"]]],[11,"from_cast","","",71,[[["usizex4"]],["self"]]],[11,"from_cast","","",71,[[["msizex4"]],["self"]]],[11,"from_cast","","",72,[[["i8x4"]],["self"]]],[11,"from_cast","","",72,[[["u8x4"]],["self"]]],[11,"from_cast","","",72,[[["m8x4"]],["self"]]],[11,"from_cast","","",72,[[["i16x4"]],["self"]]],[11,"from_cast","","",72,[[["u16x4"]],["self"]]],[11,"from_cast","","",72,[[["m16x4"]],["self"]]],[11,"from_cast","","",72,[[["i32x4"]],["self"]]],[11,"from_cast","","",72,[[["u32x4"]],["self"]]],[11,"from_cast","","",72,[[["f32x4"]],["self"]]],[11,"from_cast","","",72,[[["m32x4"]],["self"]]],[11,"from_cast","","",72,[[["i64x4"]],["self"]]],[11,"from_cast","","",72,[[["u64x4"]],["self"]]],[11,"from_cast","","",72,[[["f64x4"]],["self"]]],[11,"from_cast","","",72,[[["m64x4"]],["self"]]],[11,"from_cast","","",72,[[["i128x4"]],["self"]]],[11,"from_cast","","",72,[[["u128x4"]],["self"]]],[11,"from_cast","","",72,[[["m128x4"]],["self"]]],[11,"from_cast","","",72,[[["isizex4"]],["self"]]],[11,"from_cast","","",72,[[["msizex4"]],["self"]]],[11,"from_cast","","",73,[[["i8x4"]],["self"]]],[11,"from_cast","","",73,[[["u8x4"]],["self"]]],[11,"from_cast","","",73,[[["m8x4"]],["self"]]],[11,"from_cast","","",73,[[["i16x4"]],["self"]]],[11,"from_cast","","",73,[[["u16x4"]],["self"]]],[11,"from_cast","","",73,[[["m16x4"]],["self"]]],[11,"from_cast","","",73,[[["i32x4"]],["self"]]],[11,"from_cast","","",73,[[["u32x4"]],["self"]]],[11,"from_cast","","",73,[[["f32x4"]],["self"]]],[11,"from_cast","","",73,[[["m32x4"]],["self"]]],[11,"from_cast","","",73,[[["i64x4"]],["self"]]],[11,"from_cast","","",73,[[["u64x4"]],["self"]]],[11,"from_cast","","",73,[[["f64x4"]],["self"]]],[11,"from_cast","","",73,[[["m64x4"]],["self"]]],[11,"from_cast","","",73,[[["i128x4"]],["self"]]],[11,"from_cast","","",73,[[["u128x4"]],["self"]]],[11,"from_cast","","",73,[[["m128x4"]],["self"]]],[11,"from_cast","","",73,[[["isizex4"]],["self"]]],[11,"from_cast","","",73,[[["usizex4"]],["self"]]],[11,"from_cast","","",74,[[["u8x64"]],["self"]]],[11,"from_cast","","",74,[[["m8x64"]],["self"]]],[11,"from_cast","","",75,[[["i8x64"]],["self"]]],[11,"from_cast","","",75,[[["m8x64"]],["self"]]],[11,"from_cast","","",76,[[["i8x64"]],["self"]]],[11,"from_cast","","",76,[[["u8x64"]],["self"]]],[11,"from_cast","","",77,[[["i8x32"]],["self"]]],[11,"from_cast","","",77,[[["u8x32"]],["self"]]],[11,"from_cast","","",77,[[["m8x32"]],["self"]]],[11,"from_cast","","",77,[[["u16x32"]],["self"]]],[11,"from_cast","","",77,[[["m16x32"]],["self"]]],[11,"from_cast","","",78,[[["i8x32"]],["self"]]],[11,"from_cast","","",78,[[["u8x32"]],["self"]]],[11,"from_cast","","",78,[[["m8x32"]],["self"]]],[11,"from_cast","","",78,[[["i16x32"]],["self"]]],[11,"from_cast","","",78,[[["m16x32"]],["self"]]],[11,"from_cast","","",79,[[["i8x32"]],["self"]]],[11,"from_cast","","",79,[[["u8x32"]],["self"]]],[11,"from_cast","","",79,[[["m8x32"]],["self"]]],[11,"from_cast","","",79,[[["i16x32"]],["self"]]],[11,"from_cast","","",79,[[["u16x32"]],["self"]]],[11,"from_cast","","",80,[[["i8x16"]],["self"]]],[11,"from_cast","","",80,[[["u8x16"]],["self"]]],[11,"from_cast","","",80,[[["m8x16"]],["self"]]],[11,"from_cast","","",80,[[["i16x16"]],["self"]]],[11,"from_cast","","",80,[[["u16x16"]],["self"]]],[11,"from_cast","","",80,[[["m16x16"]],["self"]]],[11,"from_cast","","",80,[[["u32x16"]],["self"]]],[11,"from_cast","","",80,[[["f32x16"]],["self"]]],[11,"from_cast","","",80,[[["m32x16"]],["self"]]],[11,"from_cast","","",81,[[["i8x16"]],["self"]]],[11,"from_cast","","",81,[[["u8x16"]],["self"]]],[11,"from_cast","","",81,[[["m8x16"]],["self"]]],[11,"from_cast","","",81,[[["i16x16"]],["self"]]],[11,"from_cast","","",81,[[["u16x16"]],["self"]]],[11,"from_cast","","",81,[[["m16x16"]],["self"]]],[11,"from_cast","","",81,[[["i32x16"]],["self"]]],[11,"from_cast","","",81,[[["f32x16"]],["self"]]],[11,"from_cast","","",81,[[["m32x16"]],["self"]]],[11,"from_cast","","",82,[[["i8x16"]],["self"]]],[11,"from_cast","","",82,[[["u8x16"]],["self"]]],[11,"from_cast","","",82,[[["m8x16"]],["self"]]],[11,"from_cast","","",82,[[["i16x16"]],["self"]]],[11,"from_cast","","",82,[[["u16x16"]],["self"]]],[11,"from_cast","","",82,[[["m16x16"]],["self"]]],[11,"from_cast","","",82,[[["i32x16"]],["self"]]],[11,"from_cast","","",82,[[["u32x16"]],["self"]]],[11,"from_cast","","",82,[[["m32x16"]],["self"]]],[11,"from_cast","","",83,[[["i8x16"]],["self"]]],[11,"from_cast","","",83,[[["u8x16"]],["self"]]],[11,"from_cast","","",83,[[["m8x16"]],["self"]]],[11,"from_cast","","",83,[[["i16x16"]],["self"]]],[11,"from_cast","","",83,[[["u16x16"]],["self"]]],[11,"from_cast","","",83,[[["m16x16"]],["self"]]],[11,"from_cast","","",83,[[["i32x16"]],["self"]]],[11,"from_cast","","",83,[[["u32x16"]],["self"]]],[11,"from_cast","","",83,[[["f32x16"]],["self"]]],[11,"from_cast","","",84,[[["i8x8"]],["self"]]],[11,"from_cast","","",84,[[["u8x8"]],["self"]]],[11,"from_cast","","",84,[[["m8x8"]],["self"]]],[11,"from_cast","","",84,[[["i16x8"]],["self"]]],[11,"from_cast","","",84,[[["u16x8"]],["self"]]],[11,"from_cast","","",84,[[["m16x8"]],["self"]]],[11,"from_cast","","",84,[[["i32x8"]],["self"]]],[11,"from_cast","","",84,[[["u32x8"]],["self"]]],[11,"from_cast","","",84,[[["f32x8"]],["self"]]],[11,"from_cast","","",84,[[["m32x8"]],["self"]]],[11,"from_cast","","",84,[[["u64x8"]],["self"]]],[11,"from_cast","","",84,[[["f64x8"]],["self"]]],[11,"from_cast","","",84,[[["m64x8"]],["self"]]],[11,"from_cast","","",84,[[["isizex8"]],["self"]]],[11,"from_cast","","",84,[[["usizex8"]],["self"]]],[11,"from_cast","","",84,[[["msizex8"]],["self"]]],[11,"from_cast","","",85,[[["i8x8"]],["self"]]],[11,"from_cast","","",85,[[["u8x8"]],["self"]]],[11,"from_cast","","",85,[[["m8x8"]],["self"]]],[11,"from_cast","","",85,[[["i16x8"]],["self"]]],[11,"from_cast","","",85,[[["u16x8"]],["self"]]],[11,"from_cast","","",85,[[["m16x8"]],["self"]]],[11,"from_cast","","",85,[[["i32x8"]],["self"]]],[11,"from_cast","","",85,[[["u32x8"]],["self"]]],[11,"from_cast","","",85,[[["f32x8"]],["self"]]],[11,"from_cast","","",85,[[["m32x8"]],["self"]]],[11,"from_cast","","",85,[[["i64x8"]],["self"]]],[11,"from_cast","","",85,[[["f64x8"]],["self"]]],[11,"from_cast","","",85,[[["m64x8"]],["self"]]],[11,"from_cast","","",85,[[["isizex8"]],["self"]]],[11,"from_cast","","",85,[[["usizex8"]],["self"]]],[11,"from_cast","","",85,[[["msizex8"]],["self"]]],[11,"from_cast","","",86,[[["i8x8"]],["self"]]],[11,"from_cast","","",86,[[["u8x8"]],["self"]]],[11,"from_cast","","",86,[[["m8x8"]],["self"]]],[11,"from_cast","","",86,[[["i16x8"]],["self"]]],[11,"from_cast","","",86,[[["u16x8"]],["self"]]],[11,"from_cast","","",86,[[["m16x8"]],["self"]]],[11,"from_cast","","",86,[[["i32x8"]],["self"]]],[11,"from_cast","","",86,[[["u32x8"]],["self"]]],[11,"from_cast","","",86,[[["f32x8"]],["self"]]],[11,"from_cast","","",86,[[["m32x8"]],["self"]]],[11,"from_cast","","",86,[[["i64x8"]],["self"]]],[11,"from_cast","","",86,[[["u64x8"]],["self"]]],[11,"from_cast","","",86,[[["m64x8"]],["self"]]],[11,"from_cast","","",86,[[["isizex8"]],["self"]]],[11,"from_cast","","",86,[[["usizex8"]],["self"]]],[11,"from_cast","","",86,[[["msizex8"]],["self"]]],[11,"from_cast","","",87,[[["i8x8"]],["self"]]],[11,"from_cast","","",87,[[["u8x8"]],["self"]]],[11,"from_cast","","",87,[[["m8x8"]],["self"]]],[11,"from_cast","","",87,[[["i16x8"]],["self"]]],[11,"from_cast","","",87,[[["u16x8"]],["self"]]],[11,"from_cast","","",87,[[["m16x8"]],["self"]]],[11,"from_cast","","",87,[[["i32x8"]],["self"]]],[11,"from_cast","","",87,[[["u32x8"]],["self"]]],[11,"from_cast","","",87,[[["f32x8"]],["self"]]],[11,"from_cast","","",87,[[["m32x8"]],["self"]]],[11,"from_cast","","",87,[[["i64x8"]],["self"]]],[11,"from_cast","","",87,[[["u64x8"]],["self"]]],[11,"from_cast","","",87,[[["f64x8"]],["self"]]],[11,"from_cast","","",87,[[["isizex8"]],["self"]]],[11,"from_cast","","",87,[[["usizex8"]],["self"]]],[11,"from_cast","","",87,[[["msizex8"]],["self"]]],[11,"from_cast","","",88,[[["i8x4"]],["self"]]],[11,"from_cast","","",88,[[["u8x4"]],["self"]]],[11,"from_cast","","",88,[[["m8x4"]],["self"]]],[11,"from_cast","","",88,[[["i16x4"]],["self"]]],[11,"from_cast","","",88,[[["u16x4"]],["self"]]],[11,"from_cast","","",88,[[["m16x4"]],["self"]]],[11,"from_cast","","",88,[[["i32x4"]],["self"]]],[11,"from_cast","","",88,[[["u32x4"]],["self"]]],[11,"from_cast","","",88,[[["f32x4"]],["self"]]],[11,"from_cast","","",88,[[["m32x4"]],["self"]]],[11,"from_cast","","",88,[[["i64x4"]],["self"]]],[11,"from_cast","","",88,[[["u64x4"]],["self"]]],[11,"from_cast","","",88,[[["f64x4"]],["self"]]],[11,"from_cast","","",88,[[["m64x4"]],["self"]]],[11,"from_cast","","",88,[[["u128x4"]],["self"]]],[11,"from_cast","","",88,[[["m128x4"]],["self"]]],[11,"from_cast","","",88,[[["isizex4"]],["self"]]],[11,"from_cast","","",88,[[["usizex4"]],["self"]]],[11,"from_cast","","",88,[[["msizex4"]],["self"]]],[11,"from_cast","","",89,[[["i8x4"]],["self"]]],[11,"from_cast","","",89,[[["u8x4"]],["self"]]],[11,"from_cast","","",89,[[["m8x4"]],["self"]]],[11,"from_cast","","",89,[[["i16x4"]],["self"]]],[11,"from_cast","","",89,[[["u16x4"]],["self"]]],[11,"from_cast","","",89,[[["m16x4"]],["self"]]],[11,"from_cast","","",89,[[["i32x4"]],["self"]]],[11,"from_cast","","",89,[[["u32x4"]],["self"]]],[11,"from_cast","","",89,[[["f32x4"]],["self"]]],[11,"from_cast","","",89,[[["m32x4"]],["self"]]],[11,"from_cast","","",89,[[["i64x4"]],["self"]]],[11,"from_cast","","",89,[[["u64x4"]],["self"]]],[11,"from_cast","","",89,[[["f64x4"]],["self"]]],[11,"from_cast","","",89,[[["m64x4"]],["self"]]],[11,"from_cast","","",89,[[["i128x4"]],["self"]]],[11,"from_cast","","",89,[[["m128x4"]],["self"]]],[11,"from_cast","","",89,[[["isizex4"]],["self"]]],[11,"from_cast","","",89,[[["usizex4"]],["self"]]],[11,"from_cast","","",89,[[["msizex4"]],["self"]]],[11,"from_cast","","",90,[[["i8x4"]],["self"]]],[11,"from_cast","","",90,[[["u8x4"]],["self"]]],[11,"from_cast","","",90,[[["m8x4"]],["self"]]],[11,"from_cast","","",90,[[["i16x4"]],["self"]]],[11,"from_cast","","",90,[[["u16x4"]],["self"]]],[11,"from_cast","","",90,[[["m16x4"]],["self"]]],[11,"from_cast","","",90,[[["i32x4"]],["self"]]],[11,"from_cast","","",90,[[["u32x4"]],["self"]]],[11,"from_cast","","",90,[[["f32x4"]],["self"]]],[11,"from_cast","","",90,[[["m32x4"]],["self"]]],[11,"from_cast","","",90,[[["i64x4"]],["self"]]],[11,"from_cast","","",90,[[["u64x4"]],["self"]]],[11,"from_cast","","",90,[[["m64x4"]],["self"]]],[11,"from_cast","","",90,[[["f64x4"]],["self"]]],[11,"from_cast","","",90,[[["i128x4"]],["self"]]],[11,"from_cast","","",90,[[["u128x4"]],["self"]]],[11,"from_cast","","",90,[[["isizex4"]],["self"]]],[11,"from_cast","","",90,[[["usizex4"]],["self"]]],[11,"from_cast","","",90,[[["msizex4"]],["self"]]],[11,"from_cast","","",91,[[["i8x8"]],["self"]]],[11,"from_cast","","",91,[[["u8x8"]],["self"]]],[11,"from_cast","","",91,[[["m8x8"]],["self"]]],[11,"from_cast","","",91,[[["i16x8"]],["self"]]],[11,"from_cast","","",91,[[["u16x8"]],["self"]]],[11,"from_cast","","",91,[[["m16x8"]],["self"]]],[11,"from_cast","","",91,[[["i32x8"]],["self"]]],[11,"from_cast","","",91,[[["u32x8"]],["self"]]],[11,"from_cast","","",91,[[["f32x8"]],["self"]]],[11,"from_cast","","",91,[[["m32x8"]],["self"]]],[11,"from_cast","","",91,[[["i64x8"]],["self"]]],[11,"from_cast","","",91,[[["u64x8"]],["self"]]],[11,"from_cast","","",91,[[["f64x8"]],["self"]]],[11,"from_cast","","",91,[[["m64x8"]],["self"]]],[11,"from_cast","","",91,[[["usizex8"]],["self"]]],[11,"from_cast","","",91,[[["msizex8"]],["self"]]],[11,"from_cast","","",92,[[["i8x8"]],["self"]]],[11,"from_cast","","",92,[[["u8x8"]],["self"]]],[11,"from_cast","","",92,[[["m8x8"]],["self"]]],[11,"from_cast","","",92,[[["i16x8"]],["self"]]],[11,"from_cast","","",92,[[["u16x8"]],["self"]]],[11,"from_cast","","",92,[[["m16x8"]],["self"]]],[11,"from_cast","","",92,[[["i32x8"]],["self"]]],[11,"from_cast","","",92,[[["u32x8"]],["self"]]],[11,"from_cast","","",92,[[["f32x8"]],["self"]]],[11,"from_cast","","",92,[[["m32x8"]],["self"]]],[11,"from_cast","","",92,[[["i64x8"]],["self"]]],[11,"from_cast","","",92,[[["u64x8"]],["self"]]],[11,"from_cast","","",92,[[["f64x8"]],["self"]]],[11,"from_cast","","",92,[[["m64x8"]],["self"]]],[11,"from_cast","","",92,[[["isizex8"]],["self"]]],[11,"from_cast","","",92,[[["msizex8"]],["self"]]],[11,"from_cast","","",93,[[["i8x8"]],["self"]]],[11,"from_cast","","",93,[[["u8x8"]],["self"]]],[11,"from_cast","","",93,[[["m8x8"]],["self"]]],[11,"from_cast","","",93,[[["i16x8"]],["self"]]],[11,"from_cast","","",93,[[["u16x8"]],["self"]]],[11,"from_cast","","",93,[[["m16x8"]],["self"]]],[11,"from_cast","","",93,[[["i32x8"]],["self"]]],[11,"from_cast","","",93,[[["u32x8"]],["self"]]],[11,"from_cast","","",93,[[["f32x8"]],["self"]]],[11,"from_cast","","",93,[[["m32x8"]],["self"]]],[11,"from_cast","","",93,[[["i64x8"]],["self"]]],[11,"from_cast","","",93,[[["u64x8"]],["self"]]],[11,"from_cast","","",93,[[["f64x8"]],["self"]]],[11,"from_cast","","",93,[[["m64x8"]],["self"]]],[11,"from_cast","","",93,[[["isizex8"]],["self"]]],[11,"from_cast","","",93,[[["usizex8"]],["self"]]],[11,"from_bits","","",15,[[["u8x2"]],["self"]]],[11,"from_bits","","",15,[[["m8x2"]],["self"]]],[11,"from_bits","","",16,[[["i8x2"]],["self"]]],[11,"from_bits","","",16,[[["m8x2"]],["self"]]],[11,"from_bits","","",18,[[["u8x4"]],["self"]]],[11,"from_bits","","",18,[[["m8x4"]],["self"]]],[11,"from_bits","","",18,[[["i16x2"]],["self"]]],[11,"from_bits","","",18,[[["u16x2"]],["self"]]],[11,"from_bits","","",18,[[["m16x2"]],["self"]]],[11,"from_bits","","",19,[[["i8x4"]],["self"]]],[11,"from_bits","","",19,[[["m8x4"]],["self"]]],[11,"from_bits","","",19,[[["i16x2"]],["self"]]],[11,"from_bits","","",19,[[["u16x2"]],["self"]]],[11,"from_bits","","",19,[[["m16x2"]],["self"]]],[11,"from_bits","","",20,[[["m16x2"]],["self"]]],[11,"from_bits","","",21,[[["i8x4"]],["self"]]],[11,"from_bits","","",21,[[["u8x4"]],["self"]]],[11,"from_bits","","",21,[[["m8x4"]],["self"]]],[11,"from_bits","","",21,[[["u16x2"]],["self"]]],[11,"from_bits","","",21,[[["m16x2"]],["self"]]],[11,"from_bits","","",22,[[["i8x4"]],["self"]]],[11,"from_bits","","",22,[[["u8x4"]],["self"]]],[11,"from_bits","","",22,[[["m8x4"]],["self"]]],[11,"from_bits","","",22,[[["i16x2"]],["self"]]],[11,"from_bits","","",22,[[["m16x2"]],["self"]]],[11,"from_bits","","",24,[[["u8x8"]],["self"]]],[11,"from_bits","","",24,[[["m8x8"]],["self"]]],[11,"from_bits","","",24,[[["i16x4"]],["self"]]],[11,"from_bits","","",24,[[["u16x4"]],["self"]]],[11,"from_bits","","",24,[[["m16x4"]],["self"]]],[11,"from_bits","","",24,[[["i32x2"]],["self"]]],[11,"from_bits","","",24,[[["u32x2"]],["self"]]],[11,"from_bits","","",24,[[["f32x2"]],["self"]]],[11,"from_bits","","",24,[[["m32x2"]],["self"]]],[11,"from_bits","","",25,[[["i8x8"]],["self"]]],[11,"from_bits","","",25,[[["m8x8"]],["self"]]],[11,"from_bits","","",25,[[["i16x4"]],["self"]]],[11,"from_bits","","",25,[[["u16x4"]],["self"]]],[11,"from_bits","","",25,[[["m16x4"]],["self"]]],[11,"from_bits","","",25,[[["i32x2"]],["self"]]],[11,"from_bits","","",25,[[["u32x2"]],["self"]]],[11,"from_bits","","",25,[[["f32x2"]],["self"]]],[11,"from_bits","","",25,[[["m32x2"]],["self"]]],[11,"from_bits","","",26,[[["m16x4"]],["self"]]],[11,"from_bits","","",26,[[["m32x2"]],["self"]]],[11,"from_bits","","",27,[[["i8x8"]],["self"]]],[11,"from_bits","","",27,[[["u8x8"]],["self"]]],[11,"from_bits","","",27,[[["m8x8"]],["self"]]],[11,"from_bits","","",27,[[["u16x4"]],["self"]]],[11,"from_bits","","",27,[[["m16x4"]],["self"]]],[11,"from_bits","","",27,[[["i32x2"]],["self"]]],[11,"from_bits","","",27,[[["u32x2"]],["self"]]],[11,"from_bits","","",27,[[["f32x2"]],["self"]]],[11,"from_bits","","",27,[[["m32x2"]],["self"]]],[11,"from_bits","","",28,[[["i8x8"]],["self"]]],[11,"from_bits","","",28,[[["u8x8"]],["self"]]],[11,"from_bits","","",28,[[["m8x8"]],["self"]]],[11,"from_bits","","",28,[[["i16x4"]],["self"]]],[11,"from_bits","","",28,[[["m16x4"]],["self"]]],[11,"from_bits","","",28,[[["i32x2"]],["self"]]],[11,"from_bits","","",28,[[["u32x2"]],["self"]]],[11,"from_bits","","",28,[[["f32x2"]],["self"]]],[11,"from_bits","","",28,[[["m32x2"]],["self"]]],[11,"from_bits","","",29,[[["m32x2"]],["self"]]],[11,"from_bits","","",30,[[["i8x8"]],["self"]]],[11,"from_bits","","",30,[[["u8x8"]],["self"]]],[11,"from_bits","","",30,[[["m8x8"]],["self"]]],[11,"from_bits","","",30,[[["i16x4"]],["self"]]],[11,"from_bits","","",30,[[["u16x4"]],["self"]]],[11,"from_bits","","",30,[[["m16x4"]],["self"]]],[11,"from_bits","","",30,[[["u32x2"]],["self"]]],[11,"from_bits","","",30,[[["f32x2"]],["self"]]],[11,"from_bits","","",30,[[["m32x2"]],["self"]]],[11,"from_bits","","",31,[[["i8x8"]],["self"]]],[11,"from_bits","","",31,[[["u8x8"]],["self"]]],[11,"from_bits","","",31,[[["m8x8"]],["self"]]],[11,"from_bits","","",31,[[["i16x4"]],["self"]]],[11,"from_bits","","",31,[[["u16x4"]],["self"]]],[11,"from_bits","","",31,[[["m16x4"]],["self"]]],[11,"from_bits","","",31,[[["i32x2"]],["self"]]],[11,"from_bits","","",31,[[["f32x2"]],["self"]]],[11,"from_bits","","",31,[[["m32x2"]],["self"]]],[11,"from_bits","","",32,[[["i8x8"]],["self"]]],[11,"from_bits","","",32,[[["u8x8"]],["self"]]],[11,"from_bits","","",32,[[["m8x8"]],["self"]]],[11,"from_bits","","",32,[[["i16x4"]],["self"]]],[11,"from_bits","","",32,[[["u16x4"]],["self"]]],[11,"from_bits","","",32,[[["m16x4"]],["self"]]],[11,"from_bits","","",32,[[["i32x2"]],["self"]]],[11,"from_bits","","",32,[[["u32x2"]],["self"]]],[11,"from_bits","","",32,[[["m32x2"]],["self"]]],[11,"from_bits","","",34,[[["u8x16"]],["self"]]],[11,"from_bits","","",34,[[["m8x16"]],["self"]]],[11,"from_bits","","",34,[[["i16x8"]],["self"]]],[11,"from_bits","","",34,[[["u16x8"]],["self"]]],[11,"from_bits","","",34,[[["m16x8"]],["self"]]],[11,"from_bits","","",34,[[["i32x4"]],["self"]]],[11,"from_bits","","",34,[[["u32x4"]],["self"]]],[11,"from_bits","","",34,[[["f32x4"]],["self"]]],[11,"from_bits","","",34,[[["m32x4"]],["self"]]],[11,"from_bits","","",34,[[["i64x2"]],["self"]]],[11,"from_bits","","",34,[[["u64x2"]],["self"]]],[11,"from_bits","","",34,[[["f64x2"]],["self"]]],[11,"from_bits","","",34,[[["m64x2"]],["self"]]],[11,"from_bits","","",34,[[["i128x1"]],["self"]]],[11,"from_bits","","",34,[[["u128x1"]],["self"]]],[11,"from_bits","","",34,[[["m128x1"]],["self"]]],[11,"from_bits","","",35,[[["i8x16"]],["self"]]],[11,"from_bits","","",35,[[["m8x16"]],["self"]]],[11,"from_bits","","",35,[[["i16x8"]],["self"]]],[11,"from_bits","","",35,[[["u16x8"]],["self"]]],[11,"from_bits","","",35,[[["m16x8"]],["self"]]],[11,"from_bits","","",35,[[["i32x4"]],["self"]]],[11,"from_bits","","",35,[[["u32x4"]],["self"]]],[11,"from_bits","","",35,[[["f32x4"]],["self"]]],[11,"from_bits","","",35,[[["m32x4"]],["self"]]],[11,"from_bits","","",35,[[["i64x2"]],["self"]]],[11,"from_bits","","",35,[[["u64x2"]],["self"]]],[11,"from_bits","","",35,[[["f64x2"]],["self"]]],[11,"from_bits","","",35,[[["m64x2"]],["self"]]],[11,"from_bits","","",35,[[["i128x1"]],["self"]]],[11,"from_bits","","",35,[[["u128x1"]],["self"]]],[11,"from_bits","","",35,[[["m128x1"]],["self"]]],[11,"from_bits","","",36,[[["m16x8"]],["self"]]],[11,"from_bits","","",36,[[["m32x4"]],["self"]]],[11,"from_bits","","",36,[[["m64x2"]],["self"]]],[11,"from_bits","","",36,[[["m128x1"]],["self"]]],[11,"from_bits","","",37,[[["i8x16"]],["self"]]],[11,"from_bits","","",37,[[["u8x16"]],["self"]]],[11,"from_bits","","",37,[[["m8x16"]],["self"]]],[11,"from_bits","","",37,[[["u16x8"]],["self"]]],[11,"from_bits","","",37,[[["m16x8"]],["self"]]],[11,"from_bits","","",37,[[["i32x4"]],["self"]]],[11,"from_bits","","",37,[[["u32x4"]],["self"]]],[11,"from_bits","","",37,[[["f32x4"]],["self"]]],[11,"from_bits","","",37,[[["m32x4"]],["self"]]],[11,"from_bits","","",37,[[["i64x2"]],["self"]]],[11,"from_bits","","",37,[[["u64x2"]],["self"]]],[11,"from_bits","","",37,[[["f64x2"]],["self"]]],[11,"from_bits","","",37,[[["m64x2"]],["self"]]],[11,"from_bits","","",37,[[["i128x1"]],["self"]]],[11,"from_bits","","",37,[[["u128x1"]],["self"]]],[11,"from_bits","","",37,[[["m128x1"]],["self"]]],[11,"from_bits","","",38,[[["i8x16"]],["self"]]],[11,"from_bits","","",38,[[["u8x16"]],["self"]]],[11,"from_bits","","",38,[[["m8x16"]],["self"]]],[11,"from_bits","","",38,[[["i16x8"]],["self"]]],[11,"from_bits","","",38,[[["m16x8"]],["self"]]],[11,"from_bits","","",38,[[["i32x4"]],["self"]]],[11,"from_bits","","",38,[[["u32x4"]],["self"]]],[11,"from_bits","","",38,[[["f32x4"]],["self"]]],[11,"from_bits","","",38,[[["m32x4"]],["self"]]],[11,"from_bits","","",38,[[["i64x2"]],["self"]]],[11,"from_bits","","",38,[[["u64x2"]],["self"]]],[11,"from_bits","","",38,[[["f64x2"]],["self"]]],[11,"from_bits","","",38,[[["m64x2"]],["self"]]],[11,"from_bits","","",38,[[["i128x1"]],["self"]]],[11,"from_bits","","",38,[[["u128x1"]],["self"]]],[11,"from_bits","","",38,[[["m128x1"]],["self"]]],[11,"from_bits","","",39,[[["m32x4"]],["self"]]],[11,"from_bits","","",39,[[["m64x2"]],["self"]]],[11,"from_bits","","",39,[[["m128x1"]],["self"]]],[11,"from_bits","","",40,[[["i8x16"]],["self"]]],[11,"from_bits","","",40,[[["u8x16"]],["self"]]],[11,"from_bits","","",40,[[["m8x16"]],["self"]]],[11,"from_bits","","",40,[[["i16x8"]],["self"]]],[11,"from_bits","","",40,[[["u16x8"]],["self"]]],[11,"from_bits","","",40,[[["m16x8"]],["self"]]],[11,"from_bits","","",40,[[["u32x4"]],["self"]]],[11,"from_bits","","",40,[[["f32x4"]],["self"]]],[11,"from_bits","","",40,[[["m32x4"]],["self"]]],[11,"from_bits","","",40,[[["i64x2"]],["self"]]],[11,"from_bits","","",40,[[["u64x2"]],["self"]]],[11,"from_bits","","",40,[[["f64x2"]],["self"]]],[11,"from_bits","","",40,[[["m64x2"]],["self"]]],[11,"from_bits","","",40,[[["i128x1"]],["self"]]],[11,"from_bits","","",40,[[["u128x1"]],["self"]]],[11,"from_bits","","",40,[[["m128x1"]],["self"]]],[11,"from_bits","","",41,[[["i8x16"]],["self"]]],[11,"from_bits","","",41,[[["u8x16"]],["self"]]],[11,"from_bits","","",41,[[["m8x16"]],["self"]]],[11,"from_bits","","",41,[[["i16x8"]],["self"]]],[11,"from_bits","","",41,[[["u16x8"]],["self"]]],[11,"from_bits","","",41,[[["m16x8"]],["self"]]],[11,"from_bits","","",41,[[["i32x4"]],["self"]]],[11,"from_bits","","",41,[[["f32x4"]],["self"]]],[11,"from_bits","","",41,[[["m32x4"]],["self"]]],[11,"from_bits","","",41,[[["i64x2"]],["self"]]],[11,"from_bits","","",41,[[["u64x2"]],["self"]]],[11,"from_bits","","",41,[[["f64x2"]],["self"]]],[11,"from_bits","","",41,[[["m64x2"]],["self"]]],[11,"from_bits","","",41,[[["i128x1"]],["self"]]],[11,"from_bits","","",41,[[["u128x1"]],["self"]]],[11,"from_bits","","",41,[[["m128x1"]],["self"]]],[11,"from_bits","","",42,[[["i8x16"]],["self"]]],[11,"from_bits","","",42,[[["u8x16"]],["self"]]],[11,"from_bits","","",42,[[["m8x16"]],["self"]]],[11,"from_bits","","",42,[[["i16x8"]],["self"]]],[11,"from_bits","","",42,[[["u16x8"]],["self"]]],[11,"from_bits","","",42,[[["m16x8"]],["self"]]],[11,"from_bits","","",42,[[["i32x4"]],["self"]]],[11,"from_bits","","",42,[[["u32x4"]],["self"]]],[11,"from_bits","","",42,[[["m32x4"]],["self"]]],[11,"from_bits","","",42,[[["i64x2"]],["self"]]],[11,"from_bits","","",42,[[["u64x2"]],["self"]]],[11,"from_bits","","",42,[[["f64x2"]],["self"]]],[11,"from_bits","","",42,[[["m64x2"]],["self"]]],[11,"from_bits","","",42,[[["i128x1"]],["self"]]],[11,"from_bits","","",42,[[["u128x1"]],["self"]]],[11,"from_bits","","",42,[[["m128x1"]],["self"]]],[11,"from_bits","","",43,[[["m64x2"]],["self"]]],[11,"from_bits","","",43,[[["m128x1"]],["self"]]],[11,"from_bits","","",44,[[["i8x16"]],["self"]]],[11,"from_bits","","",44,[[["u8x16"]],["self"]]],[11,"from_bits","","",44,[[["m8x16"]],["self"]]],[11,"from_bits","","",44,[[["i16x8"]],["self"]]],[11,"from_bits","","",44,[[["u16x8"]],["self"]]],[11,"from_bits","","",44,[[["m16x8"]],["self"]]],[11,"from_bits","","",44,[[["i32x4"]],["self"]]],[11,"from_bits","","",44,[[["u32x4"]],["self"]]],[11,"from_bits","","",44,[[["f32x4"]],["self"]]],[11,"from_bits","","",44,[[["m32x4"]],["self"]]],[11,"from_bits","","",44,[[["u64x2"]],["self"]]],[11,"from_bits","","",44,[[["f64x2"]],["self"]]],[11,"from_bits","","",44,[[["m64x2"]],["self"]]],[11,"from_bits","","",44,[[["i128x1"]],["self"]]],[11,"from_bits","","",44,[[["u128x1"]],["self"]]],[11,"from_bits","","",44,[[["m128x1"]],["self"]]],[11,"from_bits","","",45,[[["i8x16"]],["self"]]],[11,"from_bits","","",45,[[["u8x16"]],["self"]]],[11,"from_bits","","",45,[[["m8x16"]],["self"]]],[11,"from_bits","","",45,[[["i16x8"]],["self"]]],[11,"from_bits","","",45,[[["u16x8"]],["self"]]],[11,"from_bits","","",45,[[["m16x8"]],["self"]]],[11,"from_bits","","",45,[[["i32x4"]],["self"]]],[11,"from_bits","","",45,[[["u32x4"]],["self"]]],[11,"from_bits","","",45,[[["f32x4"]],["self"]]],[11,"from_bits","","",45,[[["m32x4"]],["self"]]],[11,"from_bits","","",45,[[["i64x2"]],["self"]]],[11,"from_bits","","",45,[[["f64x2"]],["self"]]],[11,"from_bits","","",45,[[["m64x2"]],["self"]]],[11,"from_bits","","",45,[[["i128x1"]],["self"]]],[11,"from_bits","","",45,[[["u128x1"]],["self"]]],[11,"from_bits","","",45,[[["m128x1"]],["self"]]],[11,"from_bits","","",46,[[["i8x16"]],["self"]]],[11,"from_bits","","",46,[[["u8x16"]],["self"]]],[11,"from_bits","","",46,[[["m8x16"]],["self"]]],[11,"from_bits","","",46,[[["i16x8"]],["self"]]],[11,"from_bits","","",46,[[["u16x8"]],["self"]]],[11,"from_bits","","",46,[[["m16x8"]],["self"]]],[11,"from_bits","","",46,[[["i32x4"]],["self"]]],[11,"from_bits","","",46,[[["u32x4"]],["self"]]],[11,"from_bits","","",46,[[["f32x4"]],["self"]]],[11,"from_bits","","",46,[[["m32x4"]],["self"]]],[11,"from_bits","","",46,[[["i64x2"]],["self"]]],[11,"from_bits","","",46,[[["u64x2"]],["self"]]],[11,"from_bits","","",46,[[["m64x2"]],["self"]]],[11,"from_bits","","",46,[[["i128x1"]],["self"]]],[11,"from_bits","","",46,[[["u128x1"]],["self"]]],[11,"from_bits","","",46,[[["m128x1"]],["self"]]],[11,"from_bits","","",47,[[["m128x1"]],["self"]]],[11,"from_bits","","",51,[[["i8x16"]],["self"]]],[11,"from_bits","","",51,[[["u8x16"]],["self"]]],[11,"from_bits","","",51,[[["m8x16"]],["self"]]],[11,"from_bits","","",51,[[["i16x8"]],["self"]]],[11,"from_bits","","",51,[[["u16x8"]],["self"]]],[11,"from_bits","","",51,[[["m16x8"]],["self"]]],[11,"from_bits","","",51,[[["i32x4"]],["self"]]],[11,"from_bits","","",51,[[["u32x4"]],["self"]]],[11,"from_bits","","",51,[[["f32x4"]],["self"]]],[11,"from_bits","","",51,[[["m32x4"]],["self"]]],[11,"from_bits","","",51,[[["i64x2"]],["self"]]],[11,"from_bits","","",51,[[["u64x2"]],["self"]]],[11,"from_bits","","",51,[[["f64x2"]],["self"]]],[11,"from_bits","","",51,[[["m64x2"]],["self"]]],[11,"from_bits","","",51,[[["u128x1"]],["self"]]],[11,"from_bits","","",51,[[["m128x1"]],["self"]]],[11,"from_bits","","",52,[[["i8x16"]],["self"]]],[11,"from_bits","","",52,[[["u8x16"]],["self"]]],[11,"from_bits","","",52,[[["m8x16"]],["self"]]],[11,"from_bits","","",52,[[["i16x8"]],["self"]]],[11,"from_bits","","",52,[[["u16x8"]],["self"]]],[11,"from_bits","","",52,[[["m16x8"]],["self"]]],[11,"from_bits","","",52,[[["i32x4"]],["self"]]],[11,"from_bits","","",52,[[["u32x4"]],["self"]]],[11,"from_bits","","",52,[[["f32x4"]],["self"]]],[11,"from_bits","","",52,[[["m32x4"]],["self"]]],[11,"from_bits","","",52,[[["i64x2"]],["self"]]],[11,"from_bits","","",52,[[["u64x2"]],["self"]]],[11,"from_bits","","",52,[[["f64x2"]],["self"]]],[11,"from_bits","","",52,[[["m64x2"]],["self"]]],[11,"from_bits","","",52,[[["i128x1"]],["self"]]],[11,"from_bits","","",52,[[["m128x1"]],["self"]]],[11,"from_bits","","",54,[[["u8x32"]],["self"]]],[11,"from_bits","","",54,[[["m8x32"]],["self"]]],[11,"from_bits","","",54,[[["i16x16"]],["self"]]],[11,"from_bits","","",54,[[["u16x16"]],["self"]]],[11,"from_bits","","",54,[[["m16x16"]],["self"]]],[11,"from_bits","","",54,[[["i32x8"]],["self"]]],[11,"from_bits","","",54,[[["u32x8"]],["self"]]],[11,"from_bits","","",54,[[["f32x8"]],["self"]]],[11,"from_bits","","",54,[[["m32x8"]],["self"]]],[11,"from_bits","","",54,[[["i64x4"]],["self"]]],[11,"from_bits","","",54,[[["u64x4"]],["self"]]],[11,"from_bits","","",54,[[["f64x4"]],["self"]]],[11,"from_bits","","",54,[[["m64x4"]],["self"]]],[11,"from_bits","","",54,[[["i128x2"]],["self"]]],[11,"from_bits","","",54,[[["u128x2"]],["self"]]],[11,"from_bits","","",54,[[["m128x2"]],["self"]]],[11,"from_bits","","",55,[[["i8x32"]],["self"]]],[11,"from_bits","","",55,[[["m8x32"]],["self"]]],[11,"from_bits","","",55,[[["i16x16"]],["self"]]],[11,"from_bits","","",55,[[["u16x16"]],["self"]]],[11,"from_bits","","",55,[[["m16x16"]],["self"]]],[11,"from_bits","","",55,[[["i32x8"]],["self"]]],[11,"from_bits","","",55,[[["u32x8"]],["self"]]],[11,"from_bits","","",55,[[["f32x8"]],["self"]]],[11,"from_bits","","",55,[[["m32x8"]],["self"]]],[11,"from_bits","","",55,[[["i64x4"]],["self"]]],[11,"from_bits","","",55,[[["u64x4"]],["self"]]],[11,"from_bits","","",55,[[["f64x4"]],["self"]]],[11,"from_bits","","",55,[[["m64x4"]],["self"]]],[11,"from_bits","","",55,[[["i128x2"]],["self"]]],[11,"from_bits","","",55,[[["u128x2"]],["self"]]],[11,"from_bits","","",55,[[["m128x2"]],["self"]]],[11,"from_bits","","",56,[[["m16x16"]],["self"]]],[11,"from_bits","","",56,[[["m32x8"]],["self"]]],[11,"from_bits","","",56,[[["m64x4"]],["self"]]],[11,"from_bits","","",56,[[["m128x2"]],["self"]]],[11,"from_bits","","",57,[[["i8x32"]],["self"]]],[11,"from_bits","","",57,[[["u8x32"]],["self"]]],[11,"from_bits","","",57,[[["m8x32"]],["self"]]],[11,"from_bits","","",57,[[["u16x16"]],["self"]]],[11,"from_bits","","",57,[[["m16x16"]],["self"]]],[11,"from_bits","","",57,[[["i32x8"]],["self"]]],[11,"from_bits","","",57,[[["u32x8"]],["self"]]],[11,"from_bits","","",57,[[["f32x8"]],["self"]]],[11,"from_bits","","",57,[[["m32x8"]],["self"]]],[11,"from_bits","","",57,[[["i64x4"]],["self"]]],[11,"from_bits","","",57,[[["u64x4"]],["self"]]],[11,"from_bits","","",57,[[["f64x4"]],["self"]]],[11,"from_bits","","",57,[[["m64x4"]],["self"]]],[11,"from_bits","","",57,[[["i128x2"]],["self"]]],[11,"from_bits","","",57,[[["u128x2"]],["self"]]],[11,"from_bits","","",57,[[["m128x2"]],["self"]]],[11,"from_bits","","",58,[[["i8x32"]],["self"]]],[11,"from_bits","","",58,[[["u8x32"]],["self"]]],[11,"from_bits","","",58,[[["m8x32"]],["self"]]],[11,"from_bits","","",58,[[["i16x16"]],["self"]]],[11,"from_bits","","",58,[[["m16x16"]],["self"]]],[11,"from_bits","","",58,[[["i32x8"]],["self"]]],[11,"from_bits","","",58,[[["u32x8"]],["self"]]],[11,"from_bits","","",58,[[["f32x8"]],["self"]]],[11,"from_bits","","",58,[[["m32x8"]],["self"]]],[11,"from_bits","","",58,[[["i64x4"]],["self"]]],[11,"from_bits","","",58,[[["u64x4"]],["self"]]],[11,"from_bits","","",58,[[["f64x4"]],["self"]]],[11,"from_bits","","",58,[[["m64x4"]],["self"]]],[11,"from_bits","","",58,[[["i128x2"]],["self"]]],[11,"from_bits","","",58,[[["u128x2"]],["self"]]],[11,"from_bits","","",58,[[["m128x2"]],["self"]]],[11,"from_bits","","",59,[[["m32x8"]],["self"]]],[11,"from_bits","","",59,[[["m64x4"]],["self"]]],[11,"from_bits","","",59,[[["m128x2"]],["self"]]],[11,"from_bits","","",60,[[["i8x32"]],["self"]]],[11,"from_bits","","",60,[[["u8x32"]],["self"]]],[11,"from_bits","","",60,[[["m8x32"]],["self"]]],[11,"from_bits","","",60,[[["i16x16"]],["self"]]],[11,"from_bits","","",60,[[["u16x16"]],["self"]]],[11,"from_bits","","",60,[[["m16x16"]],["self"]]],[11,"from_bits","","",60,[[["u32x8"]],["self"]]],[11,"from_bits","","",60,[[["f32x8"]],["self"]]],[11,"from_bits","","",60,[[["m32x8"]],["self"]]],[11,"from_bits","","",60,[[["i64x4"]],["self"]]],[11,"from_bits","","",60,[[["u64x4"]],["self"]]],[11,"from_bits","","",60,[[["f64x4"]],["self"]]],[11,"from_bits","","",60,[[["m64x4"]],["self"]]],[11,"from_bits","","",60,[[["i128x2"]],["self"]]],[11,"from_bits","","",60,[[["u128x2"]],["self"]]],[11,"from_bits","","",60,[[["m128x2"]],["self"]]],[11,"from_bits","","",61,[[["i8x32"]],["self"]]],[11,"from_bits","","",61,[[["u8x32"]],["self"]]],[11,"from_bits","","",61,[[["m8x32"]],["self"]]],[11,"from_bits","","",61,[[["i16x16"]],["self"]]],[11,"from_bits","","",61,[[["u16x16"]],["self"]]],[11,"from_bits","","",61,[[["m16x16"]],["self"]]],[11,"from_bits","","",61,[[["i32x8"]],["self"]]],[11,"from_bits","","",61,[[["f32x8"]],["self"]]],[11,"from_bits","","",61,[[["m32x8"]],["self"]]],[11,"from_bits","","",61,[[["i64x4"]],["self"]]],[11,"from_bits","","",61,[[["u64x4"]],["self"]]],[11,"from_bits","","",61,[[["f64x4"]],["self"]]],[11,"from_bits","","",61,[[["m64x4"]],["self"]]],[11,"from_bits","","",61,[[["i128x2"]],["self"]]],[11,"from_bits","","",61,[[["u128x2"]],["self"]]],[11,"from_bits","","",61,[[["m128x2"]],["self"]]],[11,"from_bits","","",62,[[["i8x32"]],["self"]]],[11,"from_bits","","",62,[[["u8x32"]],["self"]]],[11,"from_bits","","",62,[[["m8x32"]],["self"]]],[11,"from_bits","","",62,[[["i16x16"]],["self"]]],[11,"from_bits","","",62,[[["u16x16"]],["self"]]],[11,"from_bits","","",62,[[["m16x16"]],["self"]]],[11,"from_bits","","",62,[[["i32x8"]],["self"]]],[11,"from_bits","","",62,[[["u32x8"]],["self"]]],[11,"from_bits","","",62,[[["m32x8"]],["self"]]],[11,"from_bits","","",62,[[["i64x4"]],["self"]]],[11,"from_bits","","",62,[[["u64x4"]],["self"]]],[11,"from_bits","","",62,[[["f64x4"]],["self"]]],[11,"from_bits","","",62,[[["m64x4"]],["self"]]],[11,"from_bits","","",62,[[["i128x2"]],["self"]]],[11,"from_bits","","",62,[[["u128x2"]],["self"]]],[11,"from_bits","","",62,[[["m128x2"]],["self"]]],[11,"from_bits","","",63,[[["m64x4"]],["self"]]],[11,"from_bits","","",63,[[["m128x2"]],["self"]]],[11,"from_bits","","",64,[[["i8x32"]],["self"]]],[11,"from_bits","","",64,[[["u8x32"]],["self"]]],[11,"from_bits","","",64,[[["m8x32"]],["self"]]],[11,"from_bits","","",64,[[["i16x16"]],["self"]]],[11,"from_bits","","",64,[[["u16x16"]],["self"]]],[11,"from_bits","","",64,[[["m16x16"]],["self"]]],[11,"from_bits","","",64,[[["i32x8"]],["self"]]],[11,"from_bits","","",64,[[["u32x8"]],["self"]]],[11,"from_bits","","",64,[[["f32x8"]],["self"]]],[11,"from_bits","","",64,[[["m32x8"]],["self"]]],[11,"from_bits","","",64,[[["u64x4"]],["self"]]],[11,"from_bits","","",64,[[["f64x4"]],["self"]]],[11,"from_bits","","",64,[[["m64x4"]],["self"]]],[11,"from_bits","","",64,[[["i128x2"]],["self"]]],[11,"from_bits","","",64,[[["u128x2"]],["self"]]],[11,"from_bits","","",64,[[["m128x2"]],["self"]]],[11,"from_bits","","",65,[[["i8x32"]],["self"]]],[11,"from_bits","","",65,[[["u8x32"]],["self"]]],[11,"from_bits","","",65,[[["m8x32"]],["self"]]],[11,"from_bits","","",65,[[["i16x16"]],["self"]]],[11,"from_bits","","",65,[[["u16x16"]],["self"]]],[11,"from_bits","","",65,[[["m16x16"]],["self"]]],[11,"from_bits","","",65,[[["i32x8"]],["self"]]],[11,"from_bits","","",65,[[["u32x8"]],["self"]]],[11,"from_bits","","",65,[[["f32x8"]],["self"]]],[11,"from_bits","","",65,[[["m32x8"]],["self"]]],[11,"from_bits","","",65,[[["i64x4"]],["self"]]],[11,"from_bits","","",65,[[["f64x4"]],["self"]]],[11,"from_bits","","",65,[[["m64x4"]],["self"]]],[11,"from_bits","","",65,[[["i128x2"]],["self"]]],[11,"from_bits","","",65,[[["u128x2"]],["self"]]],[11,"from_bits","","",65,[[["m128x2"]],["self"]]],[11,"from_bits","","",66,[[["i8x32"]],["self"]]],[11,"from_bits","","",66,[[["u8x32"]],["self"]]],[11,"from_bits","","",66,[[["m8x32"]],["self"]]],[11,"from_bits","","",66,[[["i16x16"]],["self"]]],[11,"from_bits","","",66,[[["u16x16"]],["self"]]],[11,"from_bits","","",66,[[["m16x16"]],["self"]]],[11,"from_bits","","",66,[[["i32x8"]],["self"]]],[11,"from_bits","","",66,[[["u32x8"]],["self"]]],[11,"from_bits","","",66,[[["f32x8"]],["self"]]],[11,"from_bits","","",66,[[["m32x8"]],["self"]]],[11,"from_bits","","",66,[[["i64x4"]],["self"]]],[11,"from_bits","","",66,[[["u64x4"]],["self"]]],[11,"from_bits","","",66,[[["m64x4"]],["self"]]],[11,"from_bits","","",66,[[["i128x2"]],["self"]]],[11,"from_bits","","",66,[[["u128x2"]],["self"]]],[11,"from_bits","","",66,[[["m128x2"]],["self"]]],[11,"from_bits","","",67,[[["m128x2"]],["self"]]],[11,"from_bits","","",68,[[["i8x32"]],["self"]]],[11,"from_bits","","",68,[[["u8x32"]],["self"]]],[11,"from_bits","","",68,[[["m8x32"]],["self"]]],[11,"from_bits","","",68,[[["i16x16"]],["self"]]],[11,"from_bits","","",68,[[["u16x16"]],["self"]]],[11,"from_bits","","",68,[[["m16x16"]],["self"]]],[11,"from_bits","","",68,[[["i32x8"]],["self"]]],[11,"from_bits","","",68,[[["u32x8"]],["self"]]],[11,"from_bits","","",68,[[["f32x8"]],["self"]]],[11,"from_bits","","",68,[[["m32x8"]],["self"]]],[11,"from_bits","","",68,[[["i64x4"]],["self"]]],[11,"from_bits","","",68,[[["u64x4"]],["self"]]],[11,"from_bits","","",68,[[["f64x4"]],["self"]]],[11,"from_bits","","",68,[[["m64x4"]],["self"]]],[11,"from_bits","","",68,[[["u128x2"]],["self"]]],[11,"from_bits","","",68,[[["m128x2"]],["self"]]],[11,"from_bits","","",69,[[["i8x32"]],["self"]]],[11,"from_bits","","",69,[[["u8x32"]],["self"]]],[11,"from_bits","","",69,[[["m8x32"]],["self"]]],[11,"from_bits","","",69,[[["i16x16"]],["self"]]],[11,"from_bits","","",69,[[["u16x16"]],["self"]]],[11,"from_bits","","",69,[[["m16x16"]],["self"]]],[11,"from_bits","","",69,[[["i32x8"]],["self"]]],[11,"from_bits","","",69,[[["u32x8"]],["self"]]],[11,"from_bits","","",69,[[["f32x8"]],["self"]]],[11,"from_bits","","",69,[[["m32x8"]],["self"]]],[11,"from_bits","","",69,[[["i64x4"]],["self"]]],[11,"from_bits","","",69,[[["u64x4"]],["self"]]],[11,"from_bits","","",69,[[["f64x4"]],["self"]]],[11,"from_bits","","",69,[[["m64x4"]],["self"]]],[11,"from_bits","","",69,[[["i128x2"]],["self"]]],[11,"from_bits","","",69,[[["m128x2"]],["self"]]],[11,"from_bits","","",74,[[["u8x64"]],["self"]]],[11,"from_bits","","",74,[[["m8x64"]],["self"]]],[11,"from_bits","","",74,[[["i16x32"]],["self"]]],[11,"from_bits","","",74,[[["u16x32"]],["self"]]],[11,"from_bits","","",74,[[["m16x32"]],["self"]]],[11,"from_bits","","",74,[[["i32x16"]],["self"]]],[11,"from_bits","","",74,[[["u32x16"]],["self"]]],[11,"from_bits","","",74,[[["f32x16"]],["self"]]],[11,"from_bits","","",74,[[["m32x16"]],["self"]]],[11,"from_bits","","",74,[[["i64x8"]],["self"]]],[11,"from_bits","","",74,[[["u64x8"]],["self"]]],[11,"from_bits","","",74,[[["f64x8"]],["self"]]],[11,"from_bits","","",74,[[["m64x8"]],["self"]]],[11,"from_bits","","",74,[[["i128x4"]],["self"]]],[11,"from_bits","","",74,[[["u128x4"]],["self"]]],[11,"from_bits","","",74,[[["m128x4"]],["self"]]],[11,"from_bits","","",75,[[["i8x64"]],["self"]]],[11,"from_bits","","",75,[[["m8x64"]],["self"]]],[11,"from_bits","","",75,[[["i16x32"]],["self"]]],[11,"from_bits","","",75,[[["u16x32"]],["self"]]],[11,"from_bits","","",75,[[["m16x32"]],["self"]]],[11,"from_bits","","",75,[[["i32x16"]],["self"]]],[11,"from_bits","","",75,[[["u32x16"]],["self"]]],[11,"from_bits","","",75,[[["f32x16"]],["self"]]],[11,"from_bits","","",75,[[["m32x16"]],["self"]]],[11,"from_bits","","",75,[[["i64x8"]],["self"]]],[11,"from_bits","","",75,[[["u64x8"]],["self"]]],[11,"from_bits","","",75,[[["f64x8"]],["self"]]],[11,"from_bits","","",75,[[["m64x8"]],["self"]]],[11,"from_bits","","",75,[[["i128x4"]],["self"]]],[11,"from_bits","","",75,[[["u128x4"]],["self"]]],[11,"from_bits","","",75,[[["m128x4"]],["self"]]],[11,"from_bits","","",76,[[["m16x32"]],["self"]]],[11,"from_bits","","",76,[[["m32x16"]],["self"]]],[11,"from_bits","","",76,[[["m64x8"]],["self"]]],[11,"from_bits","","",76,[[["m128x4"]],["self"]]],[11,"from_bits","","",77,[[["i8x64"]],["self"]]],[11,"from_bits","","",77,[[["u8x64"]],["self"]]],[11,"from_bits","","",77,[[["m8x64"]],["self"]]],[11,"from_bits","","",77,[[["u16x32"]],["self"]]],[11,"from_bits","","",77,[[["m16x32"]],["self"]]],[11,"from_bits","","",77,[[["i32x16"]],["self"]]],[11,"from_bits","","",77,[[["u32x16"]],["self"]]],[11,"from_bits","","",77,[[["f32x16"]],["self"]]],[11,"from_bits","","",77,[[["m32x16"]],["self"]]],[11,"from_bits","","",77,[[["i64x8"]],["self"]]],[11,"from_bits","","",77,[[["u64x8"]],["self"]]],[11,"from_bits","","",77,[[["f64x8"]],["self"]]],[11,"from_bits","","",77,[[["m64x8"]],["self"]]],[11,"from_bits","","",77,[[["i128x4"]],["self"]]],[11,"from_bits","","",77,[[["u128x4"]],["self"]]],[11,"from_bits","","",77,[[["m128x4"]],["self"]]],[11,"from_bits","","",78,[[["i8x64"]],["self"]]],[11,"from_bits","","",78,[[["u8x64"]],["self"]]],[11,"from_bits","","",78,[[["m8x64"]],["self"]]],[11,"from_bits","","",78,[[["i16x32"]],["self"]]],[11,"from_bits","","",78,[[["m16x32"]],["self"]]],[11,"from_bits","","",78,[[["i32x16"]],["self"]]],[11,"from_bits","","",78,[[["u32x16"]],["self"]]],[11,"from_bits","","",78,[[["f32x16"]],["self"]]],[11,"from_bits","","",78,[[["m32x16"]],["self"]]],[11,"from_bits","","",78,[[["i64x8"]],["self"]]],[11,"from_bits","","",78,[[["u64x8"]],["self"]]],[11,"from_bits","","",78,[[["f64x8"]],["self"]]],[11,"from_bits","","",78,[[["m64x8"]],["self"]]],[11,"from_bits","","",78,[[["i128x4"]],["self"]]],[11,"from_bits","","",78,[[["u128x4"]],["self"]]],[11,"from_bits","","",78,[[["m128x4"]],["self"]]],[11,"from_bits","","",79,[[["m32x16"]],["self"]]],[11,"from_bits","","",79,[[["m64x8"]],["self"]]],[11,"from_bits","","",79,[[["m128x4"]],["self"]]],[11,"from_bits","","",80,[[["i8x64"]],["self"]]],[11,"from_bits","","",80,[[["u8x64"]],["self"]]],[11,"from_bits","","",80,[[["m8x64"]],["self"]]],[11,"from_bits","","",80,[[["i16x32"]],["self"]]],[11,"from_bits","","",80,[[["u16x32"]],["self"]]],[11,"from_bits","","",80,[[["m16x32"]],["self"]]],[11,"from_bits","","",80,[[["u32x16"]],["self"]]],[11,"from_bits","","",80,[[["f32x16"]],["self"]]],[11,"from_bits","","",80,[[["m32x16"]],["self"]]],[11,"from_bits","","",80,[[["i64x8"]],["self"]]],[11,"from_bits","","",80,[[["u64x8"]],["self"]]],[11,"from_bits","","",80,[[["f64x8"]],["self"]]],[11,"from_bits","","",80,[[["m64x8"]],["self"]]],[11,"from_bits","","",80,[[["i128x4"]],["self"]]],[11,"from_bits","","",80,[[["u128x4"]],["self"]]],[11,"from_bits","","",80,[[["m128x4"]],["self"]]],[11,"from_bits","","",81,[[["i8x64"]],["self"]]],[11,"from_bits","","",81,[[["u8x64"]],["self"]]],[11,"from_bits","","",81,[[["m8x64"]],["self"]]],[11,"from_bits","","",81,[[["i16x32"]],["self"]]],[11,"from_bits","","",81,[[["u16x32"]],["self"]]],[11,"from_bits","","",81,[[["m16x32"]],["self"]]],[11,"from_bits","","",81,[[["i32x16"]],["self"]]],[11,"from_bits","","",81,[[["f32x16"]],["self"]]],[11,"from_bits","","",81,[[["m32x16"]],["self"]]],[11,"from_bits","","",81,[[["i64x8"]],["self"]]],[11,"from_bits","","",81,[[["u64x8"]],["self"]]],[11,"from_bits","","",81,[[["f64x8"]],["self"]]],[11,"from_bits","","",81,[[["m64x8"]],["self"]]],[11,"from_bits","","",81,[[["i128x4"]],["self"]]],[11,"from_bits","","",81,[[["u128x4"]],["self"]]],[11,"from_bits","","",81,[[["m128x4"]],["self"]]],[11,"from_bits","","",82,[[["i8x64"]],["self"]]],[11,"from_bits","","",82,[[["u8x64"]],["self"]]],[11,"from_bits","","",82,[[["m8x64"]],["self"]]],[11,"from_bits","","",82,[[["i16x32"]],["self"]]],[11,"from_bits","","",82,[[["u16x32"]],["self"]]],[11,"from_bits","","",82,[[["m16x32"]],["self"]]],[11,"from_bits","","",82,[[["i32x16"]],["self"]]],[11,"from_bits","","",82,[[["u32x16"]],["self"]]],[11,"from_bits","","",82,[[["m32x16"]],["self"]]],[11,"from_bits","","",82,[[["i64x8"]],["self"]]],[11,"from_bits","","",82,[[["u64x8"]],["self"]]],[11,"from_bits","","",82,[[["f64x8"]],["self"]]],[11,"from_bits","","",82,[[["m64x8"]],["self"]]],[11,"from_bits","","",82,[[["i128x4"]],["self"]]],[11,"from_bits","","",82,[[["u128x4"]],["self"]]],[11,"from_bits","","",82,[[["m128x4"]],["self"]]],[11,"from_bits","","",83,[[["m64x8"]],["self"]]],[11,"from_bits","","",83,[[["m128x4"]],["self"]]],[11,"from_bits","","",84,[[["i8x64"]],["self"]]],[11,"from_bits","","",84,[[["u8x64"]],["self"]]],[11,"from_bits","","",84,[[["m8x64"]],["self"]]],[11,"from_bits","","",84,[[["i16x32"]],["self"]]],[11,"from_bits","","",84,[[["u16x32"]],["self"]]],[11,"from_bits","","",84,[[["m16x32"]],["self"]]],[11,"from_bits","","",84,[[["i32x16"]],["self"]]],[11,"from_bits","","",84,[[["u32x16"]],["self"]]],[11,"from_bits","","",84,[[["f32x16"]],["self"]]],[11,"from_bits","","",84,[[["m32x16"]],["self"]]],[11,"from_bits","","",84,[[["u64x8"]],["self"]]],[11,"from_bits","","",84,[[["f64x8"]],["self"]]],[11,"from_bits","","",84,[[["m64x8"]],["self"]]],[11,"from_bits","","",84,[[["i128x4"]],["self"]]],[11,"from_bits","","",84,[[["u128x4"]],["self"]]],[11,"from_bits","","",84,[[["m128x4"]],["self"]]],[11,"from_bits","","",85,[[["i8x64"]],["self"]]],[11,"from_bits","","",85,[[["u8x64"]],["self"]]],[11,"from_bits","","",85,[[["m8x64"]],["self"]]],[11,"from_bits","","",85,[[["i16x32"]],["self"]]],[11,"from_bits","","",85,[[["u16x32"]],["self"]]],[11,"from_bits","","",85,[[["m16x32"]],["self"]]],[11,"from_bits","","",85,[[["i32x16"]],["self"]]],[11,"from_bits","","",85,[[["u32x16"]],["self"]]],[11,"from_bits","","",85,[[["f32x16"]],["self"]]],[11,"from_bits","","",85,[[["m32x16"]],["self"]]],[11,"from_bits","","",85,[[["i64x8"]],["self"]]],[11,"from_bits","","",85,[[["f64x8"]],["self"]]],[11,"from_bits","","",85,[[["m64x8"]],["self"]]],[11,"from_bits","","",85,[[["i128x4"]],["self"]]],[11,"from_bits","","",85,[[["u128x4"]],["self"]]],[11,"from_bits","","",85,[[["m128x4"]],["self"]]],[11,"from_bits","","",86,[[["i8x64"]],["self"]]],[11,"from_bits","","",86,[[["u8x64"]],["self"]]],[11,"from_bits","","",86,[[["m8x64"]],["self"]]],[11,"from_bits","","",86,[[["i16x32"]],["self"]]],[11,"from_bits","","",86,[[["u16x32"]],["self"]]],[11,"from_bits","","",86,[[["m16x32"]],["self"]]],[11,"from_bits","","",86,[[["i32x16"]],["self"]]],[11,"from_bits","","",86,[[["u32x16"]],["self"]]],[11,"from_bits","","",86,[[["f32x16"]],["self"]]],[11,"from_bits","","",86,[[["m32x16"]],["self"]]],[11,"from_bits","","",86,[[["i64x8"]],["self"]]],[11,"from_bits","","",86,[[["u64x8"]],["self"]]],[11,"from_bits","","",86,[[["m64x8"]],["self"]]],[11,"from_bits","","",86,[[["i128x4"]],["self"]]],[11,"from_bits","","",86,[[["u128x4"]],["self"]]],[11,"from_bits","","",86,[[["m128x4"]],["self"]]],[11,"from_bits","","",87,[[["m128x4"]],["self"]]],[11,"from_bits","","",88,[[["i8x64"]],["self"]]],[11,"from_bits","","",88,[[["u8x64"]],["self"]]],[11,"from_bits","","",88,[[["m8x64"]],["self"]]],[11,"from_bits","","",88,[[["i16x32"]],["self"]]],[11,"from_bits","","",88,[[["u16x32"]],["self"]]],[11,"from_bits","","",88,[[["m16x32"]],["self"]]],[11,"from_bits","","",88,[[["i32x16"]],["self"]]],[11,"from_bits","","",88,[[["u32x16"]],["self"]]],[11,"from_bits","","",88,[[["f32x16"]],["self"]]],[11,"from_bits","","",88,[[["m32x16"]],["self"]]],[11,"from_bits","","",88,[[["i64x8"]],["self"]]],[11,"from_bits","","",88,[[["u64x8"]],["self"]]],[11,"from_bits","","",88,[[["f64x8"]],["self"]]],[11,"from_bits","","",88,[[["m64x8"]],["self"]]],[11,"from_bits","","",88,[[["u128x4"]],["self"]]],[11,"from_bits","","",88,[[["m128x4"]],["self"]]],[11,"from_bits","","",89,[[["i8x64"]],["self"]]],[11,"from_bits","","",89,[[["u8x64"]],["self"]]],[11,"from_bits","","",89,[[["m8x64"]],["self"]]],[11,"from_bits","","",89,[[["i16x32"]],["self"]]],[11,"from_bits","","",89,[[["u16x32"]],["self"]]],[11,"from_bits","","",89,[[["m16x32"]],["self"]]],[11,"from_bits","","",89,[[["i32x16"]],["self"]]],[11,"from_bits","","",89,[[["u32x16"]],["self"]]],[11,"from_bits","","",89,[[["f32x16"]],["self"]]],[11,"from_bits","","",89,[[["m32x16"]],["self"]]],[11,"from_bits","","",89,[[["i64x8"]],["self"]]],[11,"from_bits","","",89,[[["u64x8"]],["self"]]],[11,"from_bits","","",89,[[["f64x8"]],["self"]]],[11,"from_bits","","",89,[[["m64x8"]],["self"]]],[11,"from_bits","","",89,[[["i128x4"]],["self"]]],[11,"from_bits","","",89,[[["m128x4"]],["self"]]],[11,"from_bits","","",24,[[["__m64"]],["self"]]],[11,"from_bits","","",25,[[["__m64"]],["self"]]],[11,"from_bits","","",27,[[["__m64"]],["self"]]],[11,"from_bits","","",28,[[["__m64"]],["self"]]],[11,"from_bits","","",30,[[["__m64"]],["self"]]],[11,"from_bits","","",31,[[["__m64"]],["self"]]],[11,"from_bits","","",32,[[["__m64"]],["self"]]],[11,"from_bits","","",34,[[["__m128"]],["self"]]],[11,"from_bits","","",35,[[["__m128"]],["self"]]],[11,"from_bits","","",37,[[["__m128"]],["self"]]],[11,"from_bits","","",38,[[["__m128"]],["self"]]],[11,"from_bits","","",40,[[["__m128"]],["self"]]],[11,"from_bits","","",41,[[["__m128"]],["self"]]],[11,"from_bits","","",42,[[["__m128"]],["self"]]],[11,"from_bits","","",44,[[["__m128"]],["self"]]],[11,"from_bits","","",45,[[["__m128"]],["self"]]],[11,"from_bits","","",46,[[["__m128"]],["self"]]],[11,"from_bits","","",51,[[["__m128"]],["self"]]],[11,"from_bits","","",52,[[["__m128"]],["self"]]],[11,"from_bits","","",34,[[["__m128i"]],["self"]]],[11,"from_bits","","",35,[[["__m128i"]],["self"]]],[11,"from_bits","","",37,[[["__m128i"]],["self"]]],[11,"from_bits","","",38,[[["__m128i"]],["self"]]],[11,"from_bits","","",40,[[["__m128i"]],["self"]]],[11,"from_bits","","",41,[[["__m128i"]],["self"]]],[11,"from_bits","","",42,[[["__m128i"]],["self"]]],[11,"from_bits","","",44,[[["__m128i"]],["self"]]],[11,"from_bits","","",45,[[["__m128i"]],["self"]]],[11,"from_bits","","",46,[[["__m128i"]],["self"]]],[11,"from_bits","","",51,[[["__m128i"]],["self"]]],[11,"from_bits","","",52,[[["__m128i"]],["self"]]],[11,"from_bits","","",34,[[["__m128d"]],["self"]]],[11,"from_bits","","",35,[[["__m128d"]],["self"]]],[11,"from_bits","","",37,[[["__m128d"]],["self"]]],[11,"from_bits","","",38,[[["__m128d"]],["self"]]],[11,"from_bits","","",40,[[["__m128d"]],["self"]]],[11,"from_bits","","",41,[[["__m128d"]],["self"]]],[11,"from_bits","","",42,[[["__m128d"]],["self"]]],[11,"from_bits","","",44,[[["__m128d"]],["self"]]],[11,"from_bits","","",45,[[["__m128d"]],["self"]]],[11,"from_bits","","",46,[[["__m128d"]],["self"]]],[11,"from_bits","","",51,[[["__m128d"]],["self"]]],[11,"from_bits","","",52,[[["__m128d"]],["self"]]],[11,"from_bits","","",54,[[["__m256"]],["self"]]],[11,"from_bits","","",55,[[["__m256"]],["self"]]],[11,"from_bits","","",57,[[["__m256"]],["self"]]],[11,"from_bits","","",58,[[["__m256"]],["self"]]],[11,"from_bits","","",60,[[["__m256"]],["self"]]],[11,"from_bits","","",61,[[["__m256"]],["self"]]],[11,"from_bits","","",62,[[["__m256"]],["self"]]],[11,"from_bits","","",64,[[["__m256"]],["self"]]],[11,"from_bits","","",65,[[["__m256"]],["self"]]],[11,"from_bits","","",66,[[["__m256"]],["self"]]],[11,"from_bits","","",68,[[["__m256"]],["self"]]],[11,"from_bits","","",69,[[["__m256"]],["self"]]],[11,"from_bits","","",54,[[["__m256i"]],["self"]]],[11,"from_bits","","",55,[[["__m256i"]],["self"]]],[11,"from_bits","","",57,[[["__m256i"]],["self"]]],[11,"from_bits","","",58,[[["__m256i"]],["self"]]],[11,"from_bits","","",60,[[["__m256i"]],["self"]]],[11,"from_bits","","",61,[[["__m256i"]],["self"]]],[11,"from_bits","","",62,[[["__m256i"]],["self"]]],[11,"from_bits","","",64,[[["__m256i"]],["self"]]],[11,"from_bits","","",65,[[["__m256i"]],["self"]]],[11,"from_bits","","",66,[[["__m256i"]],["self"]]],[11,"from_bits","","",68,[[["__m256i"]],["self"]]],[11,"from_bits","","",69,[[["__m256i"]],["self"]]],[11,"from_bits","","",54,[[["__m256d"]],["self"]]],[11,"from_bits","","",55,[[["__m256d"]],["self"]]],[11,"from_bits","","",57,[[["__m256d"]],["self"]]],[11,"from_bits","","",58,[[["__m256d"]],["self"]]],[11,"from_bits","","",60,[[["__m256d"]],["self"]]],[11,"from_bits","","",61,[[["__m256d"]],["self"]]],[11,"from_bits","","",62,[[["__m256d"]],["self"]]],[11,"from_bits","","",64,[[["__m256d"]],["self"]]],[11,"from_bits","","",65,[[["__m256d"]],["self"]]],[11,"from_bits","","",66,[[["__m256d"]],["self"]]],[11,"from_bits","","",68,[[["__m256d"]],["self"]]],[11,"from_bits","","",69,[[["__m256d"]],["self"]]],[11,"test","","",0,[[["self"]],["bool"]]],[11,"test","","",1,[[["self"]],["bool"]]],[11,"test","","",2,[[["self"]],["bool"]]],[11,"test","","",3,[[["self"]],["bool"]]],[11,"test","","",4,[[["self"]],["bool"]]],[11,"test","","",5,[[["self"]],["bool"]]],[11,"from","","",15,[[],["self"]]],[11,"from","","",16,[[],["self"]]],[11,"from","","",17,[[],["self"]]],[11,"from","","",17,[[["m16x2"]],["self"]]],[11,"from","","",17,[[["m32x2"]],["self"]]],[11,"from","","",17,[[["m64x2"]],["self"]]],[11,"from","","",17,[[["m128x2"]],["self"]]],[11,"from","","",18,[[],["self"]]],[11,"from","","",19,[[],["self"]]],[11,"from","","",20,[[],["self"]]],[11,"from","","",20,[[["m16x4"]],["self"]]],[11,"from","","",20,[[["m32x4"]],["self"]]],[11,"from","","",20,[[["m64x4"]],["self"]]],[11,"from","","",21,[[],["self"]]],[11,"from","","",21,[[["i8x2"]],["self"]]],[11,"from","","",21,[[["u8x2"]],["self"]]],[11,"from","","",22,[[],["self"]]],[11,"from","","",22,[[["u8x2"]],["self"]]],[11,"from","","",23,[[],["self"]]],[11,"from","","",23,[[["m8x2"]],["self"]]],[11,"from","","",23,[[["m32x2"]],["self"]]],[11,"from","","",23,[[["m64x2"]],["self"]]],[11,"from","","",23,[[["m128x2"]],["self"]]],[11,"from","","",24,[[],["self"]]],[11,"from","","",25,[[],["self"]]],[11,"from","","",26,[[],["self"]]],[11,"from","","",26,[[["m16x8"]],["self"]]],[11,"from","","",26,[[["m32x8"]],["self"]]],[11,"from","","",27,[[],["self"]]],[11,"from","","",27,[[["i8x4"]],["self"]]],[11,"from","","",27,[[["u8x4"]],["self"]]],[11,"from","","",28,[[],["self"]]],[11,"from","","",28,[[["u8x4"]],["self"]]],[11,"from","","",29,[[],["self"]]],[11,"from","","",29,[[["m8x4"]],["self"]]],[11,"from","","",29,[[["m32x4"]],["self"]]],[11,"from","","",29,[[["m64x4"]],["self"]]],[11,"from","","",30,[[],["self"]]],[11,"from","","",30,[[["i8x2"]],["self"]]],[11,"from","","",30,[[["u8x2"]],["self"]]],[11,"from","","",30,[[["i16x2"]],["self"]]],[11,"from","","",30,[[["u16x2"]],["self"]]],[11,"from","","",31,[[],["self"]]],[11,"from","","",31,[[["u8x2"]],["self"]]],[11,"from","","",31,[[["u16x2"]],["self"]]],[11,"from","","",33,[[],["self"]]],[11,"from","","",33,[[["m8x2"]],["self"]]],[11,"from","","",33,[[["m16x2"]],["self"]]],[11,"from","","",33,[[["m64x2"]],["self"]]],[11,"from","","",33,[[["m128x2"]],["self"]]],[11,"from","","",32,[[],["self"]]],[11,"from","","",32,[[["i8x2"]],["self"]]],[11,"from","","",32,[[["u8x2"]],["self"]]],[11,"from","","",32,[[["i16x2"]],["self"]]],[11,"from","","",32,[[["u16x2"]],["self"]]],[11,"from","","",34,[[],["self"]]],[11,"from","","",35,[[],["self"]]],[11,"from","","",36,[[],["self"]]],[11,"from","","",36,[[["m16x16"]],["self"]]],[11,"from","","",37,[[],["self"]]],[11,"from","","",37,[[["i8x8"]],["self"]]],[11,"from","","",37,[[["u8x8"]],["self"]]],[11,"from","","",38,[[],["self"]]],[11,"from","","",38,[[["u8x8"]],["self"]]],[11,"from","","",39,[[],["self"]]],[11,"from","","",39,[[["m8x8"]],["self"]]],[11,"from","","",39,[[["m32x8"]],["self"]]],[11,"from","","",40,[[],["self"]]],[11,"from","","",40,[[["i8x4"]],["self"]]],[11,"from","","",40,[[["u8x4"]],["self"]]],[11,"from","","",40,[[["i16x4"]],["self"]]],[11,"from","","",40,[[["u16x4"]],["self"]]],[11,"from","","",41,[[],["self"]]],[11,"from","","",41,[[["u8x4"]],["self"]]],[11,"from","","",41,[[["u16x4"]],["self"]]],[11,"from","","",42,[[],["self"]]],[11,"from","","",42,[[["i8x4"]],["self"]]],[11,"from","","",42,[[["u8x4"]],["self"]]],[11,"from","","",42,[[["i16x4"]],["self"]]],[11,"from","","",42,[[["u16x4"]],["self"]]],[11,"from","","",43,[[],["self"]]],[11,"from","","",43,[[["m8x4"]],["self"]]],[11,"from","","",43,[[["m16x4"]],["self"]]],[11,"from","","",43,[[["m64x4"]],["self"]]],[11,"from","","",44,[[],["self"]]],[11,"from","","",44,[[["i8x2"]],["self"]]],[11,"from","","",44,[[["u8x2"]],["self"]]],[11,"from","","",44,[[["i16x2"]],["self"]]],[11,"from","","",44,[[["u16x2"]],["self"]]],[11,"from","","",44,[[["i32x2"]],["self"]]],[11,"from","","",44,[[["u32x2"]],["self"]]],[11,"from","","",45,[[],["self"]]],[11,"from","","",45,[[["u8x2"]],["self"]]],[11,"from","","",45,[[["u16x2"]],["self"]]],[11,"from","","",45,[[["u32x2"]],["self"]]],[11,"from","","",46,[[],["self"]]],[11,"from","","",46,[[["i8x2"]],["self"]]],[11,"from","","",46,[[["u8x2"]],["self"]]],[11,"from","","",46,[[["i16x2"]],["self"]]],[11,"from","","",46,[[["u16x2"]],["self"]]],[11,"from","","",46,[[["i32x2"]],["self"]]],[11,"from","","",46,[[["u32x2"]],["self"]]],[11,"from","","",46,[[["f32x2"]],["self"]]],[11,"from","","",47,[[],["self"]]],[11,"from","","",47,[[["m8x2"]],["self"]]],[11,"from","","",47,[[["m16x2"]],["self"]]],[11,"from","","",47,[[["m32x2"]],["self"]]],[11,"from","","",47,[[["m128x2"]],["self"]]],[11,"from","","",51,[[],["self"]]],[11,"from","","",52,[[],["self"]]],[11,"from","","",53,[[],["self"]]],[11,"from","","",54,[[],["self"]]],[11,"from","","",55,[[],["self"]]],[11,"from","","",56,[[],["self"]]],[11,"from","","",57,[[],["self"]]],[11,"from","","",57,[[["i8x16"]],["self"]]],[11,"from","","",57,[[["u8x16"]],["self"]]],[11,"from","","",58,[[],["self"]]],[11,"from","","",58,[[["u8x16"]],["self"]]],[11,"from","","",59,[[],["self"]]],[11,"from","","",59,[[["m8x16"]],["self"]]],[11,"from","","",60,[[],["self"]]],[11,"from","","",60,[[["i8x8"]],["self"]]],[11,"from","","",60,[[["u8x8"]],["self"]]],[11,"from","","",60,[[["i16x8"]],["self"]]],[11,"from","","",60,[[["u16x8"]],["self"]]],[11,"from","","",61,[[],["self"]]],[11,"from","","",61,[[["u8x8"]],["self"]]],[11,"from","","",61,[[["u16x8"]],["self"]]],[11,"from","","",62,[[],["self"]]],[11,"from","","",62,[[["i8x8"]],["self"]]],[11,"from","","",62,[[["u8x8"]],["self"]]],[11,"from","","",62,[[["i16x8"]],["self"]]],[11,"from","","",62,[[["u16x8"]],["self"]]],[11,"from","","",63,[[],["self"]]],[11,"from","","",63,[[["m8x8"]],["self"]]],[11,"from","","",63,[[["m16x8"]],["self"]]],[11,"from","","",64,[[],["self"]]],[11,"from","","",64,[[["i8x4"]],["self"]]],[11,"from","","",64,[[["u8x4"]],["self"]]],[11,"from","","",64,[[["i16x4"]],["self"]]],[11,"from","","",64,[[["u16x4"]],["self"]]],[11,"from","","",64,[[["i32x4"]],["self"]]],[11,"from","","",64,[[["u32x4"]],["self"]]],[11,"from","","",65,[[],["self"]]],[11,"from","","",65,[[["u8x4"]],["self"]]],[11,"from","","",65,[[["u16x4"]],["self"]]],[11,"from","","",65,[[["u32x4"]],["self"]]],[11,"from","","",66,[[],["self"]]],[11,"from","","",66,[[["i8x4"]],["self"]]],[11,"from","","",66,[[["u8x4"]],["self"]]],[11,"from","","",66,[[["i16x4"]],["self"]]],[11,"from","","",66,[[["u16x4"]],["self"]]],[11,"from","","",66,[[["i32x4"]],["self"]]],[11,"from","","",66,[[["u32x4"]],["self"]]],[11,"from","","",66,[[["f32x4"]],["self"]]],[11,"from","","",67,[[],["self"]]],[11,"from","","",67,[[["m8x4"]],["self"]]],[11,"from","","",67,[[["m16x4"]],["self"]]],[11,"from","","",67,[[["m32x4"]],["self"]]],[11,"from","","",68,[[],["self"]]],[11,"from","","",68,[[["i8x2"]],["self"]]],[11,"from","","",68,[[["u8x2"]],["self"]]],[11,"from","","",68,[[["i16x2"]],["self"]]],[11,"from","","",68,[[["u16x2"]],["self"]]],[11,"from","","",68,[[["i32x2"]],["self"]]],[11,"from","","",68,[[["u32x2"]],["self"]]],[11,"from","","",68,[[["i64x2"]],["self"]]],[11,"from","","",68,[[["u64x2"]],["self"]]],[11,"from","","",69,[[],["self"]]],[11,"from","","",69,[[["u8x2"]],["self"]]],[11,"from","","",69,[[["u16x2"]],["self"]]],[11,"from","","",69,[[["u32x2"]],["self"]]],[11,"from","","",69,[[["u64x2"]],["self"]]],[11,"from","","",70,[[],["self"]]],[11,"from","","",70,[[["m8x2"]],["self"]]],[11,"from","","",70,[[["m16x2"]],["self"]]],[11,"from","","",70,[[["m32x2"]],["self"]]],[11,"from","","",70,[[["m64x2"]],["self"]]],[11,"from","","",74,[[],["self"]]],[11,"from","","",75,[[],["self"]]],[11,"from","","",76,[[],["self"]]],[11,"from","","",77,[[],["self"]]],[11,"from","","",77,[[["i8x32"]],["self"]]],[11,"from","","",77,[[["u8x32"]],["self"]]],[11,"from","","",78,[[],["self"]]],[11,"from","","",78,[[["u8x32"]],["self"]]],[11,"from","","",79,[[],["self"]]],[11,"from","","",79,[[["m8x32"]],["self"]]],[11,"from","","",80,[[],["self"]]],[11,"from","","",80,[[["i8x16"]],["self"]]],[11,"from","","",80,[[["u8x16"]],["self"]]],[11,"from","","",80,[[["i16x16"]],["self"]]],[11,"from","","",80,[[["u16x16"]],["self"]]],[11,"from","","",81,[[],["self"]]],[11,"from","","",81,[[["u8x16"]],["self"]]],[11,"from","","",81,[[["u16x16"]],["self"]]],[11,"from","","",82,[[],["self"]]],[11,"from","","",82,[[["i8x16"]],["self"]]],[11,"from","","",82,[[["u8x16"]],["self"]]],[11,"from","","",82,[[["i16x16"]],["self"]]],[11,"from","","",82,[[["u16x16"]],["self"]]],[11,"from","","",83,[[],["self"]]],[11,"from","","",83,[[["m8x16"]],["self"]]],[11,"from","","",83,[[["m16x16"]],["self"]]],[11,"from","","",84,[[],["self"]]],[11,"from","","",84,[[["i8x8"]],["self"]]],[11,"from","","",84,[[["u8x8"]],["self"]]],[11,"from","","",84,[[["i16x8"]],["self"]]],[11,"from","","",84,[[["u16x8"]],["self"]]],[11,"from","","",84,[[["i32x8"]],["self"]]],[11,"from","","",84,[[["u32x8"]],["self"]]],[11,"from","","",85,[[],["self"]]],[11,"from","","",85,[[["u8x8"]],["self"]]],[11,"from","","",85,[[["u16x8"]],["self"]]],[11,"from","","",85,[[["u32x8"]],["self"]]],[11,"from","","",86,[[],["self"]]],[11,"from","","",86,[[["i8x8"]],["self"]]],[11,"from","","",86,[[["u8x8"]],["self"]]],[11,"from","","",86,[[["i16x8"]],["self"]]],[11,"from","","",86,[[["u16x8"]],["self"]]],[11,"from","","",86,[[["i32x8"]],["self"]]],[11,"from","","",86,[[["u32x8"]],["self"]]],[11,"from","","",86,[[["f32x8"]],["self"]]],[11,"from","","",87,[[],["self"]]],[11,"from","","",87,[[["m8x8"]],["self"]]],[11,"from","","",87,[[["m16x8"]],["self"]]],[11,"from","","",87,[[["m32x8"]],["self"]]],[11,"from","","",88,[[],["self"]]],[11,"from","","",88,[[["i8x4"]],["self"]]],[11,"from","","",88,[[["u8x4"]],["self"]]],[11,"from","","",88,[[["i16x4"]],["self"]]],[11,"from","","",88,[[["u16x4"]],["self"]]],[11,"from","","",88,[[["i32x4"]],["self"]]],[11,"from","","",88,[[["u32x4"]],["self"]]],[11,"from","","",88,[[["i64x4"]],["self"]]],[11,"from","","",88,[[["u64x4"]],["self"]]],[11,"from","","",89,[[],["self"]]],[11,"from","","",89,[[["u8x4"]],["self"]]],[11,"from","","",89,[[["u16x4"]],["self"]]],[11,"from","","",89,[[["u32x4"]],["self"]]],[11,"from","","",89,[[["u64x4"]],["self"]]],[11,"from","","",90,[[],["self"]]],[11,"from","","",90,[[["m8x4"]],["self"]]],[11,"from","","",90,[[["m16x4"]],["self"]]],[11,"from","","",90,[[["m32x4"]],["self"]]],[11,"from","","",90,[[["m64x4"]],["self"]]],[11,"from","","",48,[[],["self"]]],[11,"from","","",49,[[],["self"]]],[11,"from","","",50,[[],["self"]]],[11,"from","","",71,[[],["self"]]],[11,"from","","",72,[[],["self"]]],[11,"from","","",73,[[],["self"]]],[11,"from","","",91,[[],["self"]]],[11,"from","","",92,[[],["self"]]],[11,"from","","",93,[[],["self"]]],[11,"from","","",94,[[],["self"]]],[11,"from","","",95,[[],["self"]]],[11,"from","","",96,[[],["self"]]],[11,"from","","",97,[[],["self"]]],[11,"from","","",98,[[],["self"]]],[11,"from","","",99,[[],["self"]]],[11,"fmt","","",14,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",0,[[["self"],["formatter"]],[["result",["error"]],["error"]]]],[11,"fmt","","",1,[[["self"],["formatter"]],[["result",["error"]],["error"]]]],[11,"fmt","","",2,[[["self"],["formatter"]],[["result",["error"]],["error"]]]],[11,"fmt","","",3,[[["self"],["formatter"]],[["result",["error"]],["error"]]]],[11,"fmt","","",4,[[["self"],["formatter"]],[["result",["error"]],["error"]]]],[11,"fmt","","",5,[[["self"],["formatter"]],[["result",["error"]],["error"]]]],[11,"fmt","","",15,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",16,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",17,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",18,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",19,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",20,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",21,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",22,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",23,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",24,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",25,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",26,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",27,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",28,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",29,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",30,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",31,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",33,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",32,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",34,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",35,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",36,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",37,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",38,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",39,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",40,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",41,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",42,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",43,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",44,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",45,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",46,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",47,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",51,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",52,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",53,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",54,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",55,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",56,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",57,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",58,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",59,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",60,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",61,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",62,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",63,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",64,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",65,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",66,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",67,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",68,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",69,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",70,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",74,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",75,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",76,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",77,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",78,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",79,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",80,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",81,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",82,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",83,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",84,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",85,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",86,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",87,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",88,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",89,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",90,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",48,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",49,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",50,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",71,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",72,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",73,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",91,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",92,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",93,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",94,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",95,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",96,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",97,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",98,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",99,[[["self"],["formatter"]],["result"]]],[11,"div","","",15,[[],["self"]]],[11,"div","","",15,[[["i8"]],["self"]]],[11,"div","","",16,[[],["self"]]],[11,"div","","",16,[[["u8"]],["self"]]],[11,"div","","",18,[[],["self"]]],[11,"div","","",18,[[["i8"]],["self"]]],[11,"div","","",19,[[],["self"]]],[11,"div","","",19,[[["u8"]],["self"]]],[11,"div","","",21,[[],["self"]]],[11,"div","","",21,[[["i16"]],["self"]]],[11,"div","","",22,[[],["self"]]],[11,"div","","",22,[[["u16"]],["self"]]],[11,"div","","",24,[[],["self"]]],[11,"div","","",24,[[["i8"]],["self"]]],[11,"div","","",25,[[],["self"]]],[11,"div","","",25,[[["u8"]],["self"]]],[11,"div","","",27,[[],["self"]]],[11,"div","","",27,[[["i16"]],["self"]]],[11,"div","","",28,[[],["self"]]],[11,"div","","",28,[[["u16"]],["self"]]],[11,"div","","",30,[[],["self"]]],[11,"div","","",30,[[["i32"]],["self"]]],[11,"div","","",31,[[],["self"]]],[11,"div","","",31,[[["u32"]],["self"]]],[11,"div","","",32,[[],["self"]]],[11,"div","","",32,[[["f32"]],["self"]]],[11,"div","","",34,[[],["self"]]],[11,"div","","",34,[[["i8"]],["self"]]],[11,"div","","",35,[[],["self"]]],[11,"div","","",35,[[["u8"]],["self"]]],[11,"div","","",37,[[],["self"]]],[11,"div","","",37,[[["i16"]],["self"]]],[11,"div","","",38,[[],["self"]]],[11,"div","","",38,[[["u16"]],["self"]]],[11,"div","","",40,[[],["self"]]],[11,"div","","",40,[[["i32"]],["self"]]],[11,"div","","",41,[[],["self"]]],[11,"div","","",41,[[["u32"]],["self"]]],[11,"div","","",42,[[],["self"]]],[11,"div","","",42,[[["f32"]],["self"]]],[11,"div","","",44,[[],["self"]]],[11,"div","","",44,[[["i64"]],["self"]]],[11,"div","","",45,[[],["self"]]],[11,"div","","",45,[[["u64"]],["self"]]],[11,"div","","",46,[[],["self"]]],[11,"div","","",46,[[["f64"]],["self"]]],[11,"div","","",51,[[],["self"]]],[11,"div","","",51,[[["i128"]],["self"]]],[11,"div","","",52,[[],["self"]]],[11,"div","","",52,[[["u128"]],["self"]]],[11,"div","","",54,[[],["self"]]],[11,"div","","",54,[[["i8"]],["self"]]],[11,"div","","",55,[[],["self"]]],[11,"div","","",55,[[["u8"]],["self"]]],[11,"div","","",57,[[],["self"]]],[11,"div","","",57,[[["i16"]],["self"]]],[11,"div","","",58,[[],["self"]]],[11,"div","","",58,[[["u16"]],["self"]]],[11,"div","","",60,[[],["self"]]],[11,"div","","",60,[[["i32"]],["self"]]],[11,"div","","",61,[[],["self"]]],[11,"div","","",61,[[["u32"]],["self"]]],[11,"div","","",62,[[],["self"]]],[11,"div","","",62,[[["f32"]],["self"]]],[11,"div","","",64,[[],["self"]]],[11,"div","","",64,[[["i64"]],["self"]]],[11,"div","","",65,[[],["self"]]],[11,"div","","",65,[[["u64"]],["self"]]],[11,"div","","",66,[[],["self"]]],[11,"div","","",66,[[["f64"]],["self"]]],[11,"div","","",68,[[],["self"]]],[11,"div","","",68,[[["i128"]],["self"]]],[11,"div","","",69,[[],["self"]]],[11,"div","","",69,[[["u128"]],["self"]]],[11,"div","","",74,[[],["self"]]],[11,"div","","",74,[[["i8"]],["self"]]],[11,"div","","",75,[[],["self"]]],[11,"div","","",75,[[["u8"]],["self"]]],[11,"div","","",77,[[],["self"]]],[11,"div","","",77,[[["i16"]],["self"]]],[11,"div","","",78,[[],["self"]]],[11,"div","","",78,[[["u16"]],["self"]]],[11,"div","","",80,[[],["self"]]],[11,"div","","",80,[[["i32"]],["self"]]],[11,"div","","",81,[[],["self"]]],[11,"div","","",81,[[["u32"]],["self"]]],[11,"div","","",82,[[],["self"]]],[11,"div","","",82,[[["f32"]],["self"]]],[11,"div","","",84,[[],["self"]]],[11,"div","","",84,[[["i64"]],["self"]]],[11,"div","","",85,[[],["self"]]],[11,"div","","",85,[[["u64"]],["self"]]],[11,"div","","",86,[[],["self"]]],[11,"div","","",86,[[["f64"]],["self"]]],[11,"div","","",88,[[],["self"]]],[11,"div","","",88,[[["i128"]],["self"]]],[11,"div","","",89,[[],["self"]]],[11,"div","","",89,[[["u128"]],["self"]]],[11,"div","","",48,[[],["self"]]],[11,"div","","",48,[[["isize"]],["self"]]],[11,"div","","",49,[[],["self"]]],[11,"div","","",49,[[["usize"]],["self"]]],[11,"div","","",71,[[],["self"]]],[11,"div","","",71,[[["isize"]],["self"]]],[11,"div","","",72,[[],["self"]]],[11,"div","","",72,[[["usize"]],["self"]]],[11,"div","","",91,[[],["self"]]],[11,"div","","",91,[[["isize"]],["self"]]],[11,"div","","",92,[[],["self"]]],[11,"div","","",92,[[["usize"]],["self"]]],[11,"rem","","",15,[[],["self"]]],[11,"rem","","",15,[[["i8"]],["self"]]],[11,"rem","","",16,[[],["self"]]],[11,"rem","","",16,[[["u8"]],["self"]]],[11,"rem","","",18,[[],["self"]]],[11,"rem","","",18,[[["i8"]],["self"]]],[11,"rem","","",19,[[],["self"]]],[11,"rem","","",19,[[["u8"]],["self"]]],[11,"rem","","",21,[[],["self"]]],[11,"rem","","",21,[[["i16"]],["self"]]],[11,"rem","","",22,[[],["self"]]],[11,"rem","","",22,[[["u16"]],["self"]]],[11,"rem","","",24,[[],["self"]]],[11,"rem","","",24,[[["i8"]],["self"]]],[11,"rem","","",25,[[],["self"]]],[11,"rem","","",25,[[["u8"]],["self"]]],[11,"rem","","",27,[[],["self"]]],[11,"rem","","",27,[[["i16"]],["self"]]],[11,"rem","","",28,[[],["self"]]],[11,"rem","","",28,[[["u16"]],["self"]]],[11,"rem","","",30,[[],["self"]]],[11,"rem","","",30,[[["i32"]],["self"]]],[11,"rem","","",31,[[],["self"]]],[11,"rem","","",31,[[["u32"]],["self"]]],[11,"rem","","",32,[[],["self"]]],[11,"rem","","",32,[[["f32"]],["self"]]],[11,"rem","","",34,[[],["self"]]],[11,"rem","","",34,[[["i8"]],["self"]]],[11,"rem","","",35,[[],["self"]]],[11,"rem","","",35,[[["u8"]],["self"]]],[11,"rem","","",37,[[],["self"]]],[11,"rem","","",37,[[["i16"]],["self"]]],[11,"rem","","",38,[[],["self"]]],[11,"rem","","",38,[[["u16"]],["self"]]],[11,"rem","","",40,[[],["self"]]],[11,"rem","","",40,[[["i32"]],["self"]]],[11,"rem","","",41,[[],["self"]]],[11,"rem","","",41,[[["u32"]],["self"]]],[11,"rem","","",42,[[],["self"]]],[11,"rem","","",42,[[["f32"]],["self"]]],[11,"rem","","",44,[[],["self"]]],[11,"rem","","",44,[[["i64"]],["self"]]],[11,"rem","","",45,[[],["self"]]],[11,"rem","","",45,[[["u64"]],["self"]]],[11,"rem","","",46,[[],["self"]]],[11,"rem","","",46,[[["f64"]],["self"]]],[11,"rem","","",51,[[],["self"]]],[11,"rem","","",51,[[["i128"]],["self"]]],[11,"rem","","",52,[[],["self"]]],[11,"rem","","",52,[[["u128"]],["self"]]],[11,"rem","","",54,[[],["self"]]],[11,"rem","","",54,[[["i8"]],["self"]]],[11,"rem","","",55,[[],["self"]]],[11,"rem","","",55,[[["u8"]],["self"]]],[11,"rem","","",57,[[],["self"]]],[11,"rem","","",57,[[["i16"]],["self"]]],[11,"rem","","",58,[[],["self"]]],[11,"rem","","",58,[[["u16"]],["self"]]],[11,"rem","","",60,[[],["self"]]],[11,"rem","","",60,[[["i32"]],["self"]]],[11,"rem","","",61,[[],["self"]]],[11,"rem","","",61,[[["u32"]],["self"]]],[11,"rem","","",62,[[],["self"]]],[11,"rem","","",62,[[["f32"]],["self"]]],[11,"rem","","",64,[[],["self"]]],[11,"rem","","",64,[[["i64"]],["self"]]],[11,"rem","","",65,[[],["self"]]],[11,"rem","","",65,[[["u64"]],["self"]]],[11,"rem","","",66,[[],["self"]]],[11,"rem","","",66,[[["f64"]],["self"]]],[11,"rem","","",68,[[],["self"]]],[11,"rem","","",68,[[["i128"]],["self"]]],[11,"rem","","",69,[[],["self"]]],[11,"rem","","",69,[[["u128"]],["self"]]],[11,"rem","","",74,[[],["self"]]],[11,"rem","","",74,[[["i8"]],["self"]]],[11,"rem","","",75,[[],["self"]]],[11,"rem","","",75,[[["u8"]],["self"]]],[11,"rem","","",77,[[],["self"]]],[11,"rem","","",77,[[["i16"]],["self"]]],[11,"rem","","",78,[[],["self"]]],[11,"rem","","",78,[[["u16"]],["self"]]],[11,"rem","","",80,[[],["self"]]],[11,"rem","","",80,[[["i32"]],["self"]]],[11,"rem","","",81,[[],["self"]]],[11,"rem","","",81,[[["u32"]],["self"]]],[11,"rem","","",82,[[],["self"]]],[11,"rem","","",82,[[["f32"]],["self"]]],[11,"rem","","",84,[[],["self"]]],[11,"rem","","",84,[[["i64"]],["self"]]],[11,"rem","","",85,[[],["self"]]],[11,"rem","","",85,[[["u64"]],["self"]]],[11,"rem","","",86,[[],["self"]]],[11,"rem","","",86,[[["f64"]],["self"]]],[11,"rem","","",88,[[],["self"]]],[11,"rem","","",88,[[["i128"]],["self"]]],[11,"rem","","",89,[[],["self"]]],[11,"rem","","",89,[[["u128"]],["self"]]],[11,"rem","","",48,[[],["self"]]],[11,"rem","","",48,[[["isize"]],["self"]]],[11,"rem","","",49,[[],["self"]]],[11,"rem","","",49,[[["usize"]],["self"]]],[11,"rem","","",71,[[],["self"]]],[11,"rem","","",71,[[["isize"]],["self"]]],[11,"rem","","",72,[[],["self"]]],[11,"rem","","",72,[[["usize"]],["self"]]],[11,"rem","","",91,[[],["self"]]],[11,"rem","","",91,[[["isize"]],["self"]]],[11,"rem","","",92,[[],["self"]]],[11,"rem","","",92,[[["usize"]],["self"]]],[11,"sub","","",15,[[],["self"]]],[11,"sub","","",15,[[["i8"]],["self"]]],[11,"sub","","",16,[[],["self"]]],[11,"sub","","",16,[[["u8"]],["self"]]],[11,"sub","","",18,[[],["self"]]],[11,"sub","","",18,[[["i8"]],["self"]]],[11,"sub","","",19,[[],["self"]]],[11,"sub","","",19,[[["u8"]],["self"]]],[11,"sub","","",21,[[],["self"]]],[11,"sub","","",21,[[["i16"]],["self"]]],[11,"sub","","",22,[[],["self"]]],[11,"sub","","",22,[[["u16"]],["self"]]],[11,"sub","","",24,[[],["self"]]],[11,"sub","","",24,[[["i8"]],["self"]]],[11,"sub","","",25,[[],["self"]]],[11,"sub","","",25,[[["u8"]],["self"]]],[11,"sub","","",27,[[],["self"]]],[11,"sub","","",27,[[["i16"]],["self"]]],[11,"sub","","",28,[[],["self"]]],[11,"sub","","",28,[[["u16"]],["self"]]],[11,"sub","","",30,[[],["self"]]],[11,"sub","","",30,[[["i32"]],["self"]]],[11,"sub","","",31,[[],["self"]]],[11,"sub","","",31,[[["u32"]],["self"]]],[11,"sub","","",32,[[],["self"]]],[11,"sub","","",32,[[["f32"]],["self"]]],[11,"sub","","",34,[[],["self"]]],[11,"sub","","",34,[[["i8"]],["self"]]],[11,"sub","","",35,[[],["self"]]],[11,"sub","","",35,[[["u8"]],["self"]]],[11,"sub","","",37,[[],["self"]]],[11,"sub","","",37,[[["i16"]],["self"]]],[11,"sub","","",38,[[],["self"]]],[11,"sub","","",38,[[["u16"]],["self"]]],[11,"sub","","",40,[[],["self"]]],[11,"sub","","",40,[[["i32"]],["self"]]],[11,"sub","","",41,[[],["self"]]],[11,"sub","","",41,[[["u32"]],["self"]]],[11,"sub","","",42,[[],["self"]]],[11,"sub","","",42,[[["f32"]],["self"]]],[11,"sub","","",44,[[],["self"]]],[11,"sub","","",44,[[["i64"]],["self"]]],[11,"sub","","",45,[[],["self"]]],[11,"sub","","",45,[[["u64"]],["self"]]],[11,"sub","","",46,[[],["self"]]],[11,"sub","","",46,[[["f64"]],["self"]]],[11,"sub","","",51,[[],["self"]]],[11,"sub","","",51,[[["i128"]],["self"]]],[11,"sub","","",52,[[],["self"]]],[11,"sub","","",52,[[["u128"]],["self"]]],[11,"sub","","",54,[[],["self"]]],[11,"sub","","",54,[[["i8"]],["self"]]],[11,"sub","","",55,[[],["self"]]],[11,"sub","","",55,[[["u8"]],["self"]]],[11,"sub","","",57,[[],["self"]]],[11,"sub","","",57,[[["i16"]],["self"]]],[11,"sub","","",58,[[],["self"]]],[11,"sub","","",58,[[["u16"]],["self"]]],[11,"sub","","",60,[[],["self"]]],[11,"sub","","",60,[[["i32"]],["self"]]],[11,"sub","","",61,[[],["self"]]],[11,"sub","","",61,[[["u32"]],["self"]]],[11,"sub","","",62,[[],["self"]]],[11,"sub","","",62,[[["f32"]],["self"]]],[11,"sub","","",64,[[],["self"]]],[11,"sub","","",64,[[["i64"]],["self"]]],[11,"sub","","",65,[[],["self"]]],[11,"sub","","",65,[[["u64"]],["self"]]],[11,"sub","","",66,[[],["self"]]],[11,"sub","","",66,[[["f64"]],["self"]]],[11,"sub","","",68,[[],["self"]]],[11,"sub","","",68,[[["i128"]],["self"]]],[11,"sub","","",69,[[],["self"]]],[11,"sub","","",69,[[["u128"]],["self"]]],[11,"sub","","",74,[[],["self"]]],[11,"sub","","",74,[[["i8"]],["self"]]],[11,"sub","","",75,[[],["self"]]],[11,"sub","","",75,[[["u8"]],["self"]]],[11,"sub","","",77,[[],["self"]]],[11,"sub","","",77,[[["i16"]],["self"]]],[11,"sub","","",78,[[],["self"]]],[11,"sub","","",78,[[["u16"]],["self"]]],[11,"sub","","",80,[[],["self"]]],[11,"sub","","",80,[[["i32"]],["self"]]],[11,"sub","","",81,[[],["self"]]],[11,"sub","","",81,[[["u32"]],["self"]]],[11,"sub","","",82,[[],["self"]]],[11,"sub","","",82,[[["f32"]],["self"]]],[11,"sub","","",84,[[],["self"]]],[11,"sub","","",84,[[["i64"]],["self"]]],[11,"sub","","",85,[[],["self"]]],[11,"sub","","",85,[[["u64"]],["self"]]],[11,"sub","","",86,[[],["self"]]],[11,"sub","","",86,[[["f64"]],["self"]]],[11,"sub","","",88,[[],["self"]]],[11,"sub","","",88,[[["i128"]],["self"]]],[11,"sub","","",89,[[],["self"]]],[11,"sub","","",89,[[["u128"]],["self"]]],[11,"sub","","",48,[[],["self"]]],[11,"sub","","",48,[[["isize"]],["self"]]],[11,"sub","","",49,[[],["self"]]],[11,"sub","","",49,[[["usize"]],["self"]]],[11,"sub","","",71,[[],["self"]]],[11,"sub","","",71,[[["isize"]],["self"]]],[11,"sub","","",72,[[],["self"]]],[11,"sub","","",72,[[["usize"]],["self"]]],[11,"sub","","",91,[[],["self"]]],[11,"sub","","",91,[[["isize"]],["self"]]],[11,"sub","","",92,[[],["self"]]],[11,"sub","","",92,[[["usize"]],["self"]]],[11,"eq","","",0,[[["self"]],["bool"]]],[11,"ne","","",0,[[["self"]],["bool"]]],[11,"eq","","",1,[[["self"]],["bool"]]],[11,"ne","","",1,[[["self"]],["bool"]]],[11,"eq","","",2,[[["self"]],["bool"]]],[11,"ne","","",2,[[["self"]],["bool"]]],[11,"eq","","",3,[[["self"]],["bool"]]],[11,"ne","","",3,[[["self"]],["bool"]]],[11,"eq","","",4,[[["self"]],["bool"]]],[11,"ne","","",4,[[["self"]],["bool"]]],[11,"eq","","",5,[[["self"]],["bool"]]],[11,"ne","","",5,[[["self"]],["bool"]]],[11,"eq","","",15,[[["self"]],["bool"]]],[11,"ne","","",15,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",16,[[["self"]],["bool"]]],[11,"ne","","",16,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",17,[[["self"]],["bool"]]],[11,"ne","","",17,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",18,[[["self"]],["bool"]]],[11,"ne","","",18,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",19,[[["self"]],["bool"]]],[11,"ne","","",19,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",20,[[["self"]],["bool"]]],[11,"ne","","",20,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",21,[[["self"]],["bool"]]],[11,"ne","","",21,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",22,[[["self"]],["bool"]]],[11,"ne","","",22,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",23,[[["self"]],["bool"]]],[11,"ne","","",23,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",24,[[["self"]],["bool"]]],[11,"ne","","",24,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",25,[[["self"]],["bool"]]],[11,"ne","","",25,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",26,[[["self"]],["bool"]]],[11,"ne","","",26,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",27,[[["self"]],["bool"]]],[11,"ne","","",27,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",28,[[["self"]],["bool"]]],[11,"ne","","",28,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",29,[[["self"]],["bool"]]],[11,"ne","","",29,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",30,[[["self"]],["bool"]]],[11,"ne","","",30,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",31,[[["self"]],["bool"]]],[11,"ne","","",31,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",33,[[["self"]],["bool"]]],[11,"ne","","",33,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",32,[[["self"]],["bool"]]],[11,"ne","","",32,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",34,[[["self"]],["bool"]]],[11,"ne","","",34,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",35,[[["self"]],["bool"]]],[11,"ne","","",35,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",36,[[["self"]],["bool"]]],[11,"ne","","",36,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",37,[[["self"]],["bool"]]],[11,"ne","","",37,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",38,[[["self"]],["bool"]]],[11,"ne","","",38,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",39,[[["self"]],["bool"]]],[11,"ne","","",39,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",40,[[["self"]],["bool"]]],[11,"ne","","",40,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",41,[[["self"]],["bool"]]],[11,"ne","","",41,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",42,[[["self"]],["bool"]]],[11,"ne","","",42,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",43,[[["self"]],["bool"]]],[11,"ne","","",43,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",44,[[["self"]],["bool"]]],[11,"ne","","",44,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",45,[[["self"]],["bool"]]],[11,"ne","","",45,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",46,[[["self"]],["bool"]]],[11,"ne","","",46,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",47,[[["self"]],["bool"]]],[11,"ne","","",47,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",51,[[["self"]],["bool"]]],[11,"ne","","",51,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",52,[[["self"]],["bool"]]],[11,"ne","","",52,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",53,[[["self"]],["bool"]]],[11,"ne","","",53,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",54,[[["self"]],["bool"]]],[11,"ne","","",54,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",55,[[["self"]],["bool"]]],[11,"ne","","",55,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",56,[[["self"]],["bool"]]],[11,"ne","","",56,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",57,[[["self"]],["bool"]]],[11,"ne","","",57,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",58,[[["self"]],["bool"]]],[11,"ne","","",58,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",59,[[["self"]],["bool"]]],[11,"ne","","",59,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",60,[[["self"]],["bool"]]],[11,"ne","","",60,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",61,[[["self"]],["bool"]]],[11,"ne","","",61,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",62,[[["self"]],["bool"]]],[11,"ne","","",62,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",63,[[["self"]],["bool"]]],[11,"ne","","",63,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",64,[[["self"]],["bool"]]],[11,"ne","","",64,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",65,[[["self"]],["bool"]]],[11,"ne","","",65,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",66,[[["self"]],["bool"]]],[11,"ne","","",66,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",67,[[["self"]],["bool"]]],[11,"ne","","",67,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",68,[[["self"]],["bool"]]],[11,"ne","","",68,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",69,[[["self"]],["bool"]]],[11,"ne","","",69,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",70,[[["self"]],["bool"]]],[11,"ne","","",70,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",74,[[["self"]],["bool"]]],[11,"ne","","",74,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",75,[[["self"]],["bool"]]],[11,"ne","","",75,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",76,[[["self"]],["bool"]]],[11,"ne","","",76,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",77,[[["self"]],["bool"]]],[11,"ne","","",77,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",78,[[["self"]],["bool"]]],[11,"ne","","",78,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",79,[[["self"]],["bool"]]],[11,"ne","","",79,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",80,[[["self"]],["bool"]]],[11,"ne","","",80,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",81,[[["self"]],["bool"]]],[11,"ne","","",81,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",82,[[["self"]],["bool"]]],[11,"ne","","",82,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",83,[[["self"]],["bool"]]],[11,"ne","","",83,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",84,[[["self"]],["bool"]]],[11,"ne","","",84,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",85,[[["self"]],["bool"]]],[11,"ne","","",85,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",86,[[["self"]],["bool"]]],[11,"ne","","",86,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",87,[[["self"]],["bool"]]],[11,"ne","","",87,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",88,[[["self"]],["bool"]]],[11,"ne","","",88,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",89,[[["self"]],["bool"]]],[11,"ne","","",89,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",90,[[["self"]],["bool"]]],[11,"ne","","",90,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",48,[[["self"]],["bool"]]],[11,"ne","","",48,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",49,[[["self"]],["bool"]]],[11,"ne","","",49,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",50,[[["self"]],["bool"]]],[11,"ne","","",50,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",71,[[["self"]],["bool"]]],[11,"ne","","",71,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",72,[[["self"]],["bool"]]],[11,"ne","","",72,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",73,[[["self"]],["bool"]]],[11,"ne","","",73,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",91,[[["self"]],["bool"]]],[11,"ne","","",91,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",92,[[["self"]],["bool"]]],[11,"ne","","",92,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",93,[[["self"]],["bool"]]],[11,"ne","","",93,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",94,[[["self"]],["bool"]]],[11,"ne","","",94,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",95,[[["self"]],["bool"]]],[11,"ne","","",95,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",96,[[["self"]],["bool"]]],[11,"ne","","",96,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",97,[[["self"]],["bool"]]],[11,"ne","","",97,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",98,[[["self"]],["bool"]]],[11,"ne","","",98,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"eq","","",99,[[["self"]],["bool"]]],[11,"ne","","",99,[[["self"]],["bool"]]],[11,"eq","","",14,[[["self"]],["bool"]]],[11,"ne","","",14,[[["self"]],["bool"]]],[11,"cmp","","",0,[[["self"]],["ordering"]]],[11,"cmp","","",1,[[["self"]],["ordering"]]],[11,"cmp","","",2,[[["self"]],["ordering"]]],[11,"cmp","","",3,[[["self"]],["ordering"]]],[11,"cmp","","",4,[[["self"]],["ordering"]]],[11,"cmp","","",5,[[["self"]],["ordering"]]],[11,"cmp","","",14,[[["self"]],["ordering"]]],[11,"cmp","","",14,[[["self"]],["ordering"]]],[11,"cmp","","",14,[[["self"]],["ordering"]]],[11,"cmp","","",14,[[["self"]],["ordering"]]],[11,"cmp","","",14,[[["self"]],["ordering"]]],[11,"cmp","","",14,[[["self"]],["ordering"]]],[11,"cmp","","",14,[[["self"]],["ordering"]]],[11,"cmp","","",14,[[["self"]],["ordering"]]],[11,"cmp","","",14,[[["self"]],["ordering"]]],[11,"cmp","","",14,[[["self"]],["ordering"]]],[11,"cmp","","",14,[[["self"]],["ordering"]]],[11,"cmp","","",14,[[["self"]],["ordering"]]],[11,"cmp","","",14,[[["self"]],["ordering"]]],[11,"cmp","","",14,[[["self"]],["ordering"]]],[11,"cmp","","",14,[[["self"]],["ordering"]]],[11,"cmp","","",14,[[["self"]],["ordering"]]],[11,"cmp","","",14,[[["self"]],["ordering"]]],[11,"cmp","","",14,[[["self"]],["ordering"]]],[11,"cmp","","",14,[[["self"]],["ordering"]]],[11,"cmp","","",14,[[["self"]],["ordering"]]],[11,"cmp","","",14,[[["self"]],["ordering"]]],[11,"cmp","","",14,[[["self"]],["ordering"]]],[11,"cmp","","",14,[[["self"]],["ordering"]]],[11,"cmp","","",14,[[["self"]],["ordering"]]],[11,"cmp","","",14,[[["self"]],["ordering"]]],[11,"cmp","","",14,[[["self"]],["ordering"]]],[11,"cmp","","",14,[[["self"]],["ordering"]]],[11,"cmp","","",14,[[["self"]],["ordering"]]],[11,"cmp","","",14,[[["self"]],["ordering"]]],[11,"cmp","","",14,[[["self"]],["ordering"]]],[11,"cmp","","",14,[[["self"]],["ordering"]]],[11,"cmp","","",14,[[["self"]],["ordering"]]],[11,"cmp","","",14,[[["self"]],["ordering"]]],[11,"cmp","","",14,[[["self"]],["ordering"]]],[11,"cmp","","",14,[[["self"]],["ordering"]]],[11,"cmp","","",14,[[["self"]],["ordering"]]],[11,"cmp","","",14,[[["self"]],["ordering"]]],[11,"cmp","","",14,[[["self"]],["ordering"]]],[11,"cmp","","",14,[[["self"]],["ordering"]]],[11,"cmp","","",14,[[["self"]],["ordering"]]],[11,"cmp","","",14,[[["self"]],["ordering"]]],[11,"cmp","","",14,[[["self"]],["ordering"]]],[11,"cmp","","",14,[[["self"]],["ordering"]]],[11,"cmp","","",14,[[["self"]],["ordering"]]],[11,"cmp","","",14,[[["self"]],["ordering"]]],[11,"cmp","","",14,[[["self"]],["ordering"]]],[11,"cmp","","",14,[[["self"]],["ordering"]]],[11,"cmp","","",14,[[["self"]],["ordering"]]],[11,"cmp","","",14,[[["self"]],["ordering"]]],[11,"cmp","","",14,[[["self"]],["ordering"]]],[11,"cmp","","",14,[[["self"]],["ordering"]]],[11,"cmp","","",14,[[["self"]],["ordering"]]],[11,"cmp","","",14,[[["self"]],["ordering"]]],[11,"cmp","","",14,[[["self"]],["ordering"]]],[11,"cmp","","",14,[[["self"]],["ordering"]]],[11,"cmp","","",14,[[["self"]],["ordering"]]],[11,"cmp","","",14,[[["self"]],["ordering"]]],[11,"cmp","","",14,[[["self"]],["ordering"]]],[11,"cmp","","",14,[[["self"]],["ordering"]]],[11,"cmp","","",14,[[["self"]],["ordering"]]],[11,"cmp","","",14,[[["self"]],["ordering"]]],[11,"cmp","","",14,[[["self"]],["ordering"]]],[11,"cmp","","",14,[[["self"]],["ordering"]]],[11,"cmp","","",14,[[["self"]],["ordering"]]],[11,"cmp","","",14,[[["self"]],["ordering"]]],[11,"cmp","","",14,[[["self"]],["ordering"]]],[11,"cmp","","",14,[[["self"]],["ordering"]]],[11,"cmp","","",14,[[["self"]],["ordering"]]],[11,"cmp","","",14,[[["self"]],["ordering"]]],[11,"cmp","","",14,[[["self"]],["ordering"]]],[11,"cmp","","",14,[[["self"]],["ordering"]]],[11,"cmp","","",14,[[["self"]],["ordering"]]],[11,"partial_cmp","","",0,[[["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",0,[[["self"]],["bool"]]],[11,"gt","","",0,[[["self"]],["bool"]]],[11,"le","","",0,[[["self"]],["bool"]]],[11,"ge","","",0,[[["self"]],["bool"]]],[11,"partial_cmp","","",1,[[["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",1,[[["self"]],["bool"]]],[11,"gt","","",1,[[["self"]],["bool"]]],[11,"le","","",1,[[["self"]],["bool"]]],[11,"ge","","",1,[[["self"]],["bool"]]],[11,"partial_cmp","","",2,[[["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",2,[[["self"]],["bool"]]],[11,"gt","","",2,[[["self"]],["bool"]]],[11,"le","","",2,[[["self"]],["bool"]]],[11,"ge","","",2,[[["self"]],["bool"]]],[11,"partial_cmp","","",3,[[["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",3,[[["self"]],["bool"]]],[11,"gt","","",3,[[["self"]],["bool"]]],[11,"le","","",3,[[["self"]],["bool"]]],[11,"ge","","",3,[[["self"]],["bool"]]],[11,"partial_cmp","","",4,[[["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",4,[[["self"]],["bool"]]],[11,"gt","","",4,[[["self"]],["bool"]]],[11,"le","","",4,[[["self"]],["bool"]]],[11,"ge","","",4,[[["self"]],["bool"]]],[11,"partial_cmp","","",5,[[["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",5,[[["self"]],["bool"]]],[11,"gt","","",5,[[["self"]],["bool"]]],[11,"le","","",5,[[["self"]],["bool"]]],[11,"ge","","",5,[[["self"]],["bool"]]],[11,"partial_cmp","","",14,[[["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",14,[[["self"]],["bool"]]],[11,"le","","",14,[[["self"]],["bool"]]],[11,"ge","","",14,[[["self"]],["bool"]]],[11,"gt","","",14,[[["self"]],["bool"]]],[11,"partial_cmp","","",14,[[["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",14,[[["self"]],["bool"]]],[11,"le","","",14,[[["self"]],["bool"]]],[11,"ge","","",14,[[["self"]],["bool"]]],[11,"gt","","",14,[[["self"]],["bool"]]],[11,"partial_cmp","","",14,[[["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",14,[[["self"]],["bool"]]],[11,"le","","",14,[[["self"]],["bool"]]],[11,"ge","","",14,[[["self"]],["bool"]]],[11,"gt","","",14,[[["self"]],["bool"]]],[11,"partial_cmp","","",14,[[["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",14,[[["self"]],["bool"]]],[11,"le","","",14,[[["self"]],["bool"]]],[11,"ge","","",14,[[["self"]],["bool"]]],[11,"gt","","",14,[[["self"]],["bool"]]],[11,"partial_cmp","","",14,[[["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",14,[[["self"]],["bool"]]],[11,"le","","",14,[[["self"]],["bool"]]],[11,"ge","","",14,[[["self"]],["bool"]]],[11,"gt","","",14,[[["self"]],["bool"]]],[11,"partial_cmp","","",14,[[["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",14,[[["self"]],["bool"]]],[11,"le","","",14,[[["self"]],["bool"]]],[11,"ge","","",14,[[["self"]],["bool"]]],[11,"gt","","",14,[[["self"]],["bool"]]],[11,"partial_cmp","","",14,[[["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",14,[[["self"]],["bool"]]],[11,"le","","",14,[[["self"]],["bool"]]],[11,"ge","","",14,[[["self"]],["bool"]]],[11,"gt","","",14,[[["self"]],["bool"]]],[11,"partial_cmp","","",14,[[["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",14,[[["self"]],["bool"]]],[11,"le","","",14,[[["self"]],["bool"]]],[11,"ge","","",14,[[["self"]],["bool"]]],[11,"gt","","",14,[[["self"]],["bool"]]],[11,"partial_cmp","","",14,[[["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",14,[[["self"]],["bool"]]],[11,"le","","",14,[[["self"]],["bool"]]],[11,"ge","","",14,[[["self"]],["bool"]]],[11,"gt","","",14,[[["self"]],["bool"]]],[11,"partial_cmp","","",14,[[["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",14,[[["self"]],["bool"]]],[11,"le","","",14,[[["self"]],["bool"]]],[11,"ge","","",14,[[["self"]],["bool"]]],[11,"gt","","",14,[[["self"]],["bool"]]],[11,"partial_cmp","","",14,[[["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",14,[[["self"]],["bool"]]],[11,"le","","",14,[[["self"]],["bool"]]],[11,"ge","","",14,[[["self"]],["bool"]]],[11,"gt","","",14,[[["self"]],["bool"]]],[11,"partial_cmp","","",14,[[["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",14,[[["self"]],["bool"]]],[11,"le","","",14,[[["self"]],["bool"]]],[11,"ge","","",14,[[["self"]],["bool"]]],[11,"gt","","",14,[[["self"]],["bool"]]],[11,"partial_cmp","","",14,[[["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",14,[[["self"]],["bool"]]],[11,"le","","",14,[[["self"]],["bool"]]],[11,"ge","","",14,[[["self"]],["bool"]]],[11,"gt","","",14,[[["self"]],["bool"]]],[11,"partial_cmp","","",14,[[["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",14,[[["self"]],["bool"]]],[11,"le","","",14,[[["self"]],["bool"]]],[11,"ge","","",14,[[["self"]],["bool"]]],[11,"gt","","",14,[[["self"]],["bool"]]],[11,"partial_cmp","","",14,[[["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",14,[[["self"]],["bool"]]],[11,"le","","",14,[[["self"]],["bool"]]],[11,"ge","","",14,[[["self"]],["bool"]]],[11,"gt","","",14,[[["self"]],["bool"]]],[11,"partial_cmp","","",14,[[["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",14,[[["self"]],["bool"]]],[11,"le","","",14,[[["self"]],["bool"]]],[11,"ge","","",14,[[["self"]],["bool"]]],[11,"gt","","",14,[[["self"]],["bool"]]],[11,"partial_cmp","","",14,[[["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",14,[[["self"]],["bool"]]],[11,"le","","",14,[[["self"]],["bool"]]],[11,"ge","","",14,[[["self"]],["bool"]]],[11,"gt","","",14,[[["self"]],["bool"]]],[11,"partial_cmp","","",14,[[["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",14,[[["self"]],["bool"]]],[11,"le","","",14,[[["self"]],["bool"]]],[11,"ge","","",14,[[["self"]],["bool"]]],[11,"gt","","",14,[[["self"]],["bool"]]],[11,"partial_cmp","","",14,[[["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",14,[[["self"]],["bool"]]],[11,"le","","",14,[[["self"]],["bool"]]],[11,"ge","","",14,[[["self"]],["bool"]]],[11,"gt","","",14,[[["self"]],["bool"]]],[11,"partial_cmp","","",14,[[["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",14,[[["self"]],["bool"]]],[11,"le","","",14,[[["self"]],["bool"]]],[11,"ge","","",14,[[["self"]],["bool"]]],[11,"gt","","",14,[[["self"]],["bool"]]],[11,"partial_cmp","","",14,[[["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",14,[[["self"]],["bool"]]],[11,"le","","",14,[[["self"]],["bool"]]],[11,"ge","","",14,[[["self"]],["bool"]]],[11,"gt","","",14,[[["self"]],["bool"]]],[11,"partial_cmp","","",14,[[["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",14,[[["self"]],["bool"]]],[11,"le","","",14,[[["self"]],["bool"]]],[11,"ge","","",14,[[["self"]],["bool"]]],[11,"gt","","",14,[[["self"]],["bool"]]],[11,"partial_cmp","","",14,[[["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",14,[[["self"]],["bool"]]],[11,"le","","",14,[[["self"]],["bool"]]],[11,"ge","","",14,[[["self"]],["bool"]]],[11,"gt","","",14,[[["self"]],["bool"]]],[11,"partial_cmp","","",14,[[["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",14,[[["self"]],["bool"]]],[11,"le","","",14,[[["self"]],["bool"]]],[11,"ge","","",14,[[["self"]],["bool"]]],[11,"gt","","",14,[[["self"]],["bool"]]],[11,"partial_cmp","","",14,[[["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",14,[[["self"]],["bool"]]],[11,"le","","",14,[[["self"]],["bool"]]],[11,"ge","","",14,[[["self"]],["bool"]]],[11,"gt","","",14,[[["self"]],["bool"]]],[11,"partial_cmp","","",14,[[["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",14,[[["self"]],["bool"]]],[11,"le","","",14,[[["self"]],["bool"]]],[11,"ge","","",14,[[["self"]],["bool"]]],[11,"gt","","",14,[[["self"]],["bool"]]],[11,"partial_cmp","","",14,[[["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",14,[[["self"]],["bool"]]],[11,"le","","",14,[[["self"]],["bool"]]],[11,"ge","","",14,[[["self"]],["bool"]]],[11,"gt","","",14,[[["self"]],["bool"]]],[11,"partial_cmp","","",14,[[["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",14,[[["self"]],["bool"]]],[11,"le","","",14,[[["self"]],["bool"]]],[11,"ge","","",14,[[["self"]],["bool"]]],[11,"gt","","",14,[[["self"]],["bool"]]],[11,"partial_cmp","","",14,[[["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",14,[[["self"]],["bool"]]],[11,"le","","",14,[[["self"]],["bool"]]],[11,"ge","","",14,[[["self"]],["bool"]]],[11,"gt","","",14,[[["self"]],["bool"]]],[11,"partial_cmp","","",14,[[["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",14,[[["self"]],["bool"]]],[11,"le","","",14,[[["self"]],["bool"]]],[11,"ge","","",14,[[["self"]],["bool"]]],[11,"gt","","",14,[[["self"]],["bool"]]],[11,"partial_cmp","","",14,[[["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",14,[[["self"]],["bool"]]],[11,"le","","",14,[[["self"]],["bool"]]],[11,"ge","","",14,[[["self"]],["bool"]]],[11,"gt","","",14,[[["self"]],["bool"]]],[11,"partial_cmp","","",14,[[["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",14,[[["self"]],["bool"]]],[11,"le","","",14,[[["self"]],["bool"]]],[11,"ge","","",14,[[["self"]],["bool"]]],[11,"gt","","",14,[[["self"]],["bool"]]],[11,"partial_cmp","","",14,[[["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",14,[[["self"]],["bool"]]],[11,"le","","",14,[[["self"]],["bool"]]],[11,"ge","","",14,[[["self"]],["bool"]]],[11,"gt","","",14,[[["self"]],["bool"]]],[11,"partial_cmp","","",14,[[["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",14,[[["self"]],["bool"]]],[11,"le","","",14,[[["self"]],["bool"]]],[11,"ge","","",14,[[["self"]],["bool"]]],[11,"gt","","",14,[[["self"]],["bool"]]],[11,"partial_cmp","","",14,[[["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",14,[[["self"]],["bool"]]],[11,"le","","",14,[[["self"]],["bool"]]],[11,"ge","","",14,[[["self"]],["bool"]]],[11,"gt","","",14,[[["self"]],["bool"]]],[11,"partial_cmp","","",14,[[["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",14,[[["self"]],["bool"]]],[11,"le","","",14,[[["self"]],["bool"]]],[11,"ge","","",14,[[["self"]],["bool"]]],[11,"gt","","",14,[[["self"]],["bool"]]],[11,"partial_cmp","","",14,[[["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",14,[[["self"]],["bool"]]],[11,"le","","",14,[[["self"]],["bool"]]],[11,"ge","","",14,[[["self"]],["bool"]]],[11,"gt","","",14,[[["self"]],["bool"]]],[11,"partial_cmp","","",14,[[["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",14,[[["self"]],["bool"]]],[11,"le","","",14,[[["self"]],["bool"]]],[11,"ge","","",14,[[["self"]],["bool"]]],[11,"gt","","",14,[[["self"]],["bool"]]],[11,"partial_cmp","","",14,[[["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",14,[[["self"]],["bool"]]],[11,"le","","",14,[[["self"]],["bool"]]],[11,"ge","","",14,[[["self"]],["bool"]]],[11,"gt","","",14,[[["self"]],["bool"]]],[11,"partial_cmp","","",14,[[["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",14,[[["self"]],["bool"]]],[11,"le","","",14,[[["self"]],["bool"]]],[11,"ge","","",14,[[["self"]],["bool"]]],[11,"gt","","",14,[[["self"]],["bool"]]],[11,"partial_cmp","","",14,[[["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",14,[[["self"]],["bool"]]],[11,"le","","",14,[[["self"]],["bool"]]],[11,"ge","","",14,[[["self"]],["bool"]]],[11,"gt","","",14,[[["self"]],["bool"]]],[11,"partial_cmp","","",14,[[["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",14,[[["self"]],["bool"]]],[11,"le","","",14,[[["self"]],["bool"]]],[11,"ge","","",14,[[["self"]],["bool"]]],[11,"gt","","",14,[[["self"]],["bool"]]],[11,"partial_cmp","","",14,[[["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",14,[[["self"]],["bool"]]],[11,"le","","",14,[[["self"]],["bool"]]],[11,"ge","","",14,[[["self"]],["bool"]]],[11,"gt","","",14,[[["self"]],["bool"]]],[11,"partial_cmp","","",14,[[["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",14,[[["self"]],["bool"]]],[11,"le","","",14,[[["self"]],["bool"]]],[11,"ge","","",14,[[["self"]],["bool"]]],[11,"gt","","",14,[[["self"]],["bool"]]],[11,"partial_cmp","","",14,[[["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",14,[[["self"]],["bool"]]],[11,"le","","",14,[[["self"]],["bool"]]],[11,"ge","","",14,[[["self"]],["bool"]]],[11,"gt","","",14,[[["self"]],["bool"]]],[11,"partial_cmp","","",14,[[["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",14,[[["self"]],["bool"]]],[11,"le","","",14,[[["self"]],["bool"]]],[11,"ge","","",14,[[["self"]],["bool"]]],[11,"gt","","",14,[[["self"]],["bool"]]],[11,"partial_cmp","","",14,[[["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",14,[[["self"]],["bool"]]],[11,"le","","",14,[[["self"]],["bool"]]],[11,"ge","","",14,[[["self"]],["bool"]]],[11,"gt","","",14,[[["self"]],["bool"]]],[11,"partial_cmp","","",14,[[["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",14,[[["self"]],["bool"]]],[11,"le","","",14,[[["self"]],["bool"]]],[11,"ge","","",14,[[["self"]],["bool"]]],[11,"gt","","",14,[[["self"]],["bool"]]],[11,"partial_cmp","","",14,[[["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",14,[[["self"]],["bool"]]],[11,"le","","",14,[[["self"]],["bool"]]],[11,"ge","","",14,[[["self"]],["bool"]]],[11,"gt","","",14,[[["self"]],["bool"]]],[11,"partial_cmp","","",14,[[["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",14,[[["self"]],["bool"]]],[11,"le","","",14,[[["self"]],["bool"]]],[11,"ge","","",14,[[["self"]],["bool"]]],[11,"gt","","",14,[[["self"]],["bool"]]],[11,"partial_cmp","","",14,[[["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",14,[[["self"]],["bool"]]],[11,"le","","",14,[[["self"]],["bool"]]],[11,"ge","","",14,[[["self"]],["bool"]]],[11,"gt","","",14,[[["self"]],["bool"]]],[11,"partial_cmp","","",14,[[["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",14,[[["self"]],["bool"]]],[11,"le","","",14,[[["self"]],["bool"]]],[11,"ge","","",14,[[["self"]],["bool"]]],[11,"gt","","",14,[[["self"]],["bool"]]],[11,"partial_cmp","","",14,[[["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",14,[[["self"]],["bool"]]],[11,"le","","",14,[[["self"]],["bool"]]],[11,"ge","","",14,[[["self"]],["bool"]]],[11,"gt","","",14,[[["self"]],["bool"]]],[11,"partial_cmp","","",14,[[["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",14,[[["self"]],["bool"]]],[11,"le","","",14,[[["self"]],["bool"]]],[11,"ge","","",14,[[["self"]],["bool"]]],[11,"gt","","",14,[[["self"]],["bool"]]],[11,"partial_cmp","","",14,[[["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",14,[[["self"]],["bool"]]],[11,"le","","",14,[[["self"]],["bool"]]],[11,"ge","","",14,[[["self"]],["bool"]]],[11,"gt","","",14,[[["self"]],["bool"]]],[11,"partial_cmp","","",14,[[["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",14,[[["self"]],["bool"]]],[11,"le","","",14,[[["self"]],["bool"]]],[11,"ge","","",14,[[["self"]],["bool"]]],[11,"gt","","",14,[[["self"]],["bool"]]],[11,"partial_cmp","","",14,[[["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",14,[[["self"]],["bool"]]],[11,"le","","",14,[[["self"]],["bool"]]],[11,"ge","","",14,[[["self"]],["bool"]]],[11,"gt","","",14,[[["self"]],["bool"]]],[11,"partial_cmp","","",14,[[["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",14,[[["self"]],["bool"]]],[11,"le","","",14,[[["self"]],["bool"]]],[11,"ge","","",14,[[["self"]],["bool"]]],[11,"gt","","",14,[[["self"]],["bool"]]],[11,"partial_cmp","","",14,[[["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",14,[[["self"]],["bool"]]],[11,"le","","",14,[[["self"]],["bool"]]],[11,"ge","","",14,[[["self"]],["bool"]]],[11,"gt","","",14,[[["self"]],["bool"]]],[11,"partial_cmp","","",14,[[["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",14,[[["self"]],["bool"]]],[11,"le","","",14,[[["self"]],["bool"]]],[11,"ge","","",14,[[["self"]],["bool"]]],[11,"gt","","",14,[[["self"]],["bool"]]],[11,"partial_cmp","","",14,[[["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",14,[[["self"]],["bool"]]],[11,"le","","",14,[[["self"]],["bool"]]],[11,"ge","","",14,[[["self"]],["bool"]]],[11,"gt","","",14,[[["self"]],["bool"]]],[11,"partial_cmp","","",14,[[["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",14,[[["self"]],["bool"]]],[11,"le","","",14,[[["self"]],["bool"]]],[11,"ge","","",14,[[["self"]],["bool"]]],[11,"gt","","",14,[[["self"]],["bool"]]],[11,"partial_cmp","","",14,[[["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",14,[[["self"]],["bool"]]],[11,"le","","",14,[[["self"]],["bool"]]],[11,"ge","","",14,[[["self"]],["bool"]]],[11,"gt","","",14,[[["self"]],["bool"]]],[11,"partial_cmp","","",14,[[["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",14,[[["self"]],["bool"]]],[11,"le","","",14,[[["self"]],["bool"]]],[11,"ge","","",14,[[["self"]],["bool"]]],[11,"gt","","",14,[[["self"]],["bool"]]],[11,"partial_cmp","","",14,[[["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",14,[[["self"]],["bool"]]],[11,"le","","",14,[[["self"]],["bool"]]],[11,"ge","","",14,[[["self"]],["bool"]]],[11,"gt","","",14,[[["self"]],["bool"]]],[11,"partial_cmp","","",14,[[["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",14,[[["self"]],["bool"]]],[11,"le","","",14,[[["self"]],["bool"]]],[11,"ge","","",14,[[["self"]],["bool"]]],[11,"gt","","",14,[[["self"]],["bool"]]],[11,"partial_cmp","","",14,[[["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",14,[[["self"]],["bool"]]],[11,"le","","",14,[[["self"]],["bool"]]],[11,"ge","","",14,[[["self"]],["bool"]]],[11,"gt","","",14,[[["self"]],["bool"]]],[11,"partial_cmp","","",14,[[["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",14,[[["self"]],["bool"]]],[11,"le","","",14,[[["self"]],["bool"]]],[11,"ge","","",14,[[["self"]],["bool"]]],[11,"gt","","",14,[[["self"]],["bool"]]],[11,"partial_cmp","","",14,[[["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",14,[[["self"]],["bool"]]],[11,"le","","",14,[[["self"]],["bool"]]],[11,"ge","","",14,[[["self"]],["bool"]]],[11,"gt","","",14,[[["self"]],["bool"]]],[11,"partial_cmp","","",14,[[["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",14,[[["self"]],["bool"]]],[11,"le","","",14,[[["self"]],["bool"]]],[11,"ge","","",14,[[["self"]],["bool"]]],[11,"gt","","",14,[[["self"]],["bool"]]],[11,"partial_cmp","","",14,[[["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",14,[[["self"]],["bool"]]],[11,"le","","",14,[[["self"]],["bool"]]],[11,"ge","","",14,[[["self"]],["bool"]]],[11,"gt","","",14,[[["self"]],["bool"]]],[11,"partial_cmp","","",14,[[["self"]],[["option",["ordering"]],["ordering"]]]],[11,"lt","","",14,[[["self"]],["bool"]]],[11,"le","","",14,[[["self"]],["bool"]]],[11,"ge","","",14,[[["self"]],["bool"]]],[11,"gt","","",14,[[["self"]],["bool"]]],[11,"add","","",15,[[],["self"]]],[11,"add","","",15,[[["i8"]],["self"]]],[11,"add","","",16,[[],["self"]]],[11,"add","","",16,[[["u8"]],["self"]]],[11,"add","","",18,[[],["self"]]],[11,"add","","",18,[[["i8"]],["self"]]],[11,"add","","",19,[[],["self"]]],[11,"add","","",19,[[["u8"]],["self"]]],[11,"add","","",21,[[],["self"]]],[11,"add","","",21,[[["i16"]],["self"]]],[11,"add","","",22,[[],["self"]]],[11,"add","","",22,[[["u16"]],["self"]]],[11,"add","","",24,[[],["self"]]],[11,"add","","",24,[[["i8"]],["self"]]],[11,"add","","",25,[[],["self"]]],[11,"add","","",25,[[["u8"]],["self"]]],[11,"add","","",27,[[],["self"]]],[11,"add","","",27,[[["i16"]],["self"]]],[11,"add","","",28,[[],["self"]]],[11,"add","","",28,[[["u16"]],["self"]]],[11,"add","","",30,[[],["self"]]],[11,"add","","",30,[[["i32"]],["self"]]],[11,"add","","",31,[[],["self"]]],[11,"add","","",31,[[["u32"]],["self"]]],[11,"add","","",32,[[],["self"]]],[11,"add","","",32,[[["f32"]],["self"]]],[11,"add","","",34,[[],["self"]]],[11,"add","","",34,[[["i8"]],["self"]]],[11,"add","","",35,[[],["self"]]],[11,"add","","",35,[[["u8"]],["self"]]],[11,"add","","",37,[[],["self"]]],[11,"add","","",37,[[["i16"]],["self"]]],[11,"add","","",38,[[],["self"]]],[11,"add","","",38,[[["u16"]],["self"]]],[11,"add","","",40,[[],["self"]]],[11,"add","","",40,[[["i32"]],["self"]]],[11,"add","","",41,[[],["self"]]],[11,"add","","",41,[[["u32"]],["self"]]],[11,"add","","",42,[[],["self"]]],[11,"add","","",42,[[["f32"]],["self"]]],[11,"add","","",44,[[],["self"]]],[11,"add","","",44,[[["i64"]],["self"]]],[11,"add","","",45,[[],["self"]]],[11,"add","","",45,[[["u64"]],["self"]]],[11,"add","","",46,[[],["self"]]],[11,"add","","",46,[[["f64"]],["self"]]],[11,"add","","",51,[[],["self"]]],[11,"add","","",51,[[["i128"]],["self"]]],[11,"add","","",52,[[],["self"]]],[11,"add","","",52,[[["u128"]],["self"]]],[11,"add","","",54,[[],["self"]]],[11,"add","","",54,[[["i8"]],["self"]]],[11,"add","","",55,[[],["self"]]],[11,"add","","",55,[[["u8"]],["self"]]],[11,"add","","",57,[[],["self"]]],[11,"add","","",57,[[["i16"]],["self"]]],[11,"add","","",58,[[],["self"]]],[11,"add","","",58,[[["u16"]],["self"]]],[11,"add","","",60,[[],["self"]]],[11,"add","","",60,[[["i32"]],["self"]]],[11,"add","","",61,[[],["self"]]],[11,"add","","",61,[[["u32"]],["self"]]],[11,"add","","",62,[[],["self"]]],[11,"add","","",62,[[["f32"]],["self"]]],[11,"add","","",64,[[],["self"]]],[11,"add","","",64,[[["i64"]],["self"]]],[11,"add","","",65,[[],["self"]]],[11,"add","","",65,[[["u64"]],["self"]]],[11,"add","","",66,[[],["self"]]],[11,"add","","",66,[[["f64"]],["self"]]],[11,"add","","",68,[[],["self"]]],[11,"add","","",68,[[["i128"]],["self"]]],[11,"add","","",69,[[],["self"]]],[11,"add","","",69,[[["u128"]],["self"]]],[11,"add","","",74,[[],["self"]]],[11,"add","","",74,[[["i8"]],["self"]]],[11,"add","","",75,[[],["self"]]],[11,"add","","",75,[[["u8"]],["self"]]],[11,"add","","",77,[[],["self"]]],[11,"add","","",77,[[["i16"]],["self"]]],[11,"add","","",78,[[],["self"]]],[11,"add","","",78,[[["u16"]],["self"]]],[11,"add","","",80,[[],["self"]]],[11,"add","","",80,[[["i32"]],["self"]]],[11,"add","","",81,[[],["self"]]],[11,"add","","",81,[[["u32"]],["self"]]],[11,"add","","",82,[[],["self"]]],[11,"add","","",82,[[["f32"]],["self"]]],[11,"add","","",84,[[],["self"]]],[11,"add","","",84,[[["i64"]],["self"]]],[11,"add","","",85,[[],["self"]]],[11,"add","","",85,[[["u64"]],["self"]]],[11,"add","","",86,[[],["self"]]],[11,"add","","",86,[[["f64"]],["self"]]],[11,"add","","",88,[[],["self"]]],[11,"add","","",88,[[["i128"]],["self"]]],[11,"add","","",89,[[],["self"]]],[11,"add","","",89,[[["u128"]],["self"]]],[11,"add","","",48,[[],["self"]]],[11,"add","","",48,[[["isize"]],["self"]]],[11,"add","","",49,[[],["self"]]],[11,"add","","",49,[[["usize"]],["self"]]],[11,"add","","",71,[[],["self"]]],[11,"add","","",71,[[["isize"]],["self"]]],[11,"add","","",72,[[],["self"]]],[11,"add","","",72,[[["usize"]],["self"]]],[11,"add","","",91,[[],["self"]]],[11,"add","","",91,[[["isize"]],["self"]]],[11,"add","","",92,[[],["self"]]],[11,"add","","",92,[[["usize"]],["self"]]],[11,"mul","","",15,[[],["self"]]],[11,"mul","","",15,[[["i8"]],["self"]]],[11,"mul","","",16,[[],["self"]]],[11,"mul","","",16,[[["u8"]],["self"]]],[11,"mul","","",18,[[],["self"]]],[11,"mul","","",18,[[["i8"]],["self"]]],[11,"mul","","",19,[[],["self"]]],[11,"mul","","",19,[[["u8"]],["self"]]],[11,"mul","","",21,[[],["self"]]],[11,"mul","","",21,[[["i16"]],["self"]]],[11,"mul","","",22,[[],["self"]]],[11,"mul","","",22,[[["u16"]],["self"]]],[11,"mul","","",24,[[],["self"]]],[11,"mul","","",24,[[["i8"]],["self"]]],[11,"mul","","",25,[[],["self"]]],[11,"mul","","",25,[[["u8"]],["self"]]],[11,"mul","","",27,[[],["self"]]],[11,"mul","","",27,[[["i16"]],["self"]]],[11,"mul","","",28,[[],["self"]]],[11,"mul","","",28,[[["u16"]],["self"]]],[11,"mul","","",30,[[],["self"]]],[11,"mul","","",30,[[["i32"]],["self"]]],[11,"mul","","",31,[[],["self"]]],[11,"mul","","",31,[[["u32"]],["self"]]],[11,"mul","","",32,[[],["self"]]],[11,"mul","","",32,[[["f32"]],["self"]]],[11,"mul","","",34,[[],["self"]]],[11,"mul","","",34,[[["i8"]],["self"]]],[11,"mul","","",35,[[],["self"]]],[11,"mul","","",35,[[["u8"]],["self"]]],[11,"mul","","",37,[[],["self"]]],[11,"mul","","",37,[[["i16"]],["self"]]],[11,"mul","","",38,[[],["self"]]],[11,"mul","","",38,[[["u16"]],["self"]]],[11,"mul","","",40,[[],["self"]]],[11,"mul","","",40,[[["i32"]],["self"]]],[11,"mul","","",41,[[],["self"]]],[11,"mul","","",41,[[["u32"]],["self"]]],[11,"mul","","",42,[[],["self"]]],[11,"mul","","",42,[[["f32"]],["self"]]],[11,"mul","","",44,[[],["self"]]],[11,"mul","","",44,[[["i64"]],["self"]]],[11,"mul","","",45,[[],["self"]]],[11,"mul","","",45,[[["u64"]],["self"]]],[11,"mul","","",46,[[],["self"]]],[11,"mul","","",46,[[["f64"]],["self"]]],[11,"mul","","",51,[[],["self"]]],[11,"mul","","",51,[[["i128"]],["self"]]],[11,"mul","","",52,[[],["self"]]],[11,"mul","","",52,[[["u128"]],["self"]]],[11,"mul","","",54,[[],["self"]]],[11,"mul","","",54,[[["i8"]],["self"]]],[11,"mul","","",55,[[],["self"]]],[11,"mul","","",55,[[["u8"]],["self"]]],[11,"mul","","",57,[[],["self"]]],[11,"mul","","",57,[[["i16"]],["self"]]],[11,"mul","","",58,[[],["self"]]],[11,"mul","","",58,[[["u16"]],["self"]]],[11,"mul","","",60,[[],["self"]]],[11,"mul","","",60,[[["i32"]],["self"]]],[11,"mul","","",61,[[],["self"]]],[11,"mul","","",61,[[["u32"]],["self"]]],[11,"mul","","",62,[[],["self"]]],[11,"mul","","",62,[[["f32"]],["self"]]],[11,"mul","","",64,[[],["self"]]],[11,"mul","","",64,[[["i64"]],["self"]]],[11,"mul","","",65,[[],["self"]]],[11,"mul","","",65,[[["u64"]],["self"]]],[11,"mul","","",66,[[],["self"]]],[11,"mul","","",66,[[["f64"]],["self"]]],[11,"mul","","",68,[[],["self"]]],[11,"mul","","",68,[[["i128"]],["self"]]],[11,"mul","","",69,[[],["self"]]],[11,"mul","","",69,[[["u128"]],["self"]]],[11,"mul","","",74,[[],["self"]]],[11,"mul","","",74,[[["i8"]],["self"]]],[11,"mul","","",75,[[],["self"]]],[11,"mul","","",75,[[["u8"]],["self"]]],[11,"mul","","",77,[[],["self"]]],[11,"mul","","",77,[[["i16"]],["self"]]],[11,"mul","","",78,[[],["self"]]],[11,"mul","","",78,[[["u16"]],["self"]]],[11,"mul","","",80,[[],["self"]]],[11,"mul","","",80,[[["i32"]],["self"]]],[11,"mul","","",81,[[],["self"]]],[11,"mul","","",81,[[["u32"]],["self"]]],[11,"mul","","",82,[[],["self"]]],[11,"mul","","",82,[[["f32"]],["self"]]],[11,"mul","","",84,[[],["self"]]],[11,"mul","","",84,[[["i64"]],["self"]]],[11,"mul","","",85,[[],["self"]]],[11,"mul","","",85,[[["u64"]],["self"]]],[11,"mul","","",86,[[],["self"]]],[11,"mul","","",86,[[["f64"]],["self"]]],[11,"mul","","",88,[[],["self"]]],[11,"mul","","",88,[[["i128"]],["self"]]],[11,"mul","","",89,[[],["self"]]],[11,"mul","","",89,[[["u128"]],["self"]]],[11,"mul","","",48,[[],["self"]]],[11,"mul","","",48,[[["isize"]],["self"]]],[11,"mul","","",49,[[],["self"]]],[11,"mul","","",49,[[["usize"]],["self"]]],[11,"mul","","",71,[[],["self"]]],[11,"mul","","",71,[[["isize"]],["self"]]],[11,"mul","","",72,[[],["self"]]],[11,"mul","","",72,[[["usize"]],["self"]]],[11,"mul","","",91,[[],["self"]]],[11,"mul","","",91,[[["isize"]],["self"]]],[11,"mul","","",92,[[],["self"]]],[11,"mul","","",92,[[["usize"]],["self"]]],[11,"neg","","",15,[[],["self"]]],[11,"neg","","",18,[[],["self"]]],[11,"neg","","",21,[[],["self"]]],[11,"neg","","",24,[[],["self"]]],[11,"neg","","",27,[[],["self"]]],[11,"neg","","",30,[[],["self"]]],[11,"neg","","",32,[[],["self"]]],[11,"neg","","",34,[[],["self"]]],[11,"neg","","",37,[[],["self"]]],[11,"neg","","",40,[[],["self"]]],[11,"neg","","",42,[[],["self"]]],[11,"neg","","",44,[[],["self"]]],[11,"neg","","",46,[[],["self"]]],[11,"neg","","",51,[[],["self"]]],[11,"neg","","",54,[[],["self"]]],[11,"neg","","",57,[[],["self"]]],[11,"neg","","",60,[[],["self"]]],[11,"neg","","",62,[[],["self"]]],[11,"neg","","",64,[[],["self"]]],[11,"neg","","",66,[[],["self"]]],[11,"neg","","",68,[[],["self"]]],[11,"neg","","",74,[[],["self"]]],[11,"neg","","",77,[[],["self"]]],[11,"neg","","",80,[[],["self"]]],[11,"neg","","",82,[[],["self"]]],[11,"neg","","",84,[[],["self"]]],[11,"neg","","",86,[[],["self"]]],[11,"neg","","",88,[[],["self"]]],[11,"neg","","",48,[[],["self"]]],[11,"neg","","",71,[[],["self"]]],[11,"neg","","",91,[[],["self"]]],[11,"add_assign","","",15,[[["self"]]]],[11,"add_assign","","",15,[[["self"],["i8"]]]],[11,"add_assign","","",16,[[["self"]]]],[11,"add_assign","","",16,[[["self"],["u8"]]]],[11,"add_assign","","",18,[[["self"]]]],[11,"add_assign","","",18,[[["self"],["i8"]]]],[11,"add_assign","","",19,[[["self"]]]],[11,"add_assign","","",19,[[["self"],["u8"]]]],[11,"add_assign","","",21,[[["self"]]]],[11,"add_assign","","",21,[[["self"],["i16"]]]],[11,"add_assign","","",22,[[["self"]]]],[11,"add_assign","","",22,[[["u16"],["self"]]]],[11,"add_assign","","",24,[[["self"]]]],[11,"add_assign","","",24,[[["self"],["i8"]]]],[11,"add_assign","","",25,[[["self"]]]],[11,"add_assign","","",25,[[["self"],["u8"]]]],[11,"add_assign","","",27,[[["self"]]]],[11,"add_assign","","",27,[[["self"],["i16"]]]],[11,"add_assign","","",28,[[["self"]]]],[11,"add_assign","","",28,[[["u16"],["self"]]]],[11,"add_assign","","",30,[[["self"]]]],[11,"add_assign","","",30,[[["self"],["i32"]]]],[11,"add_assign","","",31,[[["self"]]]],[11,"add_assign","","",31,[[["self"],["u32"]]]],[11,"add_assign","","",32,[[["self"]]]],[11,"add_assign","","",32,[[["f32"],["self"]]]],[11,"add_assign","","",34,[[["self"]]]],[11,"add_assign","","",34,[[["self"],["i8"]]]],[11,"add_assign","","",35,[[["self"]]]],[11,"add_assign","","",35,[[["self"],["u8"]]]],[11,"add_assign","","",37,[[["self"]]]],[11,"add_assign","","",37,[[["self"],["i16"]]]],[11,"add_assign","","",38,[[["self"]]]],[11,"add_assign","","",38,[[["u16"],["self"]]]],[11,"add_assign","","",40,[[["self"]]]],[11,"add_assign","","",40,[[["self"],["i32"]]]],[11,"add_assign","","",41,[[["self"]]]],[11,"add_assign","","",41,[[["self"],["u32"]]]],[11,"add_assign","","",42,[[["self"]]]],[11,"add_assign","","",42,[[["f32"],["self"]]]],[11,"add_assign","","",44,[[["self"]]]],[11,"add_assign","","",44,[[["i64"],["self"]]]],[11,"add_assign","","",45,[[["self"]]]],[11,"add_assign","","",45,[[["self"],["u64"]]]],[11,"add_assign","","",46,[[["self"]]]],[11,"add_assign","","",46,[[["self"],["f64"]]]],[11,"add_assign","","",51,[[["self"]]]],[11,"add_assign","","",51,[[["self"],["i128"]]]],[11,"add_assign","","",52,[[["self"]]]],[11,"add_assign","","",52,[[["self"],["u128"]]]],[11,"add_assign","","",54,[[["self"]]]],[11,"add_assign","","",54,[[["self"],["i8"]]]],[11,"add_assign","","",55,[[["self"]]]],[11,"add_assign","","",55,[[["self"],["u8"]]]],[11,"add_assign","","",57,[[["self"]]]],[11,"add_assign","","",57,[[["self"],["i16"]]]],[11,"add_assign","","",58,[[["self"]]]],[11,"add_assign","","",58,[[["u16"],["self"]]]],[11,"add_assign","","",60,[[["self"]]]],[11,"add_assign","","",60,[[["self"],["i32"]]]],[11,"add_assign","","",61,[[["self"]]]],[11,"add_assign","","",61,[[["self"],["u32"]]]],[11,"add_assign","","",62,[[["self"]]]],[11,"add_assign","","",62,[[["f32"],["self"]]]],[11,"add_assign","","",64,[[["self"]]]],[11,"add_assign","","",64,[[["i64"],["self"]]]],[11,"add_assign","","",65,[[["self"]]]],[11,"add_assign","","",65,[[["self"],["u64"]]]],[11,"add_assign","","",66,[[["self"]]]],[11,"add_assign","","",66,[[["self"],["f64"]]]],[11,"add_assign","","",68,[[["self"]]]],[11,"add_assign","","",68,[[["self"],["i128"]]]],[11,"add_assign","","",69,[[["self"]]]],[11,"add_assign","","",69,[[["self"],["u128"]]]],[11,"add_assign","","",74,[[["self"]]]],[11,"add_assign","","",74,[[["self"],["i8"]]]],[11,"add_assign","","",75,[[["self"]]]],[11,"add_assign","","",75,[[["self"],["u8"]]]],[11,"add_assign","","",77,[[["self"]]]],[11,"add_assign","","",77,[[["self"],["i16"]]]],[11,"add_assign","","",78,[[["self"]]]],[11,"add_assign","","",78,[[["u16"],["self"]]]],[11,"add_assign","","",80,[[["self"]]]],[11,"add_assign","","",80,[[["self"],["i32"]]]],[11,"add_assign","","",81,[[["self"]]]],[11,"add_assign","","",81,[[["self"],["u32"]]]],[11,"add_assign","","",82,[[["self"]]]],[11,"add_assign","","",82,[[["f32"],["self"]]]],[11,"add_assign","","",84,[[["self"]]]],[11,"add_assign","","",84,[[["i64"],["self"]]]],[11,"add_assign","","",85,[[["self"]]]],[11,"add_assign","","",85,[[["self"],["u64"]]]],[11,"add_assign","","",86,[[["self"]]]],[11,"add_assign","","",86,[[["self"],["f64"]]]],[11,"add_assign","","",88,[[["self"]]]],[11,"add_assign","","",88,[[["self"],["i128"]]]],[11,"add_assign","","",89,[[["self"]]]],[11,"add_assign","","",89,[[["self"],["u128"]]]],[11,"add_assign","","",48,[[["self"]]]],[11,"add_assign","","",48,[[["isize"],["self"]]]],[11,"add_assign","","",49,[[["self"]]]],[11,"add_assign","","",49,[[["self"],["usize"]]]],[11,"add_assign","","",71,[[["self"]]]],[11,"add_assign","","",71,[[["isize"],["self"]]]],[11,"add_assign","","",72,[[["self"]]]],[11,"add_assign","","",72,[[["self"],["usize"]]]],[11,"add_assign","","",91,[[["self"]]]],[11,"add_assign","","",91,[[["isize"],["self"]]]],[11,"add_assign","","",92,[[["self"]]]],[11,"add_assign","","",92,[[["self"],["usize"]]]],[11,"sub_assign","","",15,[[["self"]]]],[11,"sub_assign","","",15,[[["self"],["i8"]]]],[11,"sub_assign","","",16,[[["self"]]]],[11,"sub_assign","","",16,[[["self"],["u8"]]]],[11,"sub_assign","","",18,[[["self"]]]],[11,"sub_assign","","",18,[[["self"],["i8"]]]],[11,"sub_assign","","",19,[[["self"]]]],[11,"sub_assign","","",19,[[["self"],["u8"]]]],[11,"sub_assign","","",21,[[["self"]]]],[11,"sub_assign","","",21,[[["self"],["i16"]]]],[11,"sub_assign","","",22,[[["self"]]]],[11,"sub_assign","","",22,[[["u16"],["self"]]]],[11,"sub_assign","","",24,[[["self"]]]],[11,"sub_assign","","",24,[[["self"],["i8"]]]],[11,"sub_assign","","",25,[[["self"]]]],[11,"sub_assign","","",25,[[["self"],["u8"]]]],[11,"sub_assign","","",27,[[["self"]]]],[11,"sub_assign","","",27,[[["self"],["i16"]]]],[11,"sub_assign","","",28,[[["self"]]]],[11,"sub_assign","","",28,[[["u16"],["self"]]]],[11,"sub_assign","","",30,[[["self"]]]],[11,"sub_assign","","",30,[[["self"],["i32"]]]],[11,"sub_assign","","",31,[[["self"]]]],[11,"sub_assign","","",31,[[["self"],["u32"]]]],[11,"sub_assign","","",32,[[["self"]]]],[11,"sub_assign","","",32,[[["f32"],["self"]]]],[11,"sub_assign","","",34,[[["self"]]]],[11,"sub_assign","","",34,[[["self"],["i8"]]]],[11,"sub_assign","","",35,[[["self"]]]],[11,"sub_assign","","",35,[[["self"],["u8"]]]],[11,"sub_assign","","",37,[[["self"]]]],[11,"sub_assign","","",37,[[["self"],["i16"]]]],[11,"sub_assign","","",38,[[["self"]]]],[11,"sub_assign","","",38,[[["u16"],["self"]]]],[11,"sub_assign","","",40,[[["self"]]]],[11,"sub_assign","","",40,[[["self"],["i32"]]]],[11,"sub_assign","","",41,[[["self"]]]],[11,"sub_assign","","",41,[[["self"],["u32"]]]],[11,"sub_assign","","",42,[[["self"]]]],[11,"sub_assign","","",42,[[["f32"],["self"]]]],[11,"sub_assign","","",44,[[["self"]]]],[11,"sub_assign","","",44,[[["i64"],["self"]]]],[11,"sub_assign","","",45,[[["self"]]]],[11,"sub_assign","","",45,[[["self"],["u64"]]]],[11,"sub_assign","","",46,[[["self"]]]],[11,"sub_assign","","",46,[[["self"],["f64"]]]],[11,"sub_assign","","",51,[[["self"]]]],[11,"sub_assign","","",51,[[["self"],["i128"]]]],[11,"sub_assign","","",52,[[["self"]]]],[11,"sub_assign","","",52,[[["self"],["u128"]]]],[11,"sub_assign","","",54,[[["self"]]]],[11,"sub_assign","","",54,[[["self"],["i8"]]]],[11,"sub_assign","","",55,[[["self"]]]],[11,"sub_assign","","",55,[[["self"],["u8"]]]],[11,"sub_assign","","",57,[[["self"]]]],[11,"sub_assign","","",57,[[["self"],["i16"]]]],[11,"sub_assign","","",58,[[["self"]]]],[11,"sub_assign","","",58,[[["u16"],["self"]]]],[11,"sub_assign","","",60,[[["self"]]]],[11,"sub_assign","","",60,[[["self"],["i32"]]]],[11,"sub_assign","","",61,[[["self"]]]],[11,"sub_assign","","",61,[[["self"],["u32"]]]],[11,"sub_assign","","",62,[[["self"]]]],[11,"sub_assign","","",62,[[["f32"],["self"]]]],[11,"sub_assign","","",64,[[["self"]]]],[11,"sub_assign","","",64,[[["i64"],["self"]]]],[11,"sub_assign","","",65,[[["self"]]]],[11,"sub_assign","","",65,[[["self"],["u64"]]]],[11,"sub_assign","","",66,[[["self"]]]],[11,"sub_assign","","",66,[[["self"],["f64"]]]],[11,"sub_assign","","",68,[[["self"]]]],[11,"sub_assign","","",68,[[["self"],["i128"]]]],[11,"sub_assign","","",69,[[["self"]]]],[11,"sub_assign","","",69,[[["self"],["u128"]]]],[11,"sub_assign","","",74,[[["self"]]]],[11,"sub_assign","","",74,[[["self"],["i8"]]]],[11,"sub_assign","","",75,[[["self"]]]],[11,"sub_assign","","",75,[[["self"],["u8"]]]],[11,"sub_assign","","",77,[[["self"]]]],[11,"sub_assign","","",77,[[["self"],["i16"]]]],[11,"sub_assign","","",78,[[["self"]]]],[11,"sub_assign","","",78,[[["u16"],["self"]]]],[11,"sub_assign","","",80,[[["self"]]]],[11,"sub_assign","","",80,[[["self"],["i32"]]]],[11,"sub_assign","","",81,[[["self"]]]],[11,"sub_assign","","",81,[[["self"],["u32"]]]],[11,"sub_assign","","",82,[[["self"]]]],[11,"sub_assign","","",82,[[["f32"],["self"]]]],[11,"sub_assign","","",84,[[["self"]]]],[11,"sub_assign","","",84,[[["i64"],["self"]]]],[11,"sub_assign","","",85,[[["self"]]]],[11,"sub_assign","","",85,[[["self"],["u64"]]]],[11,"sub_assign","","",86,[[["self"]]]],[11,"sub_assign","","",86,[[["self"],["f64"]]]],[11,"sub_assign","","",88,[[["self"]]]],[11,"sub_assign","","",88,[[["self"],["i128"]]]],[11,"sub_assign","","",89,[[["self"]]]],[11,"sub_assign","","",89,[[["self"],["u128"]]]],[11,"sub_assign","","",48,[[["self"]]]],[11,"sub_assign","","",48,[[["isize"],["self"]]]],[11,"sub_assign","","",49,[[["self"]]]],[11,"sub_assign","","",49,[[["self"],["usize"]]]],[11,"sub_assign","","",71,[[["self"]]]],[11,"sub_assign","","",71,[[["isize"],["self"]]]],[11,"sub_assign","","",72,[[["self"]]]],[11,"sub_assign","","",72,[[["self"],["usize"]]]],[11,"sub_assign","","",91,[[["self"]]]],[11,"sub_assign","","",91,[[["isize"],["self"]]]],[11,"sub_assign","","",92,[[["self"]]]],[11,"sub_assign","","",92,[[["self"],["usize"]]]],[11,"mul_assign","","",15,[[["self"]]]],[11,"mul_assign","","",15,[[["self"],["i8"]]]],[11,"mul_assign","","",16,[[["self"]]]],[11,"mul_assign","","",16,[[["self"],["u8"]]]],[11,"mul_assign","","",18,[[["self"]]]],[11,"mul_assign","","",18,[[["self"],["i8"]]]],[11,"mul_assign","","",19,[[["self"]]]],[11,"mul_assign","","",19,[[["self"],["u8"]]]],[11,"mul_assign","","",21,[[["self"]]]],[11,"mul_assign","","",21,[[["self"],["i16"]]]],[11,"mul_assign","","",22,[[["self"]]]],[11,"mul_assign","","",22,[[["u16"],["self"]]]],[11,"mul_assign","","",24,[[["self"]]]],[11,"mul_assign","","",24,[[["self"],["i8"]]]],[11,"mul_assign","","",25,[[["self"]]]],[11,"mul_assign","","",25,[[["self"],["u8"]]]],[11,"mul_assign","","",27,[[["self"]]]],[11,"mul_assign","","",27,[[["self"],["i16"]]]],[11,"mul_assign","","",28,[[["self"]]]],[11,"mul_assign","","",28,[[["u16"],["self"]]]],[11,"mul_assign","","",30,[[["self"]]]],[11,"mul_assign","","",30,[[["self"],["i32"]]]],[11,"mul_assign","","",31,[[["self"]]]],[11,"mul_assign","","",31,[[["self"],["u32"]]]],[11,"mul_assign","","",32,[[["self"]]]],[11,"mul_assign","","",32,[[["f32"],["self"]]]],[11,"mul_assign","","",34,[[["self"]]]],[11,"mul_assign","","",34,[[["self"],["i8"]]]],[11,"mul_assign","","",35,[[["self"]]]],[11,"mul_assign","","",35,[[["self"],["u8"]]]],[11,"mul_assign","","",37,[[["self"]]]],[11,"mul_assign","","",37,[[["self"],["i16"]]]],[11,"mul_assign","","",38,[[["self"]]]],[11,"mul_assign","","",38,[[["u16"],["self"]]]],[11,"mul_assign","","",40,[[["self"]]]],[11,"mul_assign","","",40,[[["self"],["i32"]]]],[11,"mul_assign","","",41,[[["self"]]]],[11,"mul_assign","","",41,[[["self"],["u32"]]]],[11,"mul_assign","","",42,[[["self"]]]],[11,"mul_assign","","",42,[[["f32"],["self"]]]],[11,"mul_assign","","",44,[[["self"]]]],[11,"mul_assign","","",44,[[["i64"],["self"]]]],[11,"mul_assign","","",45,[[["self"]]]],[11,"mul_assign","","",45,[[["self"],["u64"]]]],[11,"mul_assign","","",46,[[["self"]]]],[11,"mul_assign","","",46,[[["self"],["f64"]]]],[11,"mul_assign","","",51,[[["self"]]]],[11,"mul_assign","","",51,[[["self"],["i128"]]]],[11,"mul_assign","","",52,[[["self"]]]],[11,"mul_assign","","",52,[[["self"],["u128"]]]],[11,"mul_assign","","",54,[[["self"]]]],[11,"mul_assign","","",54,[[["self"],["i8"]]]],[11,"mul_assign","","",55,[[["self"]]]],[11,"mul_assign","","",55,[[["self"],["u8"]]]],[11,"mul_assign","","",57,[[["self"]]]],[11,"mul_assign","","",57,[[["self"],["i16"]]]],[11,"mul_assign","","",58,[[["self"]]]],[11,"mul_assign","","",58,[[["u16"],["self"]]]],[11,"mul_assign","","",60,[[["self"]]]],[11,"mul_assign","","",60,[[["self"],["i32"]]]],[11,"mul_assign","","",61,[[["self"]]]],[11,"mul_assign","","",61,[[["self"],["u32"]]]],[11,"mul_assign","","",62,[[["self"]]]],[11,"mul_assign","","",62,[[["f32"],["self"]]]],[11,"mul_assign","","",64,[[["self"]]]],[11,"mul_assign","","",64,[[["i64"],["self"]]]],[11,"mul_assign","","",65,[[["self"]]]],[11,"mul_assign","","",65,[[["self"],["u64"]]]],[11,"mul_assign","","",66,[[["self"]]]],[11,"mul_assign","","",66,[[["self"],["f64"]]]],[11,"mul_assign","","",68,[[["self"]]]],[11,"mul_assign","","",68,[[["self"],["i128"]]]],[11,"mul_assign","","",69,[[["self"]]]],[11,"mul_assign","","",69,[[["self"],["u128"]]]],[11,"mul_assign","","",74,[[["self"]]]],[11,"mul_assign","","",74,[[["self"],["i8"]]]],[11,"mul_assign","","",75,[[["self"]]]],[11,"mul_assign","","",75,[[["self"],["u8"]]]],[11,"mul_assign","","",77,[[["self"]]]],[11,"mul_assign","","",77,[[["self"],["i16"]]]],[11,"mul_assign","","",78,[[["self"]]]],[11,"mul_assign","","",78,[[["u16"],["self"]]]],[11,"mul_assign","","",80,[[["self"]]]],[11,"mul_assign","","",80,[[["self"],["i32"]]]],[11,"mul_assign","","",81,[[["self"]]]],[11,"mul_assign","","",81,[[["self"],["u32"]]]],[11,"mul_assign","","",82,[[["self"]]]],[11,"mul_assign","","",82,[[["f32"],["self"]]]],[11,"mul_assign","","",84,[[["self"]]]],[11,"mul_assign","","",84,[[["i64"],["self"]]]],[11,"mul_assign","","",85,[[["self"]]]],[11,"mul_assign","","",85,[[["self"],["u64"]]]],[11,"mul_assign","","",86,[[["self"]]]],[11,"mul_assign","","",86,[[["self"],["f64"]]]],[11,"mul_assign","","",88,[[["self"]]]],[11,"mul_assign","","",88,[[["self"],["i128"]]]],[11,"mul_assign","","",89,[[["self"]]]],[11,"mul_assign","","",89,[[["self"],["u128"]]]],[11,"mul_assign","","",48,[[["self"]]]],[11,"mul_assign","","",48,[[["isize"],["self"]]]],[11,"mul_assign","","",49,[[["self"]]]],[11,"mul_assign","","",49,[[["self"],["usize"]]]],[11,"mul_assign","","",71,[[["self"]]]],[11,"mul_assign","","",71,[[["isize"],["self"]]]],[11,"mul_assign","","",72,[[["self"]]]],[11,"mul_assign","","",72,[[["self"],["usize"]]]],[11,"mul_assign","","",91,[[["self"]]]],[11,"mul_assign","","",91,[[["isize"],["self"]]]],[11,"mul_assign","","",92,[[["self"]]]],[11,"mul_assign","","",92,[[["self"],["usize"]]]],[11,"div_assign","","",15,[[["self"]]]],[11,"div_assign","","",15,[[["self"],["i8"]]]],[11,"div_assign","","",16,[[["self"]]]],[11,"div_assign","","",16,[[["self"],["u8"]]]],[11,"div_assign","","",18,[[["self"]]]],[11,"div_assign","","",18,[[["self"],["i8"]]]],[11,"div_assign","","",19,[[["self"]]]],[11,"div_assign","","",19,[[["self"],["u8"]]]],[11,"div_assign","","",21,[[["self"]]]],[11,"div_assign","","",21,[[["self"],["i16"]]]],[11,"div_assign","","",22,[[["self"]]]],[11,"div_assign","","",22,[[["u16"],["self"]]]],[11,"div_assign","","",24,[[["self"]]]],[11,"div_assign","","",24,[[["self"],["i8"]]]],[11,"div_assign","","",25,[[["self"]]]],[11,"div_assign","","",25,[[["self"],["u8"]]]],[11,"div_assign","","",27,[[["self"]]]],[11,"div_assign","","",27,[[["self"],["i16"]]]],[11,"div_assign","","",28,[[["self"]]]],[11,"div_assign","","",28,[[["u16"],["self"]]]],[11,"div_assign","","",30,[[["self"]]]],[11,"div_assign","","",30,[[["self"],["i32"]]]],[11,"div_assign","","",31,[[["self"]]]],[11,"div_assign","","",31,[[["self"],["u32"]]]],[11,"div_assign","","",32,[[["self"]]]],[11,"div_assign","","",32,[[["f32"],["self"]]]],[11,"div_assign","","",34,[[["self"]]]],[11,"div_assign","","",34,[[["self"],["i8"]]]],[11,"div_assign","","",35,[[["self"]]]],[11,"div_assign","","",35,[[["self"],["u8"]]]],[11,"div_assign","","",37,[[["self"]]]],[11,"div_assign","","",37,[[["self"],["i16"]]]],[11,"div_assign","","",38,[[["self"]]]],[11,"div_assign","","",38,[[["u16"],["self"]]]],[11,"div_assign","","",40,[[["self"]]]],[11,"div_assign","","",40,[[["self"],["i32"]]]],[11,"div_assign","","",41,[[["self"]]]],[11,"div_assign","","",41,[[["self"],["u32"]]]],[11,"div_assign","","",42,[[["self"]]]],[11,"div_assign","","",42,[[["f32"],["self"]]]],[11,"div_assign","","",44,[[["self"]]]],[11,"div_assign","","",44,[[["i64"],["self"]]]],[11,"div_assign","","",45,[[["self"]]]],[11,"div_assign","","",45,[[["self"],["u64"]]]],[11,"div_assign","","",46,[[["self"]]]],[11,"div_assign","","",46,[[["self"],["f64"]]]],[11,"div_assign","","",51,[[["self"]]]],[11,"div_assign","","",51,[[["self"],["i128"]]]],[11,"div_assign","","",52,[[["self"]]]],[11,"div_assign","","",52,[[["self"],["u128"]]]],[11,"div_assign","","",54,[[["self"]]]],[11,"div_assign","","",54,[[["self"],["i8"]]]],[11,"div_assign","","",55,[[["self"]]]],[11,"div_assign","","",55,[[["self"],["u8"]]]],[11,"div_assign","","",57,[[["self"]]]],[11,"div_assign","","",57,[[["self"],["i16"]]]],[11,"div_assign","","",58,[[["self"]]]],[11,"div_assign","","",58,[[["u16"],["self"]]]],[11,"div_assign","","",60,[[["self"]]]],[11,"div_assign","","",60,[[["self"],["i32"]]]],[11,"div_assign","","",61,[[["self"]]]],[11,"div_assign","","",61,[[["self"],["u32"]]]],[11,"div_assign","","",62,[[["self"]]]],[11,"div_assign","","",62,[[["f32"],["self"]]]],[11,"div_assign","","",64,[[["self"]]]],[11,"div_assign","","",64,[[["i64"],["self"]]]],[11,"div_assign","","",65,[[["self"]]]],[11,"div_assign","","",65,[[["self"],["u64"]]]],[11,"div_assign","","",66,[[["self"]]]],[11,"div_assign","","",66,[[["self"],["f64"]]]],[11,"div_assign","","",68,[[["self"]]]],[11,"div_assign","","",68,[[["self"],["i128"]]]],[11,"div_assign","","",69,[[["self"]]]],[11,"div_assign","","",69,[[["self"],["u128"]]]],[11,"div_assign","","",74,[[["self"]]]],[11,"div_assign","","",74,[[["self"],["i8"]]]],[11,"div_assign","","",75,[[["self"]]]],[11,"div_assign","","",75,[[["self"],["u8"]]]],[11,"div_assign","","",77,[[["self"]]]],[11,"div_assign","","",77,[[["self"],["i16"]]]],[11,"div_assign","","",78,[[["self"]]]],[11,"div_assign","","",78,[[["u16"],["self"]]]],[11,"div_assign","","",80,[[["self"]]]],[11,"div_assign","","",80,[[["self"],["i32"]]]],[11,"div_assign","","",81,[[["self"]]]],[11,"div_assign","","",81,[[["self"],["u32"]]]],[11,"div_assign","","",82,[[["self"]]]],[11,"div_assign","","",82,[[["f32"],["self"]]]],[11,"div_assign","","",84,[[["self"]]]],[11,"div_assign","","",84,[[["i64"],["self"]]]],[11,"div_assign","","",85,[[["self"]]]],[11,"div_assign","","",85,[[["self"],["u64"]]]],[11,"div_assign","","",86,[[["self"]]]],[11,"div_assign","","",86,[[["self"],["f64"]]]],[11,"div_assign","","",88,[[["self"]]]],[11,"div_assign","","",88,[[["self"],["i128"]]]],[11,"div_assign","","",89,[[["self"]]]],[11,"div_assign","","",89,[[["self"],["u128"]]]],[11,"div_assign","","",48,[[["self"]]]],[11,"div_assign","","",48,[[["isize"],["self"]]]],[11,"div_assign","","",49,[[["self"]]]],[11,"div_assign","","",49,[[["self"],["usize"]]]],[11,"div_assign","","",71,[[["self"]]]],[11,"div_assign","","",71,[[["isize"],["self"]]]],[11,"div_assign","","",72,[[["self"]]]],[11,"div_assign","","",72,[[["self"],["usize"]]]],[11,"div_assign","","",91,[[["self"]]]],[11,"div_assign","","",91,[[["isize"],["self"]]]],[11,"div_assign","","",92,[[["self"]]]],[11,"div_assign","","",92,[[["self"],["usize"]]]],[11,"rem_assign","","",15,[[["self"]]]],[11,"rem_assign","","",15,[[["self"],["i8"]]]],[11,"rem_assign","","",16,[[["self"]]]],[11,"rem_assign","","",16,[[["self"],["u8"]]]],[11,"rem_assign","","",18,[[["self"]]]],[11,"rem_assign","","",18,[[["self"],["i8"]]]],[11,"rem_assign","","",19,[[["self"]]]],[11,"rem_assign","","",19,[[["self"],["u8"]]]],[11,"rem_assign","","",21,[[["self"]]]],[11,"rem_assign","","",21,[[["self"],["i16"]]]],[11,"rem_assign","","",22,[[["self"]]]],[11,"rem_assign","","",22,[[["u16"],["self"]]]],[11,"rem_assign","","",24,[[["self"]]]],[11,"rem_assign","","",24,[[["self"],["i8"]]]],[11,"rem_assign","","",25,[[["self"]]]],[11,"rem_assign","","",25,[[["self"],["u8"]]]],[11,"rem_assign","","",27,[[["self"]]]],[11,"rem_assign","","",27,[[["self"],["i16"]]]],[11,"rem_assign","","",28,[[["self"]]]],[11,"rem_assign","","",28,[[["u16"],["self"]]]],[11,"rem_assign","","",30,[[["self"]]]],[11,"rem_assign","","",30,[[["self"],["i32"]]]],[11,"rem_assign","","",31,[[["self"]]]],[11,"rem_assign","","",31,[[["self"],["u32"]]]],[11,"rem_assign","","",32,[[["self"]]]],[11,"rem_assign","","",32,[[["f32"],["self"]]]],[11,"rem_assign","","",34,[[["self"]]]],[11,"rem_assign","","",34,[[["self"],["i8"]]]],[11,"rem_assign","","",35,[[["self"]]]],[11,"rem_assign","","",35,[[["self"],["u8"]]]],[11,"rem_assign","","",37,[[["self"]]]],[11,"rem_assign","","",37,[[["self"],["i16"]]]],[11,"rem_assign","","",38,[[["self"]]]],[11,"rem_assign","","",38,[[["u16"],["self"]]]],[11,"rem_assign","","",40,[[["self"]]]],[11,"rem_assign","","",40,[[["self"],["i32"]]]],[11,"rem_assign","","",41,[[["self"]]]],[11,"rem_assign","","",41,[[["self"],["u32"]]]],[11,"rem_assign","","",42,[[["self"]]]],[11,"rem_assign","","",42,[[["f32"],["self"]]]],[11,"rem_assign","","",44,[[["self"]]]],[11,"rem_assign","","",44,[[["i64"],["self"]]]],[11,"rem_assign","","",45,[[["self"]]]],[11,"rem_assign","","",45,[[["self"],["u64"]]]],[11,"rem_assign","","",46,[[["self"]]]],[11,"rem_assign","","",46,[[["self"],["f64"]]]],[11,"rem_assign","","",51,[[["self"]]]],[11,"rem_assign","","",51,[[["self"],["i128"]]]],[11,"rem_assign","","",52,[[["self"]]]],[11,"rem_assign","","",52,[[["self"],["u128"]]]],[11,"rem_assign","","",54,[[["self"]]]],[11,"rem_assign","","",54,[[["self"],["i8"]]]],[11,"rem_assign","","",55,[[["self"]]]],[11,"rem_assign","","",55,[[["self"],["u8"]]]],[11,"rem_assign","","",57,[[["self"]]]],[11,"rem_assign","","",57,[[["self"],["i16"]]]],[11,"rem_assign","","",58,[[["self"]]]],[11,"rem_assign","","",58,[[["u16"],["self"]]]],[11,"rem_assign","","",60,[[["self"]]]],[11,"rem_assign","","",60,[[["self"],["i32"]]]],[11,"rem_assign","","",61,[[["self"]]]],[11,"rem_assign","","",61,[[["self"],["u32"]]]],[11,"rem_assign","","",62,[[["self"]]]],[11,"rem_assign","","",62,[[["f32"],["self"]]]],[11,"rem_assign","","",64,[[["self"]]]],[11,"rem_assign","","",64,[[["i64"],["self"]]]],[11,"rem_assign","","",65,[[["self"]]]],[11,"rem_assign","","",65,[[["self"],["u64"]]]],[11,"rem_assign","","",66,[[["self"]]]],[11,"rem_assign","","",66,[[["self"],["f64"]]]],[11,"rem_assign","","",68,[[["self"]]]],[11,"rem_assign","","",68,[[["self"],["i128"]]]],[11,"rem_assign","","",69,[[["self"]]]],[11,"rem_assign","","",69,[[["self"],["u128"]]]],[11,"rem_assign","","",74,[[["self"]]]],[11,"rem_assign","","",74,[[["self"],["i8"]]]],[11,"rem_assign","","",75,[[["self"]]]],[11,"rem_assign","","",75,[[["self"],["u8"]]]],[11,"rem_assign","","",77,[[["self"]]]],[11,"rem_assign","","",77,[[["self"],["i16"]]]],[11,"rem_assign","","",78,[[["self"]]]],[11,"rem_assign","","",78,[[["u16"],["self"]]]],[11,"rem_assign","","",80,[[["self"]]]],[11,"rem_assign","","",80,[[["self"],["i32"]]]],[11,"rem_assign","","",81,[[["self"]]]],[11,"rem_assign","","",81,[[["self"],["u32"]]]],[11,"rem_assign","","",82,[[["self"]]]],[11,"rem_assign","","",82,[[["f32"],["self"]]]],[11,"rem_assign","","",84,[[["self"]]]],[11,"rem_assign","","",84,[[["i64"],["self"]]]],[11,"rem_assign","","",85,[[["self"]]]],[11,"rem_assign","","",85,[[["self"],["u64"]]]],[11,"rem_assign","","",86,[[["self"]]]],[11,"rem_assign","","",86,[[["self"],["f64"]]]],[11,"rem_assign","","",88,[[["self"]]]],[11,"rem_assign","","",88,[[["self"],["i128"]]]],[11,"rem_assign","","",89,[[["self"]]]],[11,"rem_assign","","",89,[[["self"],["u128"]]]],[11,"rem_assign","","",48,[[["self"]]]],[11,"rem_assign","","",48,[[["isize"],["self"]]]],[11,"rem_assign","","",49,[[["self"]]]],[11,"rem_assign","","",49,[[["self"],["usize"]]]],[11,"rem_assign","","",71,[[["self"]]]],[11,"rem_assign","","",71,[[["isize"],["self"]]]],[11,"rem_assign","","",72,[[["self"]]]],[11,"rem_assign","","",72,[[["self"],["usize"]]]],[11,"rem_assign","","",91,[[["self"]]]],[11,"rem_assign","","",91,[[["isize"],["self"]]]],[11,"rem_assign","","",92,[[["self"]]]],[11,"rem_assign","","",92,[[["self"],["usize"]]]],[11,"not","","",15,[[],["self"]]],[11,"not","","",16,[[],["self"]]],[11,"not","","",17,[[],["self"]]],[11,"not","","",18,[[],["self"]]],[11,"not","","",19,[[],["self"]]],[11,"not","","",20,[[],["self"]]],[11,"not","","",21,[[],["self"]]],[11,"not","","",22,[[],["self"]]],[11,"not","","",23,[[],["self"]]],[11,"not","","",24,[[],["self"]]],[11,"not","","",25,[[],["self"]]],[11,"not","","",26,[[],["self"]]],[11,"not","","",27,[[],["self"]]],[11,"not","","",28,[[],["self"]]],[11,"not","","",29,[[],["self"]]],[11,"not","","",30,[[],["self"]]],[11,"not","","",31,[[],["self"]]],[11,"not","","",33,[[],["self"]]],[11,"not","","",34,[[],["self"]]],[11,"not","","",35,[[],["self"]]],[11,"not","","",36,[[],["self"]]],[11,"not","","",37,[[],["self"]]],[11,"not","","",38,[[],["self"]]],[11,"not","","",39,[[],["self"]]],[11,"not","","",40,[[],["self"]]],[11,"not","","",41,[[],["self"]]],[11,"not","","",43,[[],["self"]]],[11,"not","","",44,[[],["self"]]],[11,"not","","",45,[[],["self"]]],[11,"not","","",47,[[],["self"]]],[11,"not","","",51,[[],["self"]]],[11,"not","","",52,[[],["self"]]],[11,"not","","",53,[[],["self"]]],[11,"not","","",54,[[],["self"]]],[11,"not","","",55,[[],["self"]]],[11,"not","","",56,[[],["self"]]],[11,"not","","",57,[[],["self"]]],[11,"not","","",58,[[],["self"]]],[11,"not","","",59,[[],["self"]]],[11,"not","","",60,[[],["self"]]],[11,"not","","",61,[[],["self"]]],[11,"not","","",63,[[],["self"]]],[11,"not","","",64,[[],["self"]]],[11,"not","","",65,[[],["self"]]],[11,"not","","",67,[[],["self"]]],[11,"not","","",68,[[],["self"]]],[11,"not","","",69,[[],["self"]]],[11,"not","","",70,[[],["self"]]],[11,"not","","",74,[[],["self"]]],[11,"not","","",75,[[],["self"]]],[11,"not","","",76,[[],["self"]]],[11,"not","","",77,[[],["self"]]],[11,"not","","",78,[[],["self"]]],[11,"not","","",79,[[],["self"]]],[11,"not","","",80,[[],["self"]]],[11,"not","","",81,[[],["self"]]],[11,"not","","",83,[[],["self"]]],[11,"not","","",84,[[],["self"]]],[11,"not","","",85,[[],["self"]]],[11,"not","","",87,[[],["self"]]],[11,"not","","",88,[[],["self"]]],[11,"not","","",89,[[],["self"]]],[11,"not","","",90,[[],["self"]]],[11,"not","","",48,[[],["self"]]],[11,"not","","",49,[[],["self"]]],[11,"not","","",50,[[],["self"]]],[11,"not","","",71,[[],["self"]]],[11,"not","","",72,[[],["self"]]],[11,"not","","",73,[[],["self"]]],[11,"not","","",91,[[],["self"]]],[11,"not","","",92,[[],["self"]]],[11,"not","","",93,[[],["self"]]],[11,"bitand","","",15,[[],["self"]]],[11,"bitand","","",15,[[["i8"]],["self"]]],[11,"bitand","","",16,[[],["self"]]],[11,"bitand","","",16,[[["u8"]],["self"]]],[11,"bitand","","",17,[[],["self"]]],[11,"bitand","","",17,[[["bool"]],["self"]]],[11,"bitand","","",18,[[],["self"]]],[11,"bitand","","",18,[[["i8"]],["self"]]],[11,"bitand","","",19,[[],["self"]]],[11,"bitand","","",19,[[["u8"]],["self"]]],[11,"bitand","","",20,[[],["self"]]],[11,"bitand","","",20,[[["bool"]],["self"]]],[11,"bitand","","",21,[[],["self"]]],[11,"bitand","","",21,[[["i16"]],["self"]]],[11,"bitand","","",22,[[],["self"]]],[11,"bitand","","",22,[[["u16"]],["self"]]],[11,"bitand","","",23,[[],["self"]]],[11,"bitand","","",23,[[["bool"]],["self"]]],[11,"bitand","","",24,[[],["self"]]],[11,"bitand","","",24,[[["i8"]],["self"]]],[11,"bitand","","",25,[[],["self"]]],[11,"bitand","","",25,[[["u8"]],["self"]]],[11,"bitand","","",26,[[],["self"]]],[11,"bitand","","",26,[[["bool"]],["self"]]],[11,"bitand","","",27,[[],["self"]]],[11,"bitand","","",27,[[["i16"]],["self"]]],[11,"bitand","","",28,[[],["self"]]],[11,"bitand","","",28,[[["u16"]],["self"]]],[11,"bitand","","",29,[[],["self"]]],[11,"bitand","","",29,[[["bool"]],["self"]]],[11,"bitand","","",30,[[],["self"]]],[11,"bitand","","",30,[[["i32"]],["self"]]],[11,"bitand","","",31,[[],["self"]]],[11,"bitand","","",31,[[["u32"]],["self"]]],[11,"bitand","","",33,[[],["self"]]],[11,"bitand","","",33,[[["bool"]],["self"]]],[11,"bitand","","",34,[[],["self"]]],[11,"bitand","","",34,[[["i8"]],["self"]]],[11,"bitand","","",35,[[],["self"]]],[11,"bitand","","",35,[[["u8"]],["self"]]],[11,"bitand","","",36,[[],["self"]]],[11,"bitand","","",36,[[["bool"]],["self"]]],[11,"bitand","","",37,[[],["self"]]],[11,"bitand","","",37,[[["i16"]],["self"]]],[11,"bitand","","",38,[[],["self"]]],[11,"bitand","","",38,[[["u16"]],["self"]]],[11,"bitand","","",39,[[],["self"]]],[11,"bitand","","",39,[[["bool"]],["self"]]],[11,"bitand","","",40,[[],["self"]]],[11,"bitand","","",40,[[["i32"]],["self"]]],[11,"bitand","","",41,[[],["self"]]],[11,"bitand","","",41,[[["u32"]],["self"]]],[11,"bitand","","",43,[[],["self"]]],[11,"bitand","","",43,[[["bool"]],["self"]]],[11,"bitand","","",44,[[],["self"]]],[11,"bitand","","",44,[[["i64"]],["self"]]],[11,"bitand","","",45,[[],["self"]]],[11,"bitand","","",45,[[["u64"]],["self"]]],[11,"bitand","","",47,[[],["self"]]],[11,"bitand","","",47,[[["bool"]],["self"]]],[11,"bitand","","",51,[[],["self"]]],[11,"bitand","","",51,[[["i128"]],["self"]]],[11,"bitand","","",52,[[],["self"]]],[11,"bitand","","",52,[[["u128"]],["self"]]],[11,"bitand","","",53,[[],["self"]]],[11,"bitand","","",53,[[["bool"]],["self"]]],[11,"bitand","","",54,[[],["self"]]],[11,"bitand","","",54,[[["i8"]],["self"]]],[11,"bitand","","",55,[[],["self"]]],[11,"bitand","","",55,[[["u8"]],["self"]]],[11,"bitand","","",56,[[],["self"]]],[11,"bitand","","",56,[[["bool"]],["self"]]],[11,"bitand","","",57,[[],["self"]]],[11,"bitand","","",57,[[["i16"]],["self"]]],[11,"bitand","","",58,[[],["self"]]],[11,"bitand","","",58,[[["u16"]],["self"]]],[11,"bitand","","",59,[[],["self"]]],[11,"bitand","","",59,[[["bool"]],["self"]]],[11,"bitand","","",60,[[],["self"]]],[11,"bitand","","",60,[[["i32"]],["self"]]],[11,"bitand","","",61,[[],["self"]]],[11,"bitand","","",61,[[["u32"]],["self"]]],[11,"bitand","","",63,[[],["self"]]],[11,"bitand","","",63,[[["bool"]],["self"]]],[11,"bitand","","",64,[[],["self"]]],[11,"bitand","","",64,[[["i64"]],["self"]]],[11,"bitand","","",65,[[],["self"]]],[11,"bitand","","",65,[[["u64"]],["self"]]],[11,"bitand","","",67,[[],["self"]]],[11,"bitand","","",67,[[["bool"]],["self"]]],[11,"bitand","","",68,[[],["self"]]],[11,"bitand","","",68,[[["i128"]],["self"]]],[11,"bitand","","",69,[[],["self"]]],[11,"bitand","","",69,[[["u128"]],["self"]]],[11,"bitand","","",70,[[],["self"]]],[11,"bitand","","",70,[[["bool"]],["self"]]],[11,"bitand","","",74,[[],["self"]]],[11,"bitand","","",74,[[["i8"]],["self"]]],[11,"bitand","","",75,[[],["self"]]],[11,"bitand","","",75,[[["u8"]],["self"]]],[11,"bitand","","",76,[[],["self"]]],[11,"bitand","","",76,[[["bool"]],["self"]]],[11,"bitand","","",77,[[],["self"]]],[11,"bitand","","",77,[[["i16"]],["self"]]],[11,"bitand","","",78,[[],["self"]]],[11,"bitand","","",78,[[["u16"]],["self"]]],[11,"bitand","","",79,[[],["self"]]],[11,"bitand","","",79,[[["bool"]],["self"]]],[11,"bitand","","",80,[[],["self"]]],[11,"bitand","","",80,[[["i32"]],["self"]]],[11,"bitand","","",81,[[],["self"]]],[11,"bitand","","",81,[[["u32"]],["self"]]],[11,"bitand","","",83,[[],["self"]]],[11,"bitand","","",83,[[["bool"]],["self"]]],[11,"bitand","","",84,[[],["self"]]],[11,"bitand","","",84,[[["i64"]],["self"]]],[11,"bitand","","",85,[[],["self"]]],[11,"bitand","","",85,[[["u64"]],["self"]]],[11,"bitand","","",87,[[],["self"]]],[11,"bitand","","",87,[[["bool"]],["self"]]],[11,"bitand","","",88,[[],["self"]]],[11,"bitand","","",88,[[["i128"]],["self"]]],[11,"bitand","","",89,[[],["self"]]],[11,"bitand","","",89,[[["u128"]],["self"]]],[11,"bitand","","",90,[[],["self"]]],[11,"bitand","","",90,[[["bool"]],["self"]]],[11,"bitand","","",48,[[],["self"]]],[11,"bitand","","",48,[[["isize"]],["self"]]],[11,"bitand","","",49,[[],["self"]]],[11,"bitand","","",49,[[["usize"]],["self"]]],[11,"bitand","","",50,[[],["self"]]],[11,"bitand","","",50,[[["bool"]],["self"]]],[11,"bitand","","",71,[[],["self"]]],[11,"bitand","","",71,[[["isize"]],["self"]]],[11,"bitand","","",72,[[],["self"]]],[11,"bitand","","",72,[[["usize"]],["self"]]],[11,"bitand","","",73,[[],["self"]]],[11,"bitand","","",73,[[["bool"]],["self"]]],[11,"bitand","","",91,[[],["self"]]],[11,"bitand","","",91,[[["isize"]],["self"]]],[11,"bitand","","",92,[[],["self"]]],[11,"bitand","","",92,[[["usize"]],["self"]]],[11,"bitand","","",93,[[],["self"]]],[11,"bitand","","",93,[[["bool"]],["self"]]],[11,"bitor","","",15,[[],["self"]]],[11,"bitor","","",15,[[["i8"]],["self"]]],[11,"bitor","","",16,[[],["self"]]],[11,"bitor","","",16,[[["u8"]],["self"]]],[11,"bitor","","",17,[[],["self"]]],[11,"bitor","","",17,[[["bool"]],["self"]]],[11,"bitor","","",18,[[],["self"]]],[11,"bitor","","",18,[[["i8"]],["self"]]],[11,"bitor","","",19,[[],["self"]]],[11,"bitor","","",19,[[["u8"]],["self"]]],[11,"bitor","","",20,[[],["self"]]],[11,"bitor","","",20,[[["bool"]],["self"]]],[11,"bitor","","",21,[[],["self"]]],[11,"bitor","","",21,[[["i16"]],["self"]]],[11,"bitor","","",22,[[],["self"]]],[11,"bitor","","",22,[[["u16"]],["self"]]],[11,"bitor","","",23,[[],["self"]]],[11,"bitor","","",23,[[["bool"]],["self"]]],[11,"bitor","","",24,[[],["self"]]],[11,"bitor","","",24,[[["i8"]],["self"]]],[11,"bitor","","",25,[[],["self"]]],[11,"bitor","","",25,[[["u8"]],["self"]]],[11,"bitor","","",26,[[],["self"]]],[11,"bitor","","",26,[[["bool"]],["self"]]],[11,"bitor","","",27,[[],["self"]]],[11,"bitor","","",27,[[["i16"]],["self"]]],[11,"bitor","","",28,[[],["self"]]],[11,"bitor","","",28,[[["u16"]],["self"]]],[11,"bitor","","",29,[[],["self"]]],[11,"bitor","","",29,[[["bool"]],["self"]]],[11,"bitor","","",30,[[],["self"]]],[11,"bitor","","",30,[[["i32"]],["self"]]],[11,"bitor","","",31,[[],["self"]]],[11,"bitor","","",31,[[["u32"]],["self"]]],[11,"bitor","","",33,[[],["self"]]],[11,"bitor","","",33,[[["bool"]],["self"]]],[11,"bitor","","",34,[[],["self"]]],[11,"bitor","","",34,[[["i8"]],["self"]]],[11,"bitor","","",35,[[],["self"]]],[11,"bitor","","",35,[[["u8"]],["self"]]],[11,"bitor","","",36,[[],["self"]]],[11,"bitor","","",36,[[["bool"]],["self"]]],[11,"bitor","","",37,[[],["self"]]],[11,"bitor","","",37,[[["i16"]],["self"]]],[11,"bitor","","",38,[[],["self"]]],[11,"bitor","","",38,[[["u16"]],["self"]]],[11,"bitor","","",39,[[],["self"]]],[11,"bitor","","",39,[[["bool"]],["self"]]],[11,"bitor","","",40,[[],["self"]]],[11,"bitor","","",40,[[["i32"]],["self"]]],[11,"bitor","","",41,[[],["self"]]],[11,"bitor","","",41,[[["u32"]],["self"]]],[11,"bitor","","",43,[[],["self"]]],[11,"bitor","","",43,[[["bool"]],["self"]]],[11,"bitor","","",44,[[],["self"]]],[11,"bitor","","",44,[[["i64"]],["self"]]],[11,"bitor","","",45,[[],["self"]]],[11,"bitor","","",45,[[["u64"]],["self"]]],[11,"bitor","","",47,[[],["self"]]],[11,"bitor","","",47,[[["bool"]],["self"]]],[11,"bitor","","",51,[[],["self"]]],[11,"bitor","","",51,[[["i128"]],["self"]]],[11,"bitor","","",52,[[],["self"]]],[11,"bitor","","",52,[[["u128"]],["self"]]],[11,"bitor","","",53,[[],["self"]]],[11,"bitor","","",53,[[["bool"]],["self"]]],[11,"bitor","","",54,[[],["self"]]],[11,"bitor","","",54,[[["i8"]],["self"]]],[11,"bitor","","",55,[[],["self"]]],[11,"bitor","","",55,[[["u8"]],["self"]]],[11,"bitor","","",56,[[],["self"]]],[11,"bitor","","",56,[[["bool"]],["self"]]],[11,"bitor","","",57,[[],["self"]]],[11,"bitor","","",57,[[["i16"]],["self"]]],[11,"bitor","","",58,[[],["self"]]],[11,"bitor","","",58,[[["u16"]],["self"]]],[11,"bitor","","",59,[[],["self"]]],[11,"bitor","","",59,[[["bool"]],["self"]]],[11,"bitor","","",60,[[],["self"]]],[11,"bitor","","",60,[[["i32"]],["self"]]],[11,"bitor","","",61,[[],["self"]]],[11,"bitor","","",61,[[["u32"]],["self"]]],[11,"bitor","","",63,[[],["self"]]],[11,"bitor","","",63,[[["bool"]],["self"]]],[11,"bitor","","",64,[[],["self"]]],[11,"bitor","","",64,[[["i64"]],["self"]]],[11,"bitor","","",65,[[],["self"]]],[11,"bitor","","",65,[[["u64"]],["self"]]],[11,"bitor","","",67,[[],["self"]]],[11,"bitor","","",67,[[["bool"]],["self"]]],[11,"bitor","","",68,[[],["self"]]],[11,"bitor","","",68,[[["i128"]],["self"]]],[11,"bitor","","",69,[[],["self"]]],[11,"bitor","","",69,[[["u128"]],["self"]]],[11,"bitor","","",70,[[],["self"]]],[11,"bitor","","",70,[[["bool"]],["self"]]],[11,"bitor","","",74,[[],["self"]]],[11,"bitor","","",74,[[["i8"]],["self"]]],[11,"bitor","","",75,[[],["self"]]],[11,"bitor","","",75,[[["u8"]],["self"]]],[11,"bitor","","",76,[[],["self"]]],[11,"bitor","","",76,[[["bool"]],["self"]]],[11,"bitor","","",77,[[],["self"]]],[11,"bitor","","",77,[[["i16"]],["self"]]],[11,"bitor","","",78,[[],["self"]]],[11,"bitor","","",78,[[["u16"]],["self"]]],[11,"bitor","","",79,[[],["self"]]],[11,"bitor","","",79,[[["bool"]],["self"]]],[11,"bitor","","",80,[[],["self"]]],[11,"bitor","","",80,[[["i32"]],["self"]]],[11,"bitor","","",81,[[],["self"]]],[11,"bitor","","",81,[[["u32"]],["self"]]],[11,"bitor","","",83,[[],["self"]]],[11,"bitor","","",83,[[["bool"]],["self"]]],[11,"bitor","","",84,[[],["self"]]],[11,"bitor","","",84,[[["i64"]],["self"]]],[11,"bitor","","",85,[[],["self"]]],[11,"bitor","","",85,[[["u64"]],["self"]]],[11,"bitor","","",87,[[],["self"]]],[11,"bitor","","",87,[[["bool"]],["self"]]],[11,"bitor","","",88,[[],["self"]]],[11,"bitor","","",88,[[["i128"]],["self"]]],[11,"bitor","","",89,[[],["self"]]],[11,"bitor","","",89,[[["u128"]],["self"]]],[11,"bitor","","",90,[[],["self"]]],[11,"bitor","","",90,[[["bool"]],["self"]]],[11,"bitor","","",48,[[],["self"]]],[11,"bitor","","",48,[[["isize"]],["self"]]],[11,"bitor","","",49,[[],["self"]]],[11,"bitor","","",49,[[["usize"]],["self"]]],[11,"bitor","","",50,[[],["self"]]],[11,"bitor","","",50,[[["bool"]],["self"]]],[11,"bitor","","",71,[[],["self"]]],[11,"bitor","","",71,[[["isize"]],["self"]]],[11,"bitor","","",72,[[],["self"]]],[11,"bitor","","",72,[[["usize"]],["self"]]],[11,"bitor","","",73,[[],["self"]]],[11,"bitor","","",73,[[["bool"]],["self"]]],[11,"bitor","","",91,[[],["self"]]],[11,"bitor","","",91,[[["isize"]],["self"]]],[11,"bitor","","",92,[[],["self"]]],[11,"bitor","","",92,[[["usize"]],["self"]]],[11,"bitor","","",93,[[],["self"]]],[11,"bitor","","",93,[[["bool"]],["self"]]],[11,"bitxor","","",15,[[],["self"]]],[11,"bitxor","","",15,[[["i8"]],["self"]]],[11,"bitxor","","",16,[[],["self"]]],[11,"bitxor","","",16,[[["u8"]],["self"]]],[11,"bitxor","","",17,[[],["self"]]],[11,"bitxor","","",17,[[["bool"]],["self"]]],[11,"bitxor","","",18,[[],["self"]]],[11,"bitxor","","",18,[[["i8"]],["self"]]],[11,"bitxor","","",19,[[],["self"]]],[11,"bitxor","","",19,[[["u8"]],["self"]]],[11,"bitxor","","",20,[[],["self"]]],[11,"bitxor","","",20,[[["bool"]],["self"]]],[11,"bitxor","","",21,[[],["self"]]],[11,"bitxor","","",21,[[["i16"]],["self"]]],[11,"bitxor","","",22,[[],["self"]]],[11,"bitxor","","",22,[[["u16"]],["self"]]],[11,"bitxor","","",23,[[],["self"]]],[11,"bitxor","","",23,[[["bool"]],["self"]]],[11,"bitxor","","",24,[[],["self"]]],[11,"bitxor","","",24,[[["i8"]],["self"]]],[11,"bitxor","","",25,[[],["self"]]],[11,"bitxor","","",25,[[["u8"]],["self"]]],[11,"bitxor","","",26,[[],["self"]]],[11,"bitxor","","",26,[[["bool"]],["self"]]],[11,"bitxor","","",27,[[],["self"]]],[11,"bitxor","","",27,[[["i16"]],["self"]]],[11,"bitxor","","",28,[[],["self"]]],[11,"bitxor","","",28,[[["u16"]],["self"]]],[11,"bitxor","","",29,[[],["self"]]],[11,"bitxor","","",29,[[["bool"]],["self"]]],[11,"bitxor","","",30,[[],["self"]]],[11,"bitxor","","",30,[[["i32"]],["self"]]],[11,"bitxor","","",31,[[],["self"]]],[11,"bitxor","","",31,[[["u32"]],["self"]]],[11,"bitxor","","",33,[[],["self"]]],[11,"bitxor","","",33,[[["bool"]],["self"]]],[11,"bitxor","","",34,[[],["self"]]],[11,"bitxor","","",34,[[["i8"]],["self"]]],[11,"bitxor","","",35,[[],["self"]]],[11,"bitxor","","",35,[[["u8"]],["self"]]],[11,"bitxor","","",36,[[],["self"]]],[11,"bitxor","","",36,[[["bool"]],["self"]]],[11,"bitxor","","",37,[[],["self"]]],[11,"bitxor","","",37,[[["i16"]],["self"]]],[11,"bitxor","","",38,[[],["self"]]],[11,"bitxor","","",38,[[["u16"]],["self"]]],[11,"bitxor","","",39,[[],["self"]]],[11,"bitxor","","",39,[[["bool"]],["self"]]],[11,"bitxor","","",40,[[],["self"]]],[11,"bitxor","","",40,[[["i32"]],["self"]]],[11,"bitxor","","",41,[[],["self"]]],[11,"bitxor","","",41,[[["u32"]],["self"]]],[11,"bitxor","","",43,[[],["self"]]],[11,"bitxor","","",43,[[["bool"]],["self"]]],[11,"bitxor","","",44,[[],["self"]]],[11,"bitxor","","",44,[[["i64"]],["self"]]],[11,"bitxor","","",45,[[],["self"]]],[11,"bitxor","","",45,[[["u64"]],["self"]]],[11,"bitxor","","",47,[[],["self"]]],[11,"bitxor","","",47,[[["bool"]],["self"]]],[11,"bitxor","","",51,[[],["self"]]],[11,"bitxor","","",51,[[["i128"]],["self"]]],[11,"bitxor","","",52,[[],["self"]]],[11,"bitxor","","",52,[[["u128"]],["self"]]],[11,"bitxor","","",53,[[],["self"]]],[11,"bitxor","","",53,[[["bool"]],["self"]]],[11,"bitxor","","",54,[[],["self"]]],[11,"bitxor","","",54,[[["i8"]],["self"]]],[11,"bitxor","","",55,[[],["self"]]],[11,"bitxor","","",55,[[["u8"]],["self"]]],[11,"bitxor","","",56,[[],["self"]]],[11,"bitxor","","",56,[[["bool"]],["self"]]],[11,"bitxor","","",57,[[],["self"]]],[11,"bitxor","","",57,[[["i16"]],["self"]]],[11,"bitxor","","",58,[[],["self"]]],[11,"bitxor","","",58,[[["u16"]],["self"]]],[11,"bitxor","","",59,[[],["self"]]],[11,"bitxor","","",59,[[["bool"]],["self"]]],[11,"bitxor","","",60,[[],["self"]]],[11,"bitxor","","",60,[[["i32"]],["self"]]],[11,"bitxor","","",61,[[],["self"]]],[11,"bitxor","","",61,[[["u32"]],["self"]]],[11,"bitxor","","",63,[[],["self"]]],[11,"bitxor","","",63,[[["bool"]],["self"]]],[11,"bitxor","","",64,[[],["self"]]],[11,"bitxor","","",64,[[["i64"]],["self"]]],[11,"bitxor","","",65,[[],["self"]]],[11,"bitxor","","",65,[[["u64"]],["self"]]],[11,"bitxor","","",67,[[],["self"]]],[11,"bitxor","","",67,[[["bool"]],["self"]]],[11,"bitxor","","",68,[[],["self"]]],[11,"bitxor","","",68,[[["i128"]],["self"]]],[11,"bitxor","","",69,[[],["self"]]],[11,"bitxor","","",69,[[["u128"]],["self"]]],[11,"bitxor","","",70,[[],["self"]]],[11,"bitxor","","",70,[[["bool"]],["self"]]],[11,"bitxor","","",74,[[],["self"]]],[11,"bitxor","","",74,[[["i8"]],["self"]]],[11,"bitxor","","",75,[[],["self"]]],[11,"bitxor","","",75,[[["u8"]],["self"]]],[11,"bitxor","","",76,[[],["self"]]],[11,"bitxor","","",76,[[["bool"]],["self"]]],[11,"bitxor","","",77,[[],["self"]]],[11,"bitxor","","",77,[[["i16"]],["self"]]],[11,"bitxor","","",78,[[],["self"]]],[11,"bitxor","","",78,[[["u16"]],["self"]]],[11,"bitxor","","",79,[[],["self"]]],[11,"bitxor","","",79,[[["bool"]],["self"]]],[11,"bitxor","","",80,[[],["self"]]],[11,"bitxor","","",80,[[["i32"]],["self"]]],[11,"bitxor","","",81,[[],["self"]]],[11,"bitxor","","",81,[[["u32"]],["self"]]],[11,"bitxor","","",83,[[],["self"]]],[11,"bitxor","","",83,[[["bool"]],["self"]]],[11,"bitxor","","",84,[[],["self"]]],[11,"bitxor","","",84,[[["i64"]],["self"]]],[11,"bitxor","","",85,[[],["self"]]],[11,"bitxor","","",85,[[["u64"]],["self"]]],[11,"bitxor","","",87,[[],["self"]]],[11,"bitxor","","",87,[[["bool"]],["self"]]],[11,"bitxor","","",88,[[],["self"]]],[11,"bitxor","","",88,[[["i128"]],["self"]]],[11,"bitxor","","",89,[[],["self"]]],[11,"bitxor","","",89,[[["u128"]],["self"]]],[11,"bitxor","","",90,[[],["self"]]],[11,"bitxor","","",90,[[["bool"]],["self"]]],[11,"bitxor","","",48,[[],["self"]]],[11,"bitxor","","",48,[[["isize"]],["self"]]],[11,"bitxor","","",49,[[],["self"]]],[11,"bitxor","","",49,[[["usize"]],["self"]]],[11,"bitxor","","",50,[[],["self"]]],[11,"bitxor","","",50,[[["bool"]],["self"]]],[11,"bitxor","","",71,[[],["self"]]],[11,"bitxor","","",71,[[["isize"]],["self"]]],[11,"bitxor","","",72,[[],["self"]]],[11,"bitxor","","",72,[[["usize"]],["self"]]],[11,"bitxor","","",73,[[],["self"]]],[11,"bitxor","","",73,[[["bool"]],["self"]]],[11,"bitxor","","",91,[[],["self"]]],[11,"bitxor","","",91,[[["isize"]],["self"]]],[11,"bitxor","","",92,[[],["self"]]],[11,"bitxor","","",92,[[["usize"]],["self"]]],[11,"bitxor","","",93,[[],["self"]]],[11,"bitxor","","",93,[[["bool"]],["self"]]],[11,"shl","","",15,[[],["self"]]],[11,"shl","","",15,[[["u32"]],["self"]]],[11,"shl","","",16,[[],["self"]]],[11,"shl","","",16,[[["u32"]],["self"]]],[11,"shl","","",18,[[],["self"]]],[11,"shl","","",18,[[["u32"]],["self"]]],[11,"shl","","",19,[[],["self"]]],[11,"shl","","",19,[[["u32"]],["self"]]],[11,"shl","","",21,[[],["self"]]],[11,"shl","","",21,[[["u32"]],["self"]]],[11,"shl","","",22,[[],["self"]]],[11,"shl","","",22,[[["u32"]],["self"]]],[11,"shl","","",24,[[],["self"]]],[11,"shl","","",24,[[["u32"]],["self"]]],[11,"shl","","",25,[[],["self"]]],[11,"shl","","",25,[[["u32"]],["self"]]],[11,"shl","","",27,[[],["self"]]],[11,"shl","","",27,[[["u32"]],["self"]]],[11,"shl","","",28,[[],["self"]]],[11,"shl","","",28,[[["u32"]],["self"]]],[11,"shl","","",30,[[],["self"]]],[11,"shl","","",30,[[["u32"]],["self"]]],[11,"shl","","",31,[[],["self"]]],[11,"shl","","",31,[[["u32"]],["self"]]],[11,"shl","","",34,[[],["self"]]],[11,"shl","","",34,[[["u32"]],["self"]]],[11,"shl","","",35,[[],["self"]]],[11,"shl","","",35,[[["u32"]],["self"]]],[11,"shl","","",37,[[],["self"]]],[11,"shl","","",37,[[["u32"]],["self"]]],[11,"shl","","",38,[[],["self"]]],[11,"shl","","",38,[[["u32"]],["self"]]],[11,"shl","","",40,[[],["self"]]],[11,"shl","","",40,[[["u32"]],["self"]]],[11,"shl","","",41,[[],["self"]]],[11,"shl","","",41,[[["u32"]],["self"]]],[11,"shl","","",44,[[],["self"]]],[11,"shl","","",44,[[["u32"]],["self"]]],[11,"shl","","",45,[[],["self"]]],[11,"shl","","",45,[[["u32"]],["self"]]],[11,"shl","","",51,[[],["self"]]],[11,"shl","","",51,[[["u32"]],["self"]]],[11,"shl","","",52,[[],["self"]]],[11,"shl","","",52,[[["u32"]],["self"]]],[11,"shl","","",54,[[],["self"]]],[11,"shl","","",54,[[["u32"]],["self"]]],[11,"shl","","",55,[[],["self"]]],[11,"shl","","",55,[[["u32"]],["self"]]],[11,"shl","","",57,[[],["self"]]],[11,"shl","","",57,[[["u32"]],["self"]]],[11,"shl","","",58,[[],["self"]]],[11,"shl","","",58,[[["u32"]],["self"]]],[11,"shl","","",60,[[],["self"]]],[11,"shl","","",60,[[["u32"]],["self"]]],[11,"shl","","",61,[[],["self"]]],[11,"shl","","",61,[[["u32"]],["self"]]],[11,"shl","","",64,[[],["self"]]],[11,"shl","","",64,[[["u32"]],["self"]]],[11,"shl","","",65,[[],["self"]]],[11,"shl","","",65,[[["u32"]],["self"]]],[11,"shl","","",68,[[],["self"]]],[11,"shl","","",68,[[["u32"]],["self"]]],[11,"shl","","",69,[[],["self"]]],[11,"shl","","",69,[[["u32"]],["self"]]],[11,"shl","","",74,[[],["self"]]],[11,"shl","","",74,[[["u32"]],["self"]]],[11,"shl","","",75,[[],["self"]]],[11,"shl","","",75,[[["u32"]],["self"]]],[11,"shl","","",77,[[],["self"]]],[11,"shl","","",77,[[["u32"]],["self"]]],[11,"shl","","",78,[[],["self"]]],[11,"shl","","",78,[[["u32"]],["self"]]],[11,"shl","","",80,[[],["self"]]],[11,"shl","","",80,[[["u32"]],["self"]]],[11,"shl","","",81,[[],["self"]]],[11,"shl","","",81,[[["u32"]],["self"]]],[11,"shl","","",84,[[],["self"]]],[11,"shl","","",84,[[["u32"]],["self"]]],[11,"shl","","",85,[[],["self"]]],[11,"shl","","",85,[[["u32"]],["self"]]],[11,"shl","","",88,[[],["self"]]],[11,"shl","","",88,[[["u32"]],["self"]]],[11,"shl","","",89,[[],["self"]]],[11,"shl","","",89,[[["u32"]],["self"]]],[11,"shl","","",48,[[],["self"]]],[11,"shl","","",48,[[["u32"]],["self"]]],[11,"shl","","",49,[[],["self"]]],[11,"shl","","",49,[[["u32"]],["self"]]],[11,"shl","","",71,[[],["self"]]],[11,"shl","","",71,[[["u32"]],["self"]]],[11,"shl","","",72,[[],["self"]]],[11,"shl","","",72,[[["u32"]],["self"]]],[11,"shl","","",91,[[],["self"]]],[11,"shl","","",91,[[["u32"]],["self"]]],[11,"shl","","",92,[[],["self"]]],[11,"shl","","",92,[[["u32"]],["self"]]],[11,"shr","","",15,[[],["self"]]],[11,"shr","","",15,[[["u32"]],["self"]]],[11,"shr","","",16,[[],["self"]]],[11,"shr","","",16,[[["u32"]],["self"]]],[11,"shr","","",18,[[],["self"]]],[11,"shr","","",18,[[["u32"]],["self"]]],[11,"shr","","",19,[[],["self"]]],[11,"shr","","",19,[[["u32"]],["self"]]],[11,"shr","","",21,[[],["self"]]],[11,"shr","","",21,[[["u32"]],["self"]]],[11,"shr","","",22,[[],["self"]]],[11,"shr","","",22,[[["u32"]],["self"]]],[11,"shr","","",24,[[],["self"]]],[11,"shr","","",24,[[["u32"]],["self"]]],[11,"shr","","",25,[[],["self"]]],[11,"shr","","",25,[[["u32"]],["self"]]],[11,"shr","","",27,[[],["self"]]],[11,"shr","","",27,[[["u32"]],["self"]]],[11,"shr","","",28,[[],["self"]]],[11,"shr","","",28,[[["u32"]],["self"]]],[11,"shr","","",30,[[],["self"]]],[11,"shr","","",30,[[["u32"]],["self"]]],[11,"shr","","",31,[[],["self"]]],[11,"shr","","",31,[[["u32"]],["self"]]],[11,"shr","","",34,[[],["self"]]],[11,"shr","","",34,[[["u32"]],["self"]]],[11,"shr","","",35,[[],["self"]]],[11,"shr","","",35,[[["u32"]],["self"]]],[11,"shr","","",37,[[],["self"]]],[11,"shr","","",37,[[["u32"]],["self"]]],[11,"shr","","",38,[[],["self"]]],[11,"shr","","",38,[[["u32"]],["self"]]],[11,"shr","","",40,[[],["self"]]],[11,"shr","","",40,[[["u32"]],["self"]]],[11,"shr","","",41,[[],["self"]]],[11,"shr","","",41,[[["u32"]],["self"]]],[11,"shr","","",44,[[],["self"]]],[11,"shr","","",44,[[["u32"]],["self"]]],[11,"shr","","",45,[[],["self"]]],[11,"shr","","",45,[[["u32"]],["self"]]],[11,"shr","","",51,[[],["self"]]],[11,"shr","","",51,[[["u32"]],["self"]]],[11,"shr","","",52,[[],["self"]]],[11,"shr","","",52,[[["u32"]],["self"]]],[11,"shr","","",54,[[],["self"]]],[11,"shr","","",54,[[["u32"]],["self"]]],[11,"shr","","",55,[[],["self"]]],[11,"shr","","",55,[[["u32"]],["self"]]],[11,"shr","","",57,[[],["self"]]],[11,"shr","","",57,[[["u32"]],["self"]]],[11,"shr","","",58,[[],["self"]]],[11,"shr","","",58,[[["u32"]],["self"]]],[11,"shr","","",60,[[],["self"]]],[11,"shr","","",60,[[["u32"]],["self"]]],[11,"shr","","",61,[[],["self"]]],[11,"shr","","",61,[[["u32"]],["self"]]],[11,"shr","","",64,[[],["self"]]],[11,"shr","","",64,[[["u32"]],["self"]]],[11,"shr","","",65,[[],["self"]]],[11,"shr","","",65,[[["u32"]],["self"]]],[11,"shr","","",68,[[],["self"]]],[11,"shr","","",68,[[["u32"]],["self"]]],[11,"shr","","",69,[[],["self"]]],[11,"shr","","",69,[[["u32"]],["self"]]],[11,"shr","","",74,[[],["self"]]],[11,"shr","","",74,[[["u32"]],["self"]]],[11,"shr","","",75,[[],["self"]]],[11,"shr","","",75,[[["u32"]],["self"]]],[11,"shr","","",77,[[],["self"]]],[11,"shr","","",77,[[["u32"]],["self"]]],[11,"shr","","",78,[[],["self"]]],[11,"shr","","",78,[[["u32"]],["self"]]],[11,"shr","","",80,[[],["self"]]],[11,"shr","","",80,[[["u32"]],["self"]]],[11,"shr","","",81,[[],["self"]]],[11,"shr","","",81,[[["u32"]],["self"]]],[11,"shr","","",84,[[],["self"]]],[11,"shr","","",84,[[["u32"]],["self"]]],[11,"shr","","",85,[[],["self"]]],[11,"shr","","",85,[[["u32"]],["self"]]],[11,"shr","","",88,[[],["self"]]],[11,"shr","","",88,[[["u32"]],["self"]]],[11,"shr","","",89,[[],["self"]]],[11,"shr","","",89,[[["u32"]],["self"]]],[11,"shr","","",48,[[],["self"]]],[11,"shr","","",48,[[["u32"]],["self"]]],[11,"shr","","",49,[[],["self"]]],[11,"shr","","",49,[[["u32"]],["self"]]],[11,"shr","","",71,[[],["self"]]],[11,"shr","","",71,[[["u32"]],["self"]]],[11,"shr","","",72,[[],["self"]]],[11,"shr","","",72,[[["u32"]],["self"]]],[11,"shr","","",91,[[],["self"]]],[11,"shr","","",91,[[["u32"]],["self"]]],[11,"shr","","",92,[[],["self"]]],[11,"shr","","",92,[[["u32"]],["self"]]],[11,"bitand_assign","","",15,[[["self"]]]],[11,"bitand_assign","","",15,[[["self"],["i8"]]]],[11,"bitand_assign","","",16,[[["self"]]]],[11,"bitand_assign","","",16,[[["self"],["u8"]]]],[11,"bitand_assign","","",17,[[["self"]]]],[11,"bitand_assign","","",17,[[["self"],["bool"]]]],[11,"bitand_assign","","",18,[[["self"]]]],[11,"bitand_assign","","",18,[[["self"],["i8"]]]],[11,"bitand_assign","","",19,[[["self"]]]],[11,"bitand_assign","","",19,[[["self"],["u8"]]]],[11,"bitand_assign","","",20,[[["self"]]]],[11,"bitand_assign","","",20,[[["self"],["bool"]]]],[11,"bitand_assign","","",21,[[["self"]]]],[11,"bitand_assign","","",21,[[["self"],["i16"]]]],[11,"bitand_assign","","",22,[[["self"]]]],[11,"bitand_assign","","",22,[[["u16"],["self"]]]],[11,"bitand_assign","","",23,[[["self"]]]],[11,"bitand_assign","","",23,[[["self"],["bool"]]]],[11,"bitand_assign","","",24,[[["self"]]]],[11,"bitand_assign","","",24,[[["self"],["i8"]]]],[11,"bitand_assign","","",25,[[["self"]]]],[11,"bitand_assign","","",25,[[["self"],["u8"]]]],[11,"bitand_assign","","",26,[[["self"]]]],[11,"bitand_assign","","",26,[[["self"],["bool"]]]],[11,"bitand_assign","","",27,[[["self"]]]],[11,"bitand_assign","","",27,[[["self"],["i16"]]]],[11,"bitand_assign","","",28,[[["self"]]]],[11,"bitand_assign","","",28,[[["u16"],["self"]]]],[11,"bitand_assign","","",29,[[["self"]]]],[11,"bitand_assign","","",29,[[["self"],["bool"]]]],[11,"bitand_assign","","",30,[[["self"]]]],[11,"bitand_assign","","",30,[[["self"],["i32"]]]],[11,"bitand_assign","","",31,[[["self"]]]],[11,"bitand_assign","","",31,[[["self"],["u32"]]]],[11,"bitand_assign","","",33,[[["self"]]]],[11,"bitand_assign","","",33,[[["self"],["bool"]]]],[11,"bitand_assign","","",34,[[["self"]]]],[11,"bitand_assign","","",34,[[["self"],["i8"]]]],[11,"bitand_assign","","",35,[[["self"]]]],[11,"bitand_assign","","",35,[[["self"],["u8"]]]],[11,"bitand_assign","","",36,[[["self"]]]],[11,"bitand_assign","","",36,[[["self"],["bool"]]]],[11,"bitand_assign","","",37,[[["self"]]]],[11,"bitand_assign","","",37,[[["self"],["i16"]]]],[11,"bitand_assign","","",38,[[["self"]]]],[11,"bitand_assign","","",38,[[["u16"],["self"]]]],[11,"bitand_assign","","",39,[[["self"]]]],[11,"bitand_assign","","",39,[[["self"],["bool"]]]],[11,"bitand_assign","","",40,[[["self"]]]],[11,"bitand_assign","","",40,[[["self"],["i32"]]]],[11,"bitand_assign","","",41,[[["self"]]]],[11,"bitand_assign","","",41,[[["self"],["u32"]]]],[11,"bitand_assign","","",43,[[["self"]]]],[11,"bitand_assign","","",43,[[["self"],["bool"]]]],[11,"bitand_assign","","",44,[[["self"]]]],[11,"bitand_assign","","",44,[[["i64"],["self"]]]],[11,"bitand_assign","","",45,[[["self"]]]],[11,"bitand_assign","","",45,[[["self"],["u64"]]]],[11,"bitand_assign","","",47,[[["self"]]]],[11,"bitand_assign","","",47,[[["self"],["bool"]]]],[11,"bitand_assign","","",51,[[["self"]]]],[11,"bitand_assign","","",51,[[["self"],["i128"]]]],[11,"bitand_assign","","",52,[[["self"]]]],[11,"bitand_assign","","",52,[[["self"],["u128"]]]],[11,"bitand_assign","","",53,[[["self"]]]],[11,"bitand_assign","","",53,[[["self"],["bool"]]]],[11,"bitand_assign","","",54,[[["self"]]]],[11,"bitand_assign","","",54,[[["self"],["i8"]]]],[11,"bitand_assign","","",55,[[["self"]]]],[11,"bitand_assign","","",55,[[["self"],["u8"]]]],[11,"bitand_assign","","",56,[[["self"]]]],[11,"bitand_assign","","",56,[[["self"],["bool"]]]],[11,"bitand_assign","","",57,[[["self"]]]],[11,"bitand_assign","","",57,[[["self"],["i16"]]]],[11,"bitand_assign","","",58,[[["self"]]]],[11,"bitand_assign","","",58,[[["u16"],["self"]]]],[11,"bitand_assign","","",59,[[["self"]]]],[11,"bitand_assign","","",59,[[["self"],["bool"]]]],[11,"bitand_assign","","",60,[[["self"]]]],[11,"bitand_assign","","",60,[[["self"],["i32"]]]],[11,"bitand_assign","","",61,[[["self"]]]],[11,"bitand_assign","","",61,[[["self"],["u32"]]]],[11,"bitand_assign","","",63,[[["self"]]]],[11,"bitand_assign","","",63,[[["self"],["bool"]]]],[11,"bitand_assign","","",64,[[["self"]]]],[11,"bitand_assign","","",64,[[["i64"],["self"]]]],[11,"bitand_assign","","",65,[[["self"]]]],[11,"bitand_assign","","",65,[[["self"],["u64"]]]],[11,"bitand_assign","","",67,[[["self"]]]],[11,"bitand_assign","","",67,[[["self"],["bool"]]]],[11,"bitand_assign","","",68,[[["self"]]]],[11,"bitand_assign","","",68,[[["self"],["i128"]]]],[11,"bitand_assign","","",69,[[["self"]]]],[11,"bitand_assign","","",69,[[["self"],["u128"]]]],[11,"bitand_assign","","",70,[[["self"]]]],[11,"bitand_assign","","",70,[[["self"],["bool"]]]],[11,"bitand_assign","","",74,[[["self"]]]],[11,"bitand_assign","","",74,[[["self"],["i8"]]]],[11,"bitand_assign","","",75,[[["self"]]]],[11,"bitand_assign","","",75,[[["self"],["u8"]]]],[11,"bitand_assign","","",76,[[["self"]]]],[11,"bitand_assign","","",76,[[["self"],["bool"]]]],[11,"bitand_assign","","",77,[[["self"]]]],[11,"bitand_assign","","",77,[[["self"],["i16"]]]],[11,"bitand_assign","","",78,[[["self"]]]],[11,"bitand_assign","","",78,[[["u16"],["self"]]]],[11,"bitand_assign","","",79,[[["self"]]]],[11,"bitand_assign","","",79,[[["self"],["bool"]]]],[11,"bitand_assign","","",80,[[["self"]]]],[11,"bitand_assign","","",80,[[["self"],["i32"]]]],[11,"bitand_assign","","",81,[[["self"]]]],[11,"bitand_assign","","",81,[[["self"],["u32"]]]],[11,"bitand_assign","","",83,[[["self"]]]],[11,"bitand_assign","","",83,[[["self"],["bool"]]]],[11,"bitand_assign","","",84,[[["self"]]]],[11,"bitand_assign","","",84,[[["i64"],["self"]]]],[11,"bitand_assign","","",85,[[["self"]]]],[11,"bitand_assign","","",85,[[["self"],["u64"]]]],[11,"bitand_assign","","",87,[[["self"]]]],[11,"bitand_assign","","",87,[[["self"],["bool"]]]],[11,"bitand_assign","","",88,[[["self"]]]],[11,"bitand_assign","","",88,[[["self"],["i128"]]]],[11,"bitand_assign","","",89,[[["self"]]]],[11,"bitand_assign","","",89,[[["self"],["u128"]]]],[11,"bitand_assign","","",90,[[["self"]]]],[11,"bitand_assign","","",90,[[["self"],["bool"]]]],[11,"bitand_assign","","",48,[[["self"]]]],[11,"bitand_assign","","",48,[[["isize"],["self"]]]],[11,"bitand_assign","","",49,[[["self"]]]],[11,"bitand_assign","","",49,[[["self"],["usize"]]]],[11,"bitand_assign","","",50,[[["self"]]]],[11,"bitand_assign","","",50,[[["self"],["bool"]]]],[11,"bitand_assign","","",71,[[["self"]]]],[11,"bitand_assign","","",71,[[["isize"],["self"]]]],[11,"bitand_assign","","",72,[[["self"]]]],[11,"bitand_assign","","",72,[[["self"],["usize"]]]],[11,"bitand_assign","","",73,[[["self"]]]],[11,"bitand_assign","","",73,[[["self"],["bool"]]]],[11,"bitand_assign","","",91,[[["self"]]]],[11,"bitand_assign","","",91,[[["isize"],["self"]]]],[11,"bitand_assign","","",92,[[["self"]]]],[11,"bitand_assign","","",92,[[["self"],["usize"]]]],[11,"bitand_assign","","",93,[[["self"]]]],[11,"bitand_assign","","",93,[[["self"],["bool"]]]],[11,"bitor_assign","","",15,[[["self"]]]],[11,"bitor_assign","","",15,[[["self"],["i8"]]]],[11,"bitor_assign","","",16,[[["self"]]]],[11,"bitor_assign","","",16,[[["self"],["u8"]]]],[11,"bitor_assign","","",17,[[["self"]]]],[11,"bitor_assign","","",17,[[["self"],["bool"]]]],[11,"bitor_assign","","",18,[[["self"]]]],[11,"bitor_assign","","",18,[[["self"],["i8"]]]],[11,"bitor_assign","","",19,[[["self"]]]],[11,"bitor_assign","","",19,[[["self"],["u8"]]]],[11,"bitor_assign","","",20,[[["self"]]]],[11,"bitor_assign","","",20,[[["self"],["bool"]]]],[11,"bitor_assign","","",21,[[["self"]]]],[11,"bitor_assign","","",21,[[["self"],["i16"]]]],[11,"bitor_assign","","",22,[[["self"]]]],[11,"bitor_assign","","",22,[[["u16"],["self"]]]],[11,"bitor_assign","","",23,[[["self"]]]],[11,"bitor_assign","","",23,[[["self"],["bool"]]]],[11,"bitor_assign","","",24,[[["self"]]]],[11,"bitor_assign","","",24,[[["self"],["i8"]]]],[11,"bitor_assign","","",25,[[["self"]]]],[11,"bitor_assign","","",25,[[["self"],["u8"]]]],[11,"bitor_assign","","",26,[[["self"]]]],[11,"bitor_assign","","",26,[[["self"],["bool"]]]],[11,"bitor_assign","","",27,[[["self"]]]],[11,"bitor_assign","","",27,[[["self"],["i16"]]]],[11,"bitor_assign","","",28,[[["self"]]]],[11,"bitor_assign","","",28,[[["u16"],["self"]]]],[11,"bitor_assign","","",29,[[["self"]]]],[11,"bitor_assign","","",29,[[["self"],["bool"]]]],[11,"bitor_assign","","",30,[[["self"]]]],[11,"bitor_assign","","",30,[[["self"],["i32"]]]],[11,"bitor_assign","","",31,[[["self"]]]],[11,"bitor_assign","","",31,[[["self"],["u32"]]]],[11,"bitor_assign","","",33,[[["self"]]]],[11,"bitor_assign","","",33,[[["self"],["bool"]]]],[11,"bitor_assign","","",34,[[["self"]]]],[11,"bitor_assign","","",34,[[["self"],["i8"]]]],[11,"bitor_assign","","",35,[[["self"]]]],[11,"bitor_assign","","",35,[[["self"],["u8"]]]],[11,"bitor_assign","","",36,[[["self"]]]],[11,"bitor_assign","","",36,[[["self"],["bool"]]]],[11,"bitor_assign","","",37,[[["self"]]]],[11,"bitor_assign","","",37,[[["self"],["i16"]]]],[11,"bitor_assign","","",38,[[["self"]]]],[11,"bitor_assign","","",38,[[["u16"],["self"]]]],[11,"bitor_assign","","",39,[[["self"]]]],[11,"bitor_assign","","",39,[[["self"],["bool"]]]],[11,"bitor_assign","","",40,[[["self"]]]],[11,"bitor_assign","","",40,[[["self"],["i32"]]]],[11,"bitor_assign","","",41,[[["self"]]]],[11,"bitor_assign","","",41,[[["self"],["u32"]]]],[11,"bitor_assign","","",43,[[["self"]]]],[11,"bitor_assign","","",43,[[["self"],["bool"]]]],[11,"bitor_assign","","",44,[[["self"]]]],[11,"bitor_assign","","",44,[[["i64"],["self"]]]],[11,"bitor_assign","","",45,[[["self"]]]],[11,"bitor_assign","","",45,[[["self"],["u64"]]]],[11,"bitor_assign","","",47,[[["self"]]]],[11,"bitor_assign","","",47,[[["self"],["bool"]]]],[11,"bitor_assign","","",51,[[["self"]]]],[11,"bitor_assign","","",51,[[["self"],["i128"]]]],[11,"bitor_assign","","",52,[[["self"]]]],[11,"bitor_assign","","",52,[[["self"],["u128"]]]],[11,"bitor_assign","","",53,[[["self"]]]],[11,"bitor_assign","","",53,[[["self"],["bool"]]]],[11,"bitor_assign","","",54,[[["self"]]]],[11,"bitor_assign","","",54,[[["self"],["i8"]]]],[11,"bitor_assign","","",55,[[["self"]]]],[11,"bitor_assign","","",55,[[["self"],["u8"]]]],[11,"bitor_assign","","",56,[[["self"]]]],[11,"bitor_assign","","",56,[[["self"],["bool"]]]],[11,"bitor_assign","","",57,[[["self"]]]],[11,"bitor_assign","","",57,[[["self"],["i16"]]]],[11,"bitor_assign","","",58,[[["self"]]]],[11,"bitor_assign","","",58,[[["u16"],["self"]]]],[11,"bitor_assign","","",59,[[["self"]]]],[11,"bitor_assign","","",59,[[["self"],["bool"]]]],[11,"bitor_assign","","",60,[[["self"]]]],[11,"bitor_assign","","",60,[[["self"],["i32"]]]],[11,"bitor_assign","","",61,[[["self"]]]],[11,"bitor_assign","","",61,[[["self"],["u32"]]]],[11,"bitor_assign","","",63,[[["self"]]]],[11,"bitor_assign","","",63,[[["self"],["bool"]]]],[11,"bitor_assign","","",64,[[["self"]]]],[11,"bitor_assign","","",64,[[["i64"],["self"]]]],[11,"bitor_assign","","",65,[[["self"]]]],[11,"bitor_assign","","",65,[[["self"],["u64"]]]],[11,"bitor_assign","","",67,[[["self"]]]],[11,"bitor_assign","","",67,[[["self"],["bool"]]]],[11,"bitor_assign","","",68,[[["self"]]]],[11,"bitor_assign","","",68,[[["self"],["i128"]]]],[11,"bitor_assign","","",69,[[["self"]]]],[11,"bitor_assign","","",69,[[["self"],["u128"]]]],[11,"bitor_assign","","",70,[[["self"]]]],[11,"bitor_assign","","",70,[[["self"],["bool"]]]],[11,"bitor_assign","","",74,[[["self"]]]],[11,"bitor_assign","","",74,[[["self"],["i8"]]]],[11,"bitor_assign","","",75,[[["self"]]]],[11,"bitor_assign","","",75,[[["self"],["u8"]]]],[11,"bitor_assign","","",76,[[["self"]]]],[11,"bitor_assign","","",76,[[["self"],["bool"]]]],[11,"bitor_assign","","",77,[[["self"]]]],[11,"bitor_assign","","",77,[[["self"],["i16"]]]],[11,"bitor_assign","","",78,[[["self"]]]],[11,"bitor_assign","","",78,[[["u16"],["self"]]]],[11,"bitor_assign","","",79,[[["self"]]]],[11,"bitor_assign","","",79,[[["self"],["bool"]]]],[11,"bitor_assign","","",80,[[["self"]]]],[11,"bitor_assign","","",80,[[["self"],["i32"]]]],[11,"bitor_assign","","",81,[[["self"]]]],[11,"bitor_assign","","",81,[[["self"],["u32"]]]],[11,"bitor_assign","","",83,[[["self"]]]],[11,"bitor_assign","","",83,[[["self"],["bool"]]]],[11,"bitor_assign","","",84,[[["self"]]]],[11,"bitor_assign","","",84,[[["i64"],["self"]]]],[11,"bitor_assign","","",85,[[["self"]]]],[11,"bitor_assign","","",85,[[["self"],["u64"]]]],[11,"bitor_assign","","",87,[[["self"]]]],[11,"bitor_assign","","",87,[[["self"],["bool"]]]],[11,"bitor_assign","","",88,[[["self"]]]],[11,"bitor_assign","","",88,[[["self"],["i128"]]]],[11,"bitor_assign","","",89,[[["self"]]]],[11,"bitor_assign","","",89,[[["self"],["u128"]]]],[11,"bitor_assign","","",90,[[["self"]]]],[11,"bitor_assign","","",90,[[["self"],["bool"]]]],[11,"bitor_assign","","",48,[[["self"]]]],[11,"bitor_assign","","",48,[[["isize"],["self"]]]],[11,"bitor_assign","","",49,[[["self"]]]],[11,"bitor_assign","","",49,[[["self"],["usize"]]]],[11,"bitor_assign","","",50,[[["self"]]]],[11,"bitor_assign","","",50,[[["self"],["bool"]]]],[11,"bitor_assign","","",71,[[["self"]]]],[11,"bitor_assign","","",71,[[["isize"],["self"]]]],[11,"bitor_assign","","",72,[[["self"]]]],[11,"bitor_assign","","",72,[[["self"],["usize"]]]],[11,"bitor_assign","","",73,[[["self"]]]],[11,"bitor_assign","","",73,[[["self"],["bool"]]]],[11,"bitor_assign","","",91,[[["self"]]]],[11,"bitor_assign","","",91,[[["isize"],["self"]]]],[11,"bitor_assign","","",92,[[["self"]]]],[11,"bitor_assign","","",92,[[["self"],["usize"]]]],[11,"bitor_assign","","",93,[[["self"]]]],[11,"bitor_assign","","",93,[[["self"],["bool"]]]],[11,"bitxor_assign","","",15,[[["self"]]]],[11,"bitxor_assign","","",15,[[["self"],["i8"]]]],[11,"bitxor_assign","","",16,[[["self"]]]],[11,"bitxor_assign","","",16,[[["self"],["u8"]]]],[11,"bitxor_assign","","",17,[[["self"]]]],[11,"bitxor_assign","","",17,[[["self"],["bool"]]]],[11,"bitxor_assign","","",18,[[["self"]]]],[11,"bitxor_assign","","",18,[[["self"],["i8"]]]],[11,"bitxor_assign","","",19,[[["self"]]]],[11,"bitxor_assign","","",19,[[["self"],["u8"]]]],[11,"bitxor_assign","","",20,[[["self"]]]],[11,"bitxor_assign","","",20,[[["self"],["bool"]]]],[11,"bitxor_assign","","",21,[[["self"]]]],[11,"bitxor_assign","","",21,[[["self"],["i16"]]]],[11,"bitxor_assign","","",22,[[["self"]]]],[11,"bitxor_assign","","",22,[[["u16"],["self"]]]],[11,"bitxor_assign","","",23,[[["self"]]]],[11,"bitxor_assign","","",23,[[["self"],["bool"]]]],[11,"bitxor_assign","","",24,[[["self"]]]],[11,"bitxor_assign","","",24,[[["self"],["i8"]]]],[11,"bitxor_assign","","",25,[[["self"]]]],[11,"bitxor_assign","","",25,[[["self"],["u8"]]]],[11,"bitxor_assign","","",26,[[["self"]]]],[11,"bitxor_assign","","",26,[[["self"],["bool"]]]],[11,"bitxor_assign","","",27,[[["self"]]]],[11,"bitxor_assign","","",27,[[["self"],["i16"]]]],[11,"bitxor_assign","","",28,[[["self"]]]],[11,"bitxor_assign","","",28,[[["u16"],["self"]]]],[11,"bitxor_assign","","",29,[[["self"]]]],[11,"bitxor_assign","","",29,[[["self"],["bool"]]]],[11,"bitxor_assign","","",30,[[["self"]]]],[11,"bitxor_assign","","",30,[[["self"],["i32"]]]],[11,"bitxor_assign","","",31,[[["self"]]]],[11,"bitxor_assign","","",31,[[["self"],["u32"]]]],[11,"bitxor_assign","","",33,[[["self"]]]],[11,"bitxor_assign","","",33,[[["self"],["bool"]]]],[11,"bitxor_assign","","",34,[[["self"]]]],[11,"bitxor_assign","","",34,[[["self"],["i8"]]]],[11,"bitxor_assign","","",35,[[["self"]]]],[11,"bitxor_assign","","",35,[[["self"],["u8"]]]],[11,"bitxor_assign","","",36,[[["self"]]]],[11,"bitxor_assign","","",36,[[["self"],["bool"]]]],[11,"bitxor_assign","","",37,[[["self"]]]],[11,"bitxor_assign","","",37,[[["self"],["i16"]]]],[11,"bitxor_assign","","",38,[[["self"]]]],[11,"bitxor_assign","","",38,[[["u16"],["self"]]]],[11,"bitxor_assign","","",39,[[["self"]]]],[11,"bitxor_assign","","",39,[[["self"],["bool"]]]],[11,"bitxor_assign","","",40,[[["self"]]]],[11,"bitxor_assign","","",40,[[["self"],["i32"]]]],[11,"bitxor_assign","","",41,[[["self"]]]],[11,"bitxor_assign","","",41,[[["self"],["u32"]]]],[11,"bitxor_assign","","",43,[[["self"]]]],[11,"bitxor_assign","","",43,[[["self"],["bool"]]]],[11,"bitxor_assign","","",44,[[["self"]]]],[11,"bitxor_assign","","",44,[[["i64"],["self"]]]],[11,"bitxor_assign","","",45,[[["self"]]]],[11,"bitxor_assign","","",45,[[["self"],["u64"]]]],[11,"bitxor_assign","","",47,[[["self"]]]],[11,"bitxor_assign","","",47,[[["self"],["bool"]]]],[11,"bitxor_assign","","",51,[[["self"]]]],[11,"bitxor_assign","","",51,[[["self"],["i128"]]]],[11,"bitxor_assign","","",52,[[["self"]]]],[11,"bitxor_assign","","",52,[[["self"],["u128"]]]],[11,"bitxor_assign","","",53,[[["self"]]]],[11,"bitxor_assign","","",53,[[["self"],["bool"]]]],[11,"bitxor_assign","","",54,[[["self"]]]],[11,"bitxor_assign","","",54,[[["self"],["i8"]]]],[11,"bitxor_assign","","",55,[[["self"]]]],[11,"bitxor_assign","","",55,[[["self"],["u8"]]]],[11,"bitxor_assign","","",56,[[["self"]]]],[11,"bitxor_assign","","",56,[[["self"],["bool"]]]],[11,"bitxor_assign","","",57,[[["self"]]]],[11,"bitxor_assign","","",57,[[["self"],["i16"]]]],[11,"bitxor_assign","","",58,[[["self"]]]],[11,"bitxor_assign","","",58,[[["u16"],["self"]]]],[11,"bitxor_assign","","",59,[[["self"]]]],[11,"bitxor_assign","","",59,[[["self"],["bool"]]]],[11,"bitxor_assign","","",60,[[["self"]]]],[11,"bitxor_assign","","",60,[[["self"],["i32"]]]],[11,"bitxor_assign","","",61,[[["self"]]]],[11,"bitxor_assign","","",61,[[["self"],["u32"]]]],[11,"bitxor_assign","","",63,[[["self"]]]],[11,"bitxor_assign","","",63,[[["self"],["bool"]]]],[11,"bitxor_assign","","",64,[[["self"]]]],[11,"bitxor_assign","","",64,[[["i64"],["self"]]]],[11,"bitxor_assign","","",65,[[["self"]]]],[11,"bitxor_assign","","",65,[[["self"],["u64"]]]],[11,"bitxor_assign","","",67,[[["self"]]]],[11,"bitxor_assign","","",67,[[["self"],["bool"]]]],[11,"bitxor_assign","","",68,[[["self"]]]],[11,"bitxor_assign","","",68,[[["self"],["i128"]]]],[11,"bitxor_assign","","",69,[[["self"]]]],[11,"bitxor_assign","","",69,[[["self"],["u128"]]]],[11,"bitxor_assign","","",70,[[["self"]]]],[11,"bitxor_assign","","",70,[[["self"],["bool"]]]],[11,"bitxor_assign","","",74,[[["self"]]]],[11,"bitxor_assign","","",74,[[["self"],["i8"]]]],[11,"bitxor_assign","","",75,[[["self"]]]],[11,"bitxor_assign","","",75,[[["self"],["u8"]]]],[11,"bitxor_assign","","",76,[[["self"]]]],[11,"bitxor_assign","","",76,[[["self"],["bool"]]]],[11,"bitxor_assign","","",77,[[["self"]]]],[11,"bitxor_assign","","",77,[[["self"],["i16"]]]],[11,"bitxor_assign","","",78,[[["self"]]]],[11,"bitxor_assign","","",78,[[["u16"],["self"]]]],[11,"bitxor_assign","","",79,[[["self"]]]],[11,"bitxor_assign","","",79,[[["self"],["bool"]]]],[11,"bitxor_assign","","",80,[[["self"]]]],[11,"bitxor_assign","","",80,[[["self"],["i32"]]]],[11,"bitxor_assign","","",81,[[["self"]]]],[11,"bitxor_assign","","",81,[[["self"],["u32"]]]],[11,"bitxor_assign","","",83,[[["self"]]]],[11,"bitxor_assign","","",83,[[["self"],["bool"]]]],[11,"bitxor_assign","","",84,[[["self"]]]],[11,"bitxor_assign","","",84,[[["i64"],["self"]]]],[11,"bitxor_assign","","",85,[[["self"]]]],[11,"bitxor_assign","","",85,[[["self"],["u64"]]]],[11,"bitxor_assign","","",87,[[["self"]]]],[11,"bitxor_assign","","",87,[[["self"],["bool"]]]],[11,"bitxor_assign","","",88,[[["self"]]]],[11,"bitxor_assign","","",88,[[["self"],["i128"]]]],[11,"bitxor_assign","","",89,[[["self"]]]],[11,"bitxor_assign","","",89,[[["self"],["u128"]]]],[11,"bitxor_assign","","",90,[[["self"]]]],[11,"bitxor_assign","","",90,[[["self"],["bool"]]]],[11,"bitxor_assign","","",48,[[["self"]]]],[11,"bitxor_assign","","",48,[[["isize"],["self"]]]],[11,"bitxor_assign","","",49,[[["self"]]]],[11,"bitxor_assign","","",49,[[["self"],["usize"]]]],[11,"bitxor_assign","","",50,[[["self"]]]],[11,"bitxor_assign","","",50,[[["self"],["bool"]]]],[11,"bitxor_assign","","",71,[[["self"]]]],[11,"bitxor_assign","","",71,[[["isize"],["self"]]]],[11,"bitxor_assign","","",72,[[["self"]]]],[11,"bitxor_assign","","",72,[[["self"],["usize"]]]],[11,"bitxor_assign","","",73,[[["self"]]]],[11,"bitxor_assign","","",73,[[["self"],["bool"]]]],[11,"bitxor_assign","","",91,[[["self"]]]],[11,"bitxor_assign","","",91,[[["isize"],["self"]]]],[11,"bitxor_assign","","",92,[[["self"]]]],[11,"bitxor_assign","","",92,[[["self"],["usize"]]]],[11,"bitxor_assign","","",93,[[["self"]]]],[11,"bitxor_assign","","",93,[[["self"],["bool"]]]],[11,"shl_assign","","",15,[[["self"]]]],[11,"shl_assign","","",15,[[["self"],["u32"]]]],[11,"shl_assign","","",16,[[["self"]]]],[11,"shl_assign","","",16,[[["self"],["u32"]]]],[11,"shl_assign","","",18,[[["self"]]]],[11,"shl_assign","","",18,[[["self"],["u32"]]]],[11,"shl_assign","","",19,[[["self"]]]],[11,"shl_assign","","",19,[[["self"],["u32"]]]],[11,"shl_assign","","",21,[[["self"]]]],[11,"shl_assign","","",21,[[["self"],["u32"]]]],[11,"shl_assign","","",22,[[["self"]]]],[11,"shl_assign","","",22,[[["self"],["u32"]]]],[11,"shl_assign","","",24,[[["self"]]]],[11,"shl_assign","","",24,[[["self"],["u32"]]]],[11,"shl_assign","","",25,[[["self"]]]],[11,"shl_assign","","",25,[[["self"],["u32"]]]],[11,"shl_assign","","",27,[[["self"]]]],[11,"shl_assign","","",27,[[["self"],["u32"]]]],[11,"shl_assign","","",28,[[["self"]]]],[11,"shl_assign","","",28,[[["self"],["u32"]]]],[11,"shl_assign","","",30,[[["self"]]]],[11,"shl_assign","","",30,[[["self"],["u32"]]]],[11,"shl_assign","","",31,[[["self"]]]],[11,"shl_assign","","",31,[[["self"],["u32"]]]],[11,"shl_assign","","",34,[[["self"]]]],[11,"shl_assign","","",34,[[["self"],["u32"]]]],[11,"shl_assign","","",35,[[["self"]]]],[11,"shl_assign","","",35,[[["self"],["u32"]]]],[11,"shl_assign","","",37,[[["self"]]]],[11,"shl_assign","","",37,[[["self"],["u32"]]]],[11,"shl_assign","","",38,[[["self"]]]],[11,"shl_assign","","",38,[[["self"],["u32"]]]],[11,"shl_assign","","",40,[[["self"]]]],[11,"shl_assign","","",40,[[["self"],["u32"]]]],[11,"shl_assign","","",41,[[["self"]]]],[11,"shl_assign","","",41,[[["self"],["u32"]]]],[11,"shl_assign","","",44,[[["self"]]]],[11,"shl_assign","","",44,[[["self"],["u32"]]]],[11,"shl_assign","","",45,[[["self"]]]],[11,"shl_assign","","",45,[[["self"],["u32"]]]],[11,"shl_assign","","",51,[[["self"]]]],[11,"shl_assign","","",51,[[["self"],["u32"]]]],[11,"shl_assign","","",52,[[["self"]]]],[11,"shl_assign","","",52,[[["self"],["u32"]]]],[11,"shl_assign","","",54,[[["self"]]]],[11,"shl_assign","","",54,[[["self"],["u32"]]]],[11,"shl_assign","","",55,[[["self"]]]],[11,"shl_assign","","",55,[[["self"],["u32"]]]],[11,"shl_assign","","",57,[[["self"]]]],[11,"shl_assign","","",57,[[["self"],["u32"]]]],[11,"shl_assign","","",58,[[["self"]]]],[11,"shl_assign","","",58,[[["self"],["u32"]]]],[11,"shl_assign","","",60,[[["self"]]]],[11,"shl_assign","","",60,[[["self"],["u32"]]]],[11,"shl_assign","","",61,[[["self"]]]],[11,"shl_assign","","",61,[[["self"],["u32"]]]],[11,"shl_assign","","",64,[[["self"]]]],[11,"shl_assign","","",64,[[["self"],["u32"]]]],[11,"shl_assign","","",65,[[["self"]]]],[11,"shl_assign","","",65,[[["self"],["u32"]]]],[11,"shl_assign","","",68,[[["self"]]]],[11,"shl_assign","","",68,[[["self"],["u32"]]]],[11,"shl_assign","","",69,[[["self"]]]],[11,"shl_assign","","",69,[[["self"],["u32"]]]],[11,"shl_assign","","",74,[[["self"]]]],[11,"shl_assign","","",74,[[["self"],["u32"]]]],[11,"shl_assign","","",75,[[["self"]]]],[11,"shl_assign","","",75,[[["self"],["u32"]]]],[11,"shl_assign","","",77,[[["self"]]]],[11,"shl_assign","","",77,[[["self"],["u32"]]]],[11,"shl_assign","","",78,[[["self"]]]],[11,"shl_assign","","",78,[[["self"],["u32"]]]],[11,"shl_assign","","",80,[[["self"]]]],[11,"shl_assign","","",80,[[["self"],["u32"]]]],[11,"shl_assign","","",81,[[["self"]]]],[11,"shl_assign","","",81,[[["self"],["u32"]]]],[11,"shl_assign","","",84,[[["self"]]]],[11,"shl_assign","","",84,[[["self"],["u32"]]]],[11,"shl_assign","","",85,[[["self"]]]],[11,"shl_assign","","",85,[[["self"],["u32"]]]],[11,"shl_assign","","",88,[[["self"]]]],[11,"shl_assign","","",88,[[["self"],["u32"]]]],[11,"shl_assign","","",89,[[["self"]]]],[11,"shl_assign","","",89,[[["self"],["u32"]]]],[11,"shl_assign","","",48,[[["self"]]]],[11,"shl_assign","","",48,[[["self"],["u32"]]]],[11,"shl_assign","","",49,[[["self"]]]],[11,"shl_assign","","",49,[[["self"],["u32"]]]],[11,"shl_assign","","",71,[[["self"]]]],[11,"shl_assign","","",71,[[["self"],["u32"]]]],[11,"shl_assign","","",72,[[["self"]]]],[11,"shl_assign","","",72,[[["self"],["u32"]]]],[11,"shl_assign","","",91,[[["self"]]]],[11,"shl_assign","","",91,[[["self"],["u32"]]]],[11,"shl_assign","","",92,[[["self"]]]],[11,"shl_assign","","",92,[[["self"],["u32"]]]],[11,"shr_assign","","",15,[[["self"]]]],[11,"shr_assign","","",15,[[["self"],["u32"]]]],[11,"shr_assign","","",16,[[["self"]]]],[11,"shr_assign","","",16,[[["self"],["u32"]]]],[11,"shr_assign","","",18,[[["self"]]]],[11,"shr_assign","","",18,[[["self"],["u32"]]]],[11,"shr_assign","","",19,[[["self"]]]],[11,"shr_assign","","",19,[[["self"],["u32"]]]],[11,"shr_assign","","",21,[[["self"]]]],[11,"shr_assign","","",21,[[["self"],["u32"]]]],[11,"shr_assign","","",22,[[["self"]]]],[11,"shr_assign","","",22,[[["self"],["u32"]]]],[11,"shr_assign","","",24,[[["self"]]]],[11,"shr_assign","","",24,[[["self"],["u32"]]]],[11,"shr_assign","","",25,[[["self"]]]],[11,"shr_assign","","",25,[[["self"],["u32"]]]],[11,"shr_assign","","",27,[[["self"]]]],[11,"shr_assign","","",27,[[["self"],["u32"]]]],[11,"shr_assign","","",28,[[["self"]]]],[11,"shr_assign","","",28,[[["self"],["u32"]]]],[11,"shr_assign","","",30,[[["self"]]]],[11,"shr_assign","","",30,[[["self"],["u32"]]]],[11,"shr_assign","","",31,[[["self"]]]],[11,"shr_assign","","",31,[[["self"],["u32"]]]],[11,"shr_assign","","",34,[[["self"]]]],[11,"shr_assign","","",34,[[["self"],["u32"]]]],[11,"shr_assign","","",35,[[["self"]]]],[11,"shr_assign","","",35,[[["self"],["u32"]]]],[11,"shr_assign","","",37,[[["self"]]]],[11,"shr_assign","","",37,[[["self"],["u32"]]]],[11,"shr_assign","","",38,[[["self"]]]],[11,"shr_assign","","",38,[[["self"],["u32"]]]],[11,"shr_assign","","",40,[[["self"]]]],[11,"shr_assign","","",40,[[["self"],["u32"]]]],[11,"shr_assign","","",41,[[["self"]]]],[11,"shr_assign","","",41,[[["self"],["u32"]]]],[11,"shr_assign","","",44,[[["self"]]]],[11,"shr_assign","","",44,[[["self"],["u32"]]]],[11,"shr_assign","","",45,[[["self"]]]],[11,"shr_assign","","",45,[[["self"],["u32"]]]],[11,"shr_assign","","",51,[[["self"]]]],[11,"shr_assign","","",51,[[["self"],["u32"]]]],[11,"shr_assign","","",52,[[["self"]]]],[11,"shr_assign","","",52,[[["self"],["u32"]]]],[11,"shr_assign","","",54,[[["self"]]]],[11,"shr_assign","","",54,[[["self"],["u32"]]]],[11,"shr_assign","","",55,[[["self"]]]],[11,"shr_assign","","",55,[[["self"],["u32"]]]],[11,"shr_assign","","",57,[[["self"]]]],[11,"shr_assign","","",57,[[["self"],["u32"]]]],[11,"shr_assign","","",58,[[["self"]]]],[11,"shr_assign","","",58,[[["self"],["u32"]]]],[11,"shr_assign","","",60,[[["self"]]]],[11,"shr_assign","","",60,[[["self"],["u32"]]]],[11,"shr_assign","","",61,[[["self"]]]],[11,"shr_assign","","",61,[[["self"],["u32"]]]],[11,"shr_assign","","",64,[[["self"]]]],[11,"shr_assign","","",64,[[["self"],["u32"]]]],[11,"shr_assign","","",65,[[["self"]]]],[11,"shr_assign","","",65,[[["self"],["u32"]]]],[11,"shr_assign","","",68,[[["self"]]]],[11,"shr_assign","","",68,[[["self"],["u32"]]]],[11,"shr_assign","","",69,[[["self"]]]],[11,"shr_assign","","",69,[[["self"],["u32"]]]],[11,"shr_assign","","",74,[[["self"]]]],[11,"shr_assign","","",74,[[["self"],["u32"]]]],[11,"shr_assign","","",75,[[["self"]]]],[11,"shr_assign","","",75,[[["self"],["u32"]]]],[11,"shr_assign","","",77,[[["self"]]]],[11,"shr_assign","","",77,[[["self"],["u32"]]]],[11,"shr_assign","","",78,[[["self"]]]],[11,"shr_assign","","",78,[[["self"],["u32"]]]],[11,"shr_assign","","",80,[[["self"]]]],[11,"shr_assign","","",80,[[["self"],["u32"]]]],[11,"shr_assign","","",81,[[["self"]]]],[11,"shr_assign","","",81,[[["self"],["u32"]]]],[11,"shr_assign","","",84,[[["self"]]]],[11,"shr_assign","","",84,[[["self"],["u32"]]]],[11,"shr_assign","","",85,[[["self"]]]],[11,"shr_assign","","",85,[[["self"],["u32"]]]],[11,"shr_assign","","",88,[[["self"]]]],[11,"shr_assign","","",88,[[["self"],["u32"]]]],[11,"shr_assign","","",89,[[["self"]]]],[11,"shr_assign","","",89,[[["self"],["u32"]]]],[11,"shr_assign","","",48,[[["self"]]]],[11,"shr_assign","","",48,[[["self"],["u32"]]]],[11,"shr_assign","","",49,[[["self"]]]],[11,"shr_assign","","",49,[[["self"],["u32"]]]],[11,"shr_assign","","",71,[[["self"]]]],[11,"shr_assign","","",71,[[["self"],["u32"]]]],[11,"shr_assign","","",72,[[["self"]]]],[11,"shr_assign","","",72,[[["self"],["u32"]]]],[11,"shr_assign","","",91,[[["self"]]]],[11,"shr_assign","","",91,[[["self"],["u32"]]]],[11,"shr_assign","","",92,[[["self"]]]],[11,"shr_assign","","",92,[[["self"],["u32"]]]],[11,"hash","","",0,[[["self"],["h"]]]],[11,"hash","","",1,[[["self"],["h"]]]],[11,"hash","","",2,[[["self"],["h"]]]],[11,"hash","","",3,[[["self"],["h"]]]],[11,"hash","","",4,[[["self"],["h"]]]],[11,"hash","","",5,[[["self"],["h"]]]],[11,"hash","","",15,[[["self"],["h"]]]],[11,"hash","","",16,[[["self"],["h"]]]],[11,"hash","","",18,[[["self"],["h"]]]],[11,"hash","","",19,[[["self"],["h"]]]],[11,"hash","","",21,[[["self"],["h"]]]],[11,"hash","","",22,[[["self"],["h"]]]],[11,"hash","","",24,[[["self"],["h"]]]],[11,"hash","","",25,[[["self"],["h"]]]],[11,"hash","","",27,[[["self"],["h"]]]],[11,"hash","","",28,[[["self"],["h"]]]],[11,"hash","","",30,[[["self"],["h"]]]],[11,"hash","","",31,[[["self"],["h"]]]],[11,"hash","","",34,[[["self"],["h"]]]],[11,"hash","","",35,[[["self"],["h"]]]],[11,"hash","","",37,[[["self"],["h"]]]],[11,"hash","","",38,[[["self"],["h"]]]],[11,"hash","","",40,[[["self"],["h"]]]],[11,"hash","","",41,[[["self"],["h"]]]],[11,"hash","","",44,[[["self"],["h"]]]],[11,"hash","","",45,[[["self"],["h"]]]],[11,"hash","","",51,[[["self"],["h"]]]],[11,"hash","","",52,[[["self"],["h"]]]],[11,"hash","","",54,[[["self"],["h"]]]],[11,"hash","","",55,[[["self"],["h"]]]],[11,"hash","","",57,[[["self"],["h"]]]],[11,"hash","","",58,[[["self"],["h"]]]],[11,"hash","","",60,[[["self"],["h"]]]],[11,"hash","","",61,[[["self"],["h"]]]],[11,"hash","","",64,[[["self"],["h"]]]],[11,"hash","","",65,[[["self"],["h"]]]],[11,"hash","","",68,[[["self"],["h"]]]],[11,"hash","","",69,[[["self"],["h"]]]],[11,"hash","","",74,[[["self"],["h"]]]],[11,"hash","","",75,[[["self"],["h"]]]],[11,"hash","","",77,[[["self"],["h"]]]],[11,"hash","","",78,[[["self"],["h"]]]],[11,"hash","","",80,[[["self"],["h"]]]],[11,"hash","","",81,[[["self"],["h"]]]],[11,"hash","","",84,[[["self"],["h"]]]],[11,"hash","","",85,[[["self"],["h"]]]],[11,"hash","","",88,[[["self"],["h"]]]],[11,"hash","","",89,[[["self"],["h"]]]],[11,"hash","","",48,[[["self"],["h"]]]],[11,"hash","","",49,[[["self"],["h"]]]],[11,"hash","","",71,[[["self"],["h"]]]],[11,"hash","","",72,[[["self"],["h"]]]],[11,"hash","","",91,[[["self"],["h"]]]],[11,"hash","","",92,[[["self"],["h"]]]],[11,"hash","","",94,[[["self"],["h"]]]],[11,"hash","","",95,[[["self"],["h"]]]],[11,"hash","","",96,[[["self"],["h"]]]],[11,"hash","","",97,[[["self"],["h"]]]],[11,"hash","","",98,[[["self"],["h"]]]],[11,"hash","","",99,[[["self"],["h"]]]],[11,"product","","",15,[[["iterator"]],["i8x2"]]],[11,"product","","",15,[[["iterator"]],["i8x2"]]],[11,"product","","",16,[[["iterator"]],["u8x2"]]],[11,"product","","",16,[[["iterator"]],["u8x2"]]],[11,"product","","",18,[[["iterator"]],["i8x4"]]],[11,"product","","",18,[[["iterator"]],["i8x4"]]],[11,"product","","",19,[[["iterator"]],["u8x4"]]],[11,"product","","",19,[[["iterator"]],["u8x4"]]],[11,"product","","",21,[[["iterator"]],["i16x2"]]],[11,"product","","",21,[[["iterator"]],["i16x2"]]],[11,"product","","",22,[[["iterator"]],["u16x2"]]],[11,"product","","",22,[[["iterator"]],["u16x2"]]],[11,"product","","",24,[[["iterator"]],["i8x8"]]],[11,"product","","",24,[[["iterator"]],["i8x8"]]],[11,"product","","",25,[[["iterator"]],["u8x8"]]],[11,"product","","",25,[[["iterator"]],["u8x8"]]],[11,"product","","",27,[[["iterator"]],["i16x4"]]],[11,"product","","",27,[[["iterator"]],["i16x4"]]],[11,"product","","",28,[[["iterator"]],["u16x4"]]],[11,"product","","",28,[[["iterator"]],["u16x4"]]],[11,"product","","",30,[[["iterator"]],["i32x2"]]],[11,"product","","",30,[[["iterator"]],["i32x2"]]],[11,"product","","",31,[[["iterator"]],["u32x2"]]],[11,"product","","",31,[[["iterator"]],["u32x2"]]],[11,"product","","",32,[[["iterator"]],["f32x2"]]],[11,"product","","",32,[[["iterator"]],["f32x2"]]],[11,"product","","",34,[[["iterator"]],["i8x16"]]],[11,"product","","",34,[[["iterator"]],["i8x16"]]],[11,"product","","",35,[[["iterator"]],["u8x16"]]],[11,"product","","",35,[[["iterator"]],["u8x16"]]],[11,"product","","",37,[[["iterator"]],["i16x8"]]],[11,"product","","",37,[[["iterator"]],["i16x8"]]],[11,"product","","",38,[[["iterator"]],["u16x8"]]],[11,"product","","",38,[[["iterator"]],["u16x8"]]],[11,"product","","",40,[[["iterator"]],["i32x4"]]],[11,"product","","",40,[[["iterator"]],["i32x4"]]],[11,"product","","",41,[[["iterator"]],["u32x4"]]],[11,"product","","",41,[[["iterator"]],["u32x4"]]],[11,"product","","",42,[[["iterator"]],["f32x4"]]],[11,"product","","",42,[[["iterator"]],["f32x4"]]],[11,"product","","",44,[[["iterator"]],["i64x2"]]],[11,"product","","",44,[[["iterator"]],["i64x2"]]],[11,"product","","",45,[[["iterator"]],["u64x2"]]],[11,"product","","",45,[[["iterator"]],["u64x2"]]],[11,"product","","",46,[[["iterator"]],["f64x2"]]],[11,"product","","",46,[[["iterator"]],["f64x2"]]],[11,"product","","",51,[[["iterator"]],["i128x1"]]],[11,"product","","",51,[[["iterator"]],["i128x1"]]],[11,"product","","",52,[[["iterator"]],["u128x1"]]],[11,"product","","",52,[[["iterator"]],["u128x1"]]],[11,"product","","",54,[[["iterator"]],["i8x32"]]],[11,"product","","",54,[[["iterator"]],["i8x32"]]],[11,"product","","",55,[[["iterator"]],["u8x32"]]],[11,"product","","",55,[[["iterator"]],["u8x32"]]],[11,"product","","",57,[[["iterator"]],["i16x16"]]],[11,"product","","",57,[[["iterator"]],["i16x16"]]],[11,"product","","",58,[[["iterator"]],["u16x16"]]],[11,"product","","",58,[[["iterator"]],["u16x16"]]],[11,"product","","",60,[[["iterator"]],["i32x8"]]],[11,"product","","",60,[[["iterator"]],["i32x8"]]],[11,"product","","",61,[[["iterator"]],["u32x8"]]],[11,"product","","",61,[[["iterator"]],["u32x8"]]],[11,"product","","",62,[[["iterator"]],["f32x8"]]],[11,"product","","",62,[[["iterator"]],["f32x8"]]],[11,"product","","",64,[[["iterator"]],["i64x4"]]],[11,"product","","",64,[[["iterator"]],["i64x4"]]],[11,"product","","",65,[[["iterator"]],["u64x4"]]],[11,"product","","",65,[[["iterator"]],["u64x4"]]],[11,"product","","",66,[[["iterator"]],["f64x4"]]],[11,"product","","",66,[[["iterator"]],["f64x4"]]],[11,"product","","",68,[[["iterator"]],["i128x2"]]],[11,"product","","",68,[[["iterator"]],["i128x2"]]],[11,"product","","",69,[[["iterator"]],["u128x2"]]],[11,"product","","",69,[[["iterator"]],["u128x2"]]],[11,"product","","",74,[[["iterator"]],["i8x64"]]],[11,"product","","",74,[[["iterator"]],["i8x64"]]],[11,"product","","",75,[[["iterator"]],["u8x64"]]],[11,"product","","",75,[[["iterator"]],["u8x64"]]],[11,"product","","",77,[[["iterator"]],["i16x32"]]],[11,"product","","",77,[[["iterator"]],["i16x32"]]],[11,"product","","",78,[[["iterator"]],["u16x32"]]],[11,"product","","",78,[[["iterator"]],["u16x32"]]],[11,"product","","",80,[[["iterator"]],["i32x16"]]],[11,"product","","",80,[[["iterator"]],["i32x16"]]],[11,"product","","",81,[[["iterator"]],["u32x16"]]],[11,"product","","",81,[[["iterator"]],["u32x16"]]],[11,"product","","",82,[[["iterator"]],["f32x16"]]],[11,"product","","",82,[[["iterator"]],["f32x16"]]],[11,"product","","",84,[[["iterator"]],["i64x8"]]],[11,"product","","",84,[[["iterator"]],["i64x8"]]],[11,"product","","",85,[[["iterator"]],["u64x8"]]],[11,"product","","",85,[[["iterator"]],["u64x8"]]],[11,"product","","",86,[[["iterator"]],["f64x8"]]],[11,"product","","",86,[[["iterator"]],["f64x8"]]],[11,"product","","",88,[[["iterator"]],["i128x4"]]],[11,"product","","",88,[[["iterator"]],["i128x4"]]],[11,"product","","",89,[[["iterator"]],["u128x4"]]],[11,"product","","",89,[[["iterator"]],["u128x4"]]],[11,"product","","",48,[[["iterator"]],["isizex2"]]],[11,"product","","",48,[[["iterator"]],["isizex2"]]],[11,"product","","",49,[[["iterator"]],["usizex2"]]],[11,"product","","",49,[[["iterator"]],["usizex2"]]],[11,"product","","",71,[[["iterator"]],["isizex4"]]],[11,"product","","",71,[[["iterator"]],["isizex4"]]],[11,"product","","",72,[[["iterator"]],["usizex4"]]],[11,"product","","",72,[[["iterator"]],["usizex4"]]],[11,"product","","",91,[[["iterator"]],["isizex8"]]],[11,"product","","",91,[[["iterator"]],["isizex8"]]],[11,"product","","",92,[[["iterator"]],["usizex8"]]],[11,"product","","",92,[[["iterator"]],["usizex8"]]],[11,"sum","","",15,[[["iterator"]],["i8x2"]]],[11,"sum","","",15,[[["iterator"]],["i8x2"]]],[11,"sum","","",16,[[["iterator"]],["u8x2"]]],[11,"sum","","",16,[[["iterator"]],["u8x2"]]],[11,"sum","","",18,[[["iterator"]],["i8x4"]]],[11,"sum","","",18,[[["iterator"]],["i8x4"]]],[11,"sum","","",19,[[["iterator"]],["u8x4"]]],[11,"sum","","",19,[[["iterator"]],["u8x4"]]],[11,"sum","","",21,[[["iterator"]],["i16x2"]]],[11,"sum","","",21,[[["iterator"]],["i16x2"]]],[11,"sum","","",22,[[["iterator"]],["u16x2"]]],[11,"sum","","",22,[[["iterator"]],["u16x2"]]],[11,"sum","","",24,[[["iterator"]],["i8x8"]]],[11,"sum","","",24,[[["iterator"]],["i8x8"]]],[11,"sum","","",25,[[["iterator"]],["u8x8"]]],[11,"sum","","",25,[[["iterator"]],["u8x8"]]],[11,"sum","","",27,[[["iterator"]],["i16x4"]]],[11,"sum","","",27,[[["iterator"]],["i16x4"]]],[11,"sum","","",28,[[["iterator"]],["u16x4"]]],[11,"sum","","",28,[[["iterator"]],["u16x4"]]],[11,"sum","","",30,[[["iterator"]],["i32x2"]]],[11,"sum","","",30,[[["iterator"]],["i32x2"]]],[11,"sum","","",31,[[["iterator"]],["u32x2"]]],[11,"sum","","",31,[[["iterator"]],["u32x2"]]],[11,"sum","","",32,[[["iterator"]],["f32x2"]]],[11,"sum","","",32,[[["iterator"]],["f32x2"]]],[11,"sum","","",34,[[["iterator"]],["i8x16"]]],[11,"sum","","",34,[[["iterator"]],["i8x16"]]],[11,"sum","","",35,[[["iterator"]],["u8x16"]]],[11,"sum","","",35,[[["iterator"]],["u8x16"]]],[11,"sum","","",37,[[["iterator"]],["i16x8"]]],[11,"sum","","",37,[[["iterator"]],["i16x8"]]],[11,"sum","","",38,[[["iterator"]],["u16x8"]]],[11,"sum","","",38,[[["iterator"]],["u16x8"]]],[11,"sum","","",40,[[["iterator"]],["i32x4"]]],[11,"sum","","",40,[[["iterator"]],["i32x4"]]],[11,"sum","","",41,[[["iterator"]],["u32x4"]]],[11,"sum","","",41,[[["iterator"]],["u32x4"]]],[11,"sum","","",42,[[["iterator"]],["f32x4"]]],[11,"sum","","",42,[[["iterator"]],["f32x4"]]],[11,"sum","","",44,[[["iterator"]],["i64x2"]]],[11,"sum","","",44,[[["iterator"]],["i64x2"]]],[11,"sum","","",45,[[["iterator"]],["u64x2"]]],[11,"sum","","",45,[[["iterator"]],["u64x2"]]],[11,"sum","","",46,[[["iterator"]],["f64x2"]]],[11,"sum","","",46,[[["iterator"]],["f64x2"]]],[11,"sum","","",51,[[["iterator"]],["i128x1"]]],[11,"sum","","",51,[[["iterator"]],["i128x1"]]],[11,"sum","","",52,[[["iterator"]],["u128x1"]]],[11,"sum","","",52,[[["iterator"]],["u128x1"]]],[11,"sum","","",54,[[["iterator"]],["i8x32"]]],[11,"sum","","",54,[[["iterator"]],["i8x32"]]],[11,"sum","","",55,[[["iterator"]],["u8x32"]]],[11,"sum","","",55,[[["iterator"]],["u8x32"]]],[11,"sum","","",57,[[["iterator"]],["i16x16"]]],[11,"sum","","",57,[[["iterator"]],["i16x16"]]],[11,"sum","","",58,[[["iterator"]],["u16x16"]]],[11,"sum","","",58,[[["iterator"]],["u16x16"]]],[11,"sum","","",60,[[["iterator"]],["i32x8"]]],[11,"sum","","",60,[[["iterator"]],["i32x8"]]],[11,"sum","","",61,[[["iterator"]],["u32x8"]]],[11,"sum","","",61,[[["iterator"]],["u32x8"]]],[11,"sum","","",62,[[["iterator"]],["f32x8"]]],[11,"sum","","",62,[[["iterator"]],["f32x8"]]],[11,"sum","","",64,[[["iterator"]],["i64x4"]]],[11,"sum","","",64,[[["iterator"]],["i64x4"]]],[11,"sum","","",65,[[["iterator"]],["u64x4"]]],[11,"sum","","",65,[[["iterator"]],["u64x4"]]],[11,"sum","","",66,[[["iterator"]],["f64x4"]]],[11,"sum","","",66,[[["iterator"]],["f64x4"]]],[11,"sum","","",68,[[["iterator"]],["i128x2"]]],[11,"sum","","",68,[[["iterator"]],["i128x2"]]],[11,"sum","","",69,[[["iterator"]],["u128x2"]]],[11,"sum","","",69,[[["iterator"]],["u128x2"]]],[11,"sum","","",74,[[["iterator"]],["i8x64"]]],[11,"sum","","",74,[[["iterator"]],["i8x64"]]],[11,"sum","","",75,[[["iterator"]],["u8x64"]]],[11,"sum","","",75,[[["iterator"]],["u8x64"]]],[11,"sum","","",77,[[["iterator"]],["i16x32"]]],[11,"sum","","",77,[[["iterator"]],["i16x32"]]],[11,"sum","","",78,[[["iterator"]],["u16x32"]]],[11,"sum","","",78,[[["iterator"]],["u16x32"]]],[11,"sum","","",80,[[["iterator"]],["i32x16"]]],[11,"sum","","",80,[[["iterator"]],["i32x16"]]],[11,"sum","","",81,[[["iterator"]],["u32x16"]]],[11,"sum","","",81,[[["iterator"]],["u32x16"]]],[11,"sum","","",82,[[["iterator"]],["f32x16"]]],[11,"sum","","",82,[[["iterator"]],["f32x16"]]],[11,"sum","","",84,[[["iterator"]],["i64x8"]]],[11,"sum","","",84,[[["iterator"]],["i64x8"]]],[11,"sum","","",85,[[["iterator"]],["u64x8"]]],[11,"sum","","",85,[[["iterator"]],["u64x8"]]],[11,"sum","","",86,[[["iterator"]],["f64x8"]]],[11,"sum","","",86,[[["iterator"]],["f64x8"]]],[11,"sum","","",88,[[["iterator"]],["i128x4"]]],[11,"sum","","",88,[[["iterator"]],["i128x4"]]],[11,"sum","","",89,[[["iterator"]],["u128x4"]]],[11,"sum","","",89,[[["iterator"]],["u128x4"]]],[11,"sum","","",48,[[["iterator"]],["isizex2"]]],[11,"sum","","",48,[[["iterator"]],["isizex2"]]],[11,"sum","","",49,[[["iterator"]],["usizex2"]]],[11,"sum","","",49,[[["iterator"]],["usizex2"]]],[11,"sum","","",71,[[["iterator"]],["isizex4"]]],[11,"sum","","",71,[[["iterator"]],["isizex4"]]],[11,"sum","","",72,[[["iterator"]],["usizex4"]]],[11,"sum","","",72,[[["iterator"]],["usizex4"]]],[11,"sum","","",91,[[["iterator"]],["isizex8"]]],[11,"sum","","",91,[[["iterator"]],["isizex8"]]],[11,"sum","","",92,[[["iterator"]],["usizex8"]]],[11,"sum","","",92,[[["iterator"]],["usizex8"]]],[11,"into","","",94,[[]]],[11,"into","","",95,[[]]],[11,"into","","",96,[[]]],[11,"into","","",97,[[]]],[11,"into","","",98,[[]]],[11,"into","","",99,[[]]],[11,"fmt","","",15,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",16,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",18,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",19,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",21,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",22,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",24,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",25,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",27,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",28,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",30,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",31,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",34,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",35,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",37,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",38,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",40,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",41,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",44,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",45,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",51,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",52,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",54,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",55,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",57,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",58,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",60,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",61,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",64,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",65,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",68,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",69,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",74,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",75,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",77,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",78,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",80,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",81,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",84,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",85,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",88,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",89,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",48,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",49,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",71,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",72,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",91,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",92,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",15,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",16,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",18,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",19,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",21,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",22,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",24,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",25,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",27,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",28,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",30,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",31,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",34,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",35,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",37,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",38,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",40,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",41,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",44,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",45,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",51,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",52,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",54,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",55,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",57,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",58,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",60,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",61,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",64,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",65,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",68,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",69,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",74,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",75,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",77,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",78,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",80,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",81,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",84,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",85,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",88,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",89,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",48,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",49,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",71,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",72,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",91,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",92,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",15,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",16,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",18,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",19,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",21,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",22,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",24,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",25,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",27,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",28,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",30,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",31,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",34,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",35,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",37,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",38,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",40,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",41,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",44,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",45,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",51,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",52,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",54,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",55,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",57,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",58,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",60,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",61,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",64,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",65,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",68,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",69,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",74,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",75,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",77,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",78,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",80,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",81,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",84,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",85,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",88,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",89,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",48,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",49,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",71,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",72,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",91,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",92,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",15,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",16,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",18,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",19,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",21,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",22,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",24,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",25,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",27,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",28,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",30,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",31,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",34,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",35,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",37,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",38,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",40,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",41,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",44,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",45,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",51,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",52,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",54,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",55,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",57,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",58,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",60,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",61,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",64,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",65,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",68,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",69,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",74,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",75,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",77,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",78,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",80,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",81,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",84,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",85,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",88,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",89,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",48,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",49,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",71,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",72,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",91,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",92,[[["self"],["formatter"]],["result"]]],[11,"clone","","",6,[[["self"]],["simd"]]],[11,"clone","","",14,[[["self"]],["lexicographicallyordered"]]],[11,"clone","","",0,[[["self"]],["m8"]]],[11,"clone","","",1,[[["self"]],["m16"]]],[11,"clone","","",2,[[["self"]],["m32"]]],[11,"clone","","",3,[[["self"]],["m64"]]],[11,"clone","","",4,[[["self"]],["m128"]]],[11,"clone","","",5,[[["self"]],["msize"]]],[11,"default","","",0,[[],["self"]]],[11,"default","","",1,[[],["self"]]],[11,"default","","",2,[[],["self"]]],[11,"default","","",3,[[],["self"]]],[11,"default","","",4,[[],["self"]]],[11,"default","","",5,[[],["self"]]],[11,"default","","",15,[[],["self"]]],[11,"default","","",16,[[],["self"]]],[11,"default","","",17,[[],["self"]]],[11,"default","","",18,[[],["self"]]],[11,"default","","",19,[[],["self"]]],[11,"default","","",20,[[],["self"]]],[11,"default","","",21,[[],["self"]]],[11,"default","","",22,[[],["self"]]],[11,"default","","",23,[[],["self"]]],[11,"default","","",24,[[],["self"]]],[11,"default","","",25,[[],["self"]]],[11,"default","","",26,[[],["self"]]],[11,"default","","",27,[[],["self"]]],[11,"default","","",28,[[],["self"]]],[11,"default","","",29,[[],["self"]]],[11,"default","","",30,[[],["self"]]],[11,"default","","",31,[[],["self"]]],[11,"default","","",33,[[],["self"]]],[11,"default","","",32,[[],["self"]]],[11,"default","","",34,[[],["self"]]],[11,"default","","",35,[[],["self"]]],[11,"default","","",36,[[],["self"]]],[11,"default","","",37,[[],["self"]]],[11,"default","","",38,[[],["self"]]],[11,"default","","",39,[[],["self"]]],[11,"default","","",40,[[],["self"]]],[11,"default","","",41,[[],["self"]]],[11,"default","","",42,[[],["self"]]],[11,"default","","",43,[[],["self"]]],[11,"default","","",44,[[],["self"]]],[11,"default","","",45,[[],["self"]]],[11,"default","","",46,[[],["self"]]],[11,"default","","",47,[[],["self"]]],[11,"default","","",51,[[],["self"]]],[11,"default","","",52,[[],["self"]]],[11,"default","","",53,[[],["self"]]],[11,"default","","",54,[[],["self"]]],[11,"default","","",55,[[],["self"]]],[11,"default","","",56,[[],["self"]]],[11,"default","","",57,[[],["self"]]],[11,"default","","",58,[[],["self"]]],[11,"default","","",59,[[],["self"]]],[11,"default","","",60,[[],["self"]]],[11,"default","","",61,[[],["self"]]],[11,"default","","",62,[[],["self"]]],[11,"default","","",63,[[],["self"]]],[11,"default","","",64,[[],["self"]]],[11,"default","","",65,[[],["self"]]],[11,"default","","",66,[[],["self"]]],[11,"default","","",67,[[],["self"]]],[11,"default","","",68,[[],["self"]]],[11,"default","","",69,[[],["self"]]],[11,"default","","",70,[[],["self"]]],[11,"default","","",74,[[],["self"]]],[11,"default","","",75,[[],["self"]]],[11,"default","","",76,[[],["self"]]],[11,"default","","",77,[[],["self"]]],[11,"default","","",78,[[],["self"]]],[11,"default","","",79,[[],["self"]]],[11,"default","","",80,[[],["self"]]],[11,"default","","",81,[[],["self"]]],[11,"default","","",82,[[],["self"]]],[11,"default","","",83,[[],["self"]]],[11,"default","","",84,[[],["self"]]],[11,"default","","",85,[[],["self"]]],[11,"default","","",86,[[],["self"]]],[11,"default","","",87,[[],["self"]]],[11,"default","","",88,[[],["self"]]],[11,"default","","",89,[[],["self"]]],[11,"default","","",90,[[],["self"]]],[11,"default","","",48,[[],["self"]]],[11,"default","","",49,[[],["self"]]],[11,"default","","",50,[[],["self"]]],[11,"default","","",71,[[],["self"]]],[11,"default","","",72,[[],["self"]]],[11,"default","","",73,[[],["self"]]],[11,"default","","",91,[[],["self"]]],[11,"default","","",92,[[],["self"]]],[11,"default","","",93,[[],["self"]]],[11,"default","","",94,[[],["self"]]],[11,"default","","",95,[[],["self"]]],[11,"default","","",96,[[],["self"]]],[11,"default","","",97,[[],["self"]]],[11,"default","","",98,[[],["self"]]],[11,"default","","",99,[[],["self"]]],[18,"N","","The number of elements in the array.",8,null],[18,"LANES","","The number of elements in the SIMD vector.",7,null],[11,"new","","Creates a new instance with each vector elements…",15,[[["i8"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",15,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",15,[[["i8"]],["self"]]],[11,"extract","","Extracts the value at `index`.",15,[[["usize"]],["i8"]]],[11,"extract_unchecked","","Extracts the value at `index`.",15,[[["usize"]],["i8"]]],[11,"replace","","Returns a new vector where the value at `index` is…",15,[[["i8"],["usize"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",15,[[["i8"],["usize"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",15,[[["i8x2"]],["i8x2"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",15,[[["i8x2"]],["i8x2"]]],[11,"min","","Minimum of two vectors.",15,[[],["self"]]],[11,"max","","Maximum of two vectors.",15,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",15,[[],["i8"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",15,[[],["i8"]]],[11,"max_element","","Largest vector element value.",15,[[],["i8"]]],[11,"min_element","","Smallest vector element value.",15,[[],["i8"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",15,[[],["i8"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",15,[[],["i8"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",15,[[],["i8"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",15,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",15,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",15,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",15,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",15,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",15,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",15,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",15,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",15,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",15,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",15,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",15,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",15,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",15,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",15,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",15,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",15,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",15,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",15,[[],["m8x2"]]],[11,"ne","","Lane-wise inequality comparison.",15,[[],["m8x2"]]],[11,"lt","","Lane-wise less-than comparison.",15,[[],["m8x2"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",15,[[],["m8x2"]]],[11,"gt","","Lane-wise greater-than comparison.",15,[[],["m8x2"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",15,[[],["m8x2"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",15,[[["self"]],[["lexicographicallyordered",["i8x2"]],["i8x2"]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",15,[[["self"]],[["lexicographicallyordered",["i8x2"]],["i8x2"]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",15,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",16,[[["u8"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",16,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",16,[[["u8"]],["self"]]],[11,"extract","","Extracts the value at `index`.",16,[[["usize"]],["u8"]]],[11,"extract_unchecked","","Extracts the value at `index`.",16,[[["usize"]],["u8"]]],[11,"replace","","Returns a new vector where the value at `index` is…",16,[[["usize"],["u8"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",16,[[["usize"],["u8"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",16,[[["u8x2"]],["u8x2"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",16,[[["u8x2"]],["u8x2"]]],[11,"min","","Minimum of two vectors.",16,[[],["self"]]],[11,"max","","Maximum of two vectors.",16,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",16,[[],["u8"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",16,[[],["u8"]]],[11,"max_element","","Largest vector element value.",16,[[],["u8"]]],[11,"min_element","","Smallest vector element value.",16,[[],["u8"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",16,[[],["u8"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",16,[[],["u8"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",16,[[],["u8"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",16,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",16,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",16,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",16,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",16,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",16,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",16,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",16,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",16,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",16,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",16,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",16,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",16,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",16,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",16,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",16,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",16,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",16,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",16,[[],["m8x2"]]],[11,"ne","","Lane-wise inequality comparison.",16,[[],["m8x2"]]],[11,"lt","","Lane-wise less-than comparison.",16,[[],["m8x2"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",16,[[],["m8x2"]]],[11,"gt","","Lane-wise greater-than comparison.",16,[[],["m8x2"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",16,[[],["m8x2"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",16,[[["self"]],[["u8x2"],["lexicographicallyordered",["u8x2"]]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",16,[[["self"]],[["u8x2"],["lexicographicallyordered",["u8x2"]]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",16,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",17,[[["bool"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",17,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",17,[[["bool"]],["self"]]],[11,"extract","","Extracts the value at `index`.",17,[[["usize"]],["bool"]]],[11,"extract_unchecked","","Extracts the value at `index`.",17,[[["usize"]],["bool"]]],[11,"replace","","Returns a new vector where the value at `index` is…",17,[[["usize"],["bool"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",17,[[["usize"],["bool"]],["self"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",17,[[],["bool"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",17,[[],["bool"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",17,[[],["bool"]]],[11,"all","","Are `all` vector lanes `true`?",17,[[],["bool"]]],[11,"any","","Is `any` vector lane `true`?",17,[[],["bool"]]],[11,"none","","Are `all` vector lanes `false`?",17,[[],["bool"]]],[11,"eq","","Lane-wise equality comparison.",17,[[],["m8x2"]]],[11,"ne","","Lane-wise inequality comparison.",17,[[],["m8x2"]]],[11,"lt","","Lane-wise less-than comparison.",17,[[],["m8x2"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",17,[[],["m8x2"]]],[11,"gt","","Lane-wise greater-than comparison.",17,[[],["m8x2"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",17,[[],["m8x2"]]],[11,"select","","Selects elements of `a` and `b` using mask.",17,[[["simd"]],["simd"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",17,[[["self"]],[["m8x2"],["lexicographicallyordered",["m8x2"]]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",17,[[["self"]],[["m8x2"],["lexicographicallyordered",["m8x2"]]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",17,[[["i"]],["self"]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",17,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",18,[[["i8"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",18,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",18,[[["i8"]],["self"]]],[11,"extract","","Extracts the value at `index`.",18,[[["usize"]],["i8"]]],[11,"extract_unchecked","","Extracts the value at `index`.",18,[[["usize"]],["i8"]]],[11,"replace","","Returns a new vector where the value at `index` is…",18,[[["i8"],["usize"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",18,[[["i8"],["usize"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",18,[[["i8x4"]],["i8x4"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",18,[[["i8x4"]],["i8x4"]]],[11,"min","","Minimum of two vectors.",18,[[],["self"]]],[11,"max","","Maximum of two vectors.",18,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",18,[[],["i8"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",18,[[],["i8"]]],[11,"max_element","","Largest vector element value.",18,[[],["i8"]]],[11,"min_element","","Smallest vector element value.",18,[[],["i8"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",18,[[],["i8"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",18,[[],["i8"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",18,[[],["i8"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",18,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",18,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",18,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",18,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",18,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",18,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",18,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",18,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",18,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",18,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",18,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",18,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",18,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",18,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",18,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",18,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",18,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",18,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",18,[[],["m8x4"]]],[11,"ne","","Lane-wise inequality comparison.",18,[[],["m8x4"]]],[11,"lt","","Lane-wise less-than comparison.",18,[[],["m8x4"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",18,[[],["m8x4"]]],[11,"gt","","Lane-wise greater-than comparison.",18,[[],["m8x4"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",18,[[],["m8x4"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",18,[[["self"]],[["lexicographicallyordered",["i8x4"]],["i8x4"]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",18,[[["self"]],[["lexicographicallyordered",["i8x4"]],["i8x4"]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",18,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",19,[[["u8"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",19,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",19,[[["u8"]],["self"]]],[11,"extract","","Extracts the value at `index`.",19,[[["usize"]],["u8"]]],[11,"extract_unchecked","","Extracts the value at `index`.",19,[[["usize"]],["u8"]]],[11,"replace","","Returns a new vector where the value at `index` is…",19,[[["usize"],["u8"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",19,[[["usize"],["u8"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",19,[[["u8x4"]],["u8x4"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",19,[[["u8x4"]],["u8x4"]]],[11,"min","","Minimum of two vectors.",19,[[],["self"]]],[11,"max","","Maximum of two vectors.",19,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",19,[[],["u8"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",19,[[],["u8"]]],[11,"max_element","","Largest vector element value.",19,[[],["u8"]]],[11,"min_element","","Smallest vector element value.",19,[[],["u8"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",19,[[],["u8"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",19,[[],["u8"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",19,[[],["u8"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",19,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",19,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",19,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",19,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",19,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",19,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",19,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",19,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",19,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",19,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",19,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",19,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",19,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",19,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",19,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",19,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",19,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",19,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",19,[[],["m8x4"]]],[11,"ne","","Lane-wise inequality comparison.",19,[[],["m8x4"]]],[11,"lt","","Lane-wise less-than comparison.",19,[[],["m8x4"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",19,[[],["m8x4"]]],[11,"gt","","Lane-wise greater-than comparison.",19,[[],["m8x4"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",19,[[],["m8x4"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",19,[[["self"]],[["lexicographicallyordered",["u8x4"]],["u8x4"]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",19,[[["self"]],[["lexicographicallyordered",["u8x4"]],["u8x4"]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",19,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",20,[[["bool"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",20,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",20,[[["bool"]],["self"]]],[11,"extract","","Extracts the value at `index`.",20,[[["usize"]],["bool"]]],[11,"extract_unchecked","","Extracts the value at `index`.",20,[[["usize"]],["bool"]]],[11,"replace","","Returns a new vector where the value at `index` is…",20,[[["usize"],["bool"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",20,[[["usize"],["bool"]],["self"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",20,[[],["bool"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",20,[[],["bool"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",20,[[],["bool"]]],[11,"all","","Are `all` vector lanes `true`?",20,[[],["bool"]]],[11,"any","","Is `any` vector lane `true`?",20,[[],["bool"]]],[11,"none","","Are `all` vector lanes `false`?",20,[[],["bool"]]],[11,"eq","","Lane-wise equality comparison.",20,[[],["m8x4"]]],[11,"ne","","Lane-wise inequality comparison.",20,[[],["m8x4"]]],[11,"lt","","Lane-wise less-than comparison.",20,[[],["m8x4"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",20,[[],["m8x4"]]],[11,"gt","","Lane-wise greater-than comparison.",20,[[],["m8x4"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",20,[[],["m8x4"]]],[11,"select","","Selects elements of `a` and `b` using mask.",20,[[["simd"]],["simd"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",20,[[["self"]],[["lexicographicallyordered",["m8x4"]],["m8x4"]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",20,[[["self"]],[["lexicographicallyordered",["m8x4"]],["m8x4"]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",20,[[["i"]],["self"]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",20,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",21,[[["i16"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",21,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",21,[[["i16"]],["self"]]],[11,"extract","","Extracts the value at `index`.",21,[[["usize"]],["i16"]]],[11,"extract_unchecked","","Extracts the value at `index`.",21,[[["usize"]],["i16"]]],[11,"replace","","Returns a new vector where the value at `index` is…",21,[[["usize"],["i16"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",21,[[["usize"],["i16"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",21,[[["i16x2"]],["i16x2"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",21,[[["i16x2"]],["i16x2"]]],[11,"min","","Minimum of two vectors.",21,[[],["self"]]],[11,"max","","Maximum of two vectors.",21,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",21,[[],["i16"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",21,[[],["i16"]]],[11,"max_element","","Largest vector element value.",21,[[],["i16"]]],[11,"min_element","","Smallest vector element value.",21,[[],["i16"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",21,[[],["i16"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",21,[[],["i16"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",21,[[],["i16"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",21,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",21,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",21,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",21,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",21,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",21,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",21,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",21,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",21,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",21,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",21,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",21,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",21,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",21,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",21,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",21,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",21,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",21,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",21,[[],["m16x2"]]],[11,"ne","","Lane-wise inequality comparison.",21,[[],["m16x2"]]],[11,"lt","","Lane-wise less-than comparison.",21,[[],["m16x2"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",21,[[],["m16x2"]]],[11,"gt","","Lane-wise greater-than comparison.",21,[[],["m16x2"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",21,[[],["m16x2"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",21,[[["self"]],[["i16x2"],["lexicographicallyordered",["i16x2"]]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",21,[[["self"]],[["i16x2"],["lexicographicallyordered",["i16x2"]]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",21,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",22,[[["u16"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",22,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",22,[[["u16"]],["self"]]],[11,"extract","","Extracts the value at `index`.",22,[[["usize"]],["u16"]]],[11,"extract_unchecked","","Extracts the value at `index`.",22,[[["usize"]],["u16"]]],[11,"replace","","Returns a new vector where the value at `index` is…",22,[[["u16"],["usize"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",22,[[["u16"],["usize"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",22,[[["u16x2"]],["u16x2"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",22,[[["u16x2"]],["u16x2"]]],[11,"min","","Minimum of two vectors.",22,[[],["self"]]],[11,"max","","Maximum of two vectors.",22,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",22,[[],["u16"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",22,[[],["u16"]]],[11,"max_element","","Largest vector element value.",22,[[],["u16"]]],[11,"min_element","","Smallest vector element value.",22,[[],["u16"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",22,[[],["u16"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",22,[[],["u16"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",22,[[],["u16"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",22,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",22,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",22,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",22,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",22,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",22,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",22,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",22,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",22,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",22,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",22,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",22,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",22,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",22,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",22,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",22,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",22,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",22,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",22,[[],["m16x2"]]],[11,"ne","","Lane-wise inequality comparison.",22,[[],["m16x2"]]],[11,"lt","","Lane-wise less-than comparison.",22,[[],["m16x2"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",22,[[],["m16x2"]]],[11,"gt","","Lane-wise greater-than comparison.",22,[[],["m16x2"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",22,[[],["m16x2"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",22,[[["self"]],[["u16x2"],["lexicographicallyordered",["u16x2"]]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",22,[[["self"]],[["u16x2"],["lexicographicallyordered",["u16x2"]]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",22,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",23,[[["bool"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",23,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",23,[[["bool"]],["self"]]],[11,"extract","","Extracts the value at `index`.",23,[[["usize"]],["bool"]]],[11,"extract_unchecked","","Extracts the value at `index`.",23,[[["usize"]],["bool"]]],[11,"replace","","Returns a new vector where the value at `index` is…",23,[[["usize"],["bool"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",23,[[["usize"],["bool"]],["self"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",23,[[],["bool"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",23,[[],["bool"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",23,[[],["bool"]]],[11,"all","","Are `all` vector lanes `true`?",23,[[],["bool"]]],[11,"any","","Is `any` vector lane `true`?",23,[[],["bool"]]],[11,"none","","Are `all` vector lanes `false`?",23,[[],["bool"]]],[11,"eq","","Lane-wise equality comparison.",23,[[],["m16x2"]]],[11,"ne","","Lane-wise inequality comparison.",23,[[],["m16x2"]]],[11,"lt","","Lane-wise less-than comparison.",23,[[],["m16x2"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",23,[[],["m16x2"]]],[11,"gt","","Lane-wise greater-than comparison.",23,[[],["m16x2"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",23,[[],["m16x2"]]],[11,"select","","Selects elements of `a` and `b` using mask.",23,[[["simd"]],["simd"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",23,[[["self"]],[["m16x2"],["lexicographicallyordered",["m16x2"]]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",23,[[["self"]],[["m16x2"],["lexicographicallyordered",["m16x2"]]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",23,[[["i"]],["self"]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",23,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",24,[[["i8"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",24,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",24,[[["i8"]],["self"]]],[11,"extract","","Extracts the value at `index`.",24,[[["usize"]],["i8"]]],[11,"extract_unchecked","","Extracts the value at `index`.",24,[[["usize"]],["i8"]]],[11,"replace","","Returns a new vector where the value at `index` is…",24,[[["i8"],["usize"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",24,[[["i8"],["usize"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",24,[[["i8x8"]],["i8x8"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",24,[[["i8x8"]],["i8x8"]]],[11,"min","","Minimum of two vectors.",24,[[],["self"]]],[11,"max","","Maximum of two vectors.",24,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",24,[[],["i8"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",24,[[],["i8"]]],[11,"max_element","","Largest vector element value.",24,[[],["i8"]]],[11,"min_element","","Smallest vector element value.",24,[[],["i8"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",24,[[],["i8"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",24,[[],["i8"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",24,[[],["i8"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",24,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",24,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",24,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",24,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",24,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",24,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",24,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",24,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",24,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",24,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",24,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",24,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",24,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",24,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",24,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",24,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",24,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",24,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",24,[[],["m8x8"]]],[11,"ne","","Lane-wise inequality comparison.",24,[[],["m8x8"]]],[11,"lt","","Lane-wise less-than comparison.",24,[[],["m8x8"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",24,[[],["m8x8"]]],[11,"gt","","Lane-wise greater-than comparison.",24,[[],["m8x8"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",24,[[],["m8x8"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",24,[[["self"]],[["lexicographicallyordered",["i8x8"]],["i8x8"]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",24,[[["self"]],[["lexicographicallyordered",["i8x8"]],["i8x8"]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",24,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",25,[[["u8"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",25,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",25,[[["u8"]],["self"]]],[11,"extract","","Extracts the value at `index`.",25,[[["usize"]],["u8"]]],[11,"extract_unchecked","","Extracts the value at `index`.",25,[[["usize"]],["u8"]]],[11,"replace","","Returns a new vector where the value at `index` is…",25,[[["usize"],["u8"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",25,[[["usize"],["u8"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",25,[[["u8x8"]],["u8x8"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",25,[[["u8x8"]],["u8x8"]]],[11,"min","","Minimum of two vectors.",25,[[],["self"]]],[11,"max","","Maximum of two vectors.",25,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",25,[[],["u8"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",25,[[],["u8"]]],[11,"max_element","","Largest vector element value.",25,[[],["u8"]]],[11,"min_element","","Smallest vector element value.",25,[[],["u8"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",25,[[],["u8"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",25,[[],["u8"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",25,[[],["u8"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",25,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",25,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",25,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",25,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",25,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",25,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",25,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",25,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",25,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",25,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",25,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",25,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",25,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",25,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",25,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",25,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",25,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",25,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",25,[[],["m8x8"]]],[11,"ne","","Lane-wise inequality comparison.",25,[[],["m8x8"]]],[11,"lt","","Lane-wise less-than comparison.",25,[[],["m8x8"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",25,[[],["m8x8"]]],[11,"gt","","Lane-wise greater-than comparison.",25,[[],["m8x8"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",25,[[],["m8x8"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",25,[[["self"]],[["lexicographicallyordered",["u8x8"]],["u8x8"]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",25,[[["self"]],[["lexicographicallyordered",["u8x8"]],["u8x8"]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",25,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",26,[[["bool"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",26,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",26,[[["bool"]],["self"]]],[11,"extract","","Extracts the value at `index`.",26,[[["usize"]],["bool"]]],[11,"extract_unchecked","","Extracts the value at `index`.",26,[[["usize"]],["bool"]]],[11,"replace","","Returns a new vector where the value at `index` is…",26,[[["usize"],["bool"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",26,[[["usize"],["bool"]],["self"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",26,[[],["bool"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",26,[[],["bool"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",26,[[],["bool"]]],[11,"all","","Are `all` vector lanes `true`?",26,[[],["bool"]]],[11,"any","","Is `any` vector lane `true`?",26,[[],["bool"]]],[11,"none","","Are `all` vector lanes `false`?",26,[[],["bool"]]],[11,"eq","","Lane-wise equality comparison.",26,[[],["m8x8"]]],[11,"ne","","Lane-wise inequality comparison.",26,[[],["m8x8"]]],[11,"lt","","Lane-wise less-than comparison.",26,[[],["m8x8"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",26,[[],["m8x8"]]],[11,"gt","","Lane-wise greater-than comparison.",26,[[],["m8x8"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",26,[[],["m8x8"]]],[11,"select","","Selects elements of `a` and `b` using mask.",26,[[["simd"]],["simd"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",26,[[["self"]],[["lexicographicallyordered",["m8x8"]],["m8x8"]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",26,[[["self"]],[["lexicographicallyordered",["m8x8"]],["m8x8"]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",26,[[["i"]],["self"]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",26,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",27,[[["i16"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",27,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",27,[[["i16"]],["self"]]],[11,"extract","","Extracts the value at `index`.",27,[[["usize"]],["i16"]]],[11,"extract_unchecked","","Extracts the value at `index`.",27,[[["usize"]],["i16"]]],[11,"replace","","Returns a new vector where the value at `index` is…",27,[[["usize"],["i16"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",27,[[["usize"],["i16"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",27,[[["i16x4"]],["i16x4"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",27,[[["i16x4"]],["i16x4"]]],[11,"min","","Minimum of two vectors.",27,[[],["self"]]],[11,"max","","Maximum of two vectors.",27,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",27,[[],["i16"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",27,[[],["i16"]]],[11,"max_element","","Largest vector element value.",27,[[],["i16"]]],[11,"min_element","","Smallest vector element value.",27,[[],["i16"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",27,[[],["i16"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",27,[[],["i16"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",27,[[],["i16"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",27,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",27,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",27,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",27,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",27,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",27,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",27,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",27,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",27,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",27,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",27,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",27,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",27,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",27,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",27,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",27,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",27,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",27,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",27,[[],["m16x4"]]],[11,"ne","","Lane-wise inequality comparison.",27,[[],["m16x4"]]],[11,"lt","","Lane-wise less-than comparison.",27,[[],["m16x4"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",27,[[],["m16x4"]]],[11,"gt","","Lane-wise greater-than comparison.",27,[[],["m16x4"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",27,[[],["m16x4"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",27,[[["self"]],[["lexicographicallyordered",["i16x4"]],["i16x4"]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",27,[[["self"]],[["lexicographicallyordered",["i16x4"]],["i16x4"]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",27,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",28,[[["u16"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",28,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",28,[[["u16"]],["self"]]],[11,"extract","","Extracts the value at `index`.",28,[[["usize"]],["u16"]]],[11,"extract_unchecked","","Extracts the value at `index`.",28,[[["usize"]],["u16"]]],[11,"replace","","Returns a new vector where the value at `index` is…",28,[[["u16"],["usize"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",28,[[["u16"],["usize"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",28,[[["u16x4"]],["u16x4"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",28,[[["u16x4"]],["u16x4"]]],[11,"min","","Minimum of two vectors.",28,[[],["self"]]],[11,"max","","Maximum of two vectors.",28,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",28,[[],["u16"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",28,[[],["u16"]]],[11,"max_element","","Largest vector element value.",28,[[],["u16"]]],[11,"min_element","","Smallest vector element value.",28,[[],["u16"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",28,[[],["u16"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",28,[[],["u16"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",28,[[],["u16"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",28,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",28,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",28,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",28,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",28,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",28,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",28,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",28,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",28,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",28,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",28,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",28,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",28,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",28,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",28,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",28,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",28,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",28,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",28,[[],["m16x4"]]],[11,"ne","","Lane-wise inequality comparison.",28,[[],["m16x4"]]],[11,"lt","","Lane-wise less-than comparison.",28,[[],["m16x4"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",28,[[],["m16x4"]]],[11,"gt","","Lane-wise greater-than comparison.",28,[[],["m16x4"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",28,[[],["m16x4"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",28,[[["self"]],[["lexicographicallyordered",["u16x4"]],["u16x4"]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",28,[[["self"]],[["lexicographicallyordered",["u16x4"]],["u16x4"]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",28,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",29,[[["bool"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",29,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",29,[[["bool"]],["self"]]],[11,"extract","","Extracts the value at `index`.",29,[[["usize"]],["bool"]]],[11,"extract_unchecked","","Extracts the value at `index`.",29,[[["usize"]],["bool"]]],[11,"replace","","Returns a new vector where the value at `index` is…",29,[[["usize"],["bool"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",29,[[["usize"],["bool"]],["self"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",29,[[],["bool"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",29,[[],["bool"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",29,[[],["bool"]]],[11,"all","","Are `all` vector lanes `true`?",29,[[],["bool"]]],[11,"any","","Is `any` vector lane `true`?",29,[[],["bool"]]],[11,"none","","Are `all` vector lanes `false`?",29,[[],["bool"]]],[11,"eq","","Lane-wise equality comparison.",29,[[],["m16x4"]]],[11,"ne","","Lane-wise inequality comparison.",29,[[],["m16x4"]]],[11,"lt","","Lane-wise less-than comparison.",29,[[],["m16x4"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",29,[[],["m16x4"]]],[11,"gt","","Lane-wise greater-than comparison.",29,[[],["m16x4"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",29,[[],["m16x4"]]],[11,"select","","Selects elements of `a` and `b` using mask.",29,[[["simd"]],["simd"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",29,[[["self"]],[["lexicographicallyordered",["m16x4"]],["m16x4"]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",29,[[["self"]],[["lexicographicallyordered",["m16x4"]],["m16x4"]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",29,[[["i"]],["self"]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",29,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",30,[[["i32"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",30,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",30,[[["i32"]],["self"]]],[11,"extract","","Extracts the value at `index`.",30,[[["usize"]],["i32"]]],[11,"extract_unchecked","","Extracts the value at `index`.",30,[[["usize"]],["i32"]]],[11,"replace","","Returns a new vector where the value at `index` is…",30,[[["usize"],["i32"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",30,[[["usize"],["i32"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",30,[[["i32x2"]],["i32x2"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",30,[[["i32x2"]],["i32x2"]]],[11,"min","","Minimum of two vectors.",30,[[],["self"]]],[11,"max","","Maximum of two vectors.",30,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",30,[[],["i32"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",30,[[],["i32"]]],[11,"max_element","","Largest vector element value.",30,[[],["i32"]]],[11,"min_element","","Smallest vector element value.",30,[[],["i32"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",30,[[],["i32"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",30,[[],["i32"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",30,[[],["i32"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",30,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",30,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",30,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",30,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",30,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",30,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",30,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",30,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",30,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",30,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",30,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",30,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",30,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",30,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",30,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",30,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",30,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",30,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",30,[[],["m32x2"]]],[11,"ne","","Lane-wise inequality comparison.",30,[[],["m32x2"]]],[11,"lt","","Lane-wise less-than comparison.",30,[[],["m32x2"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",30,[[],["m32x2"]]],[11,"gt","","Lane-wise greater-than comparison.",30,[[],["m32x2"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",30,[[],["m32x2"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",30,[[["self"]],[["i32x2"],["lexicographicallyordered",["i32x2"]]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",30,[[["self"]],[["i32x2"],["lexicographicallyordered",["i32x2"]]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",30,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",31,[[["u32"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",31,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",31,[[["u32"]],["self"]]],[11,"extract","","Extracts the value at `index`.",31,[[["usize"]],["u32"]]],[11,"extract_unchecked","","Extracts the value at `index`.",31,[[["usize"]],["u32"]]],[11,"replace","","Returns a new vector where the value at `index` is…",31,[[["u32"],["usize"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",31,[[["u32"],["usize"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",31,[[["u32x2"]],["u32x2"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",31,[[["u32x2"]],["u32x2"]]],[11,"min","","Minimum of two vectors.",31,[[],["self"]]],[11,"max","","Maximum of two vectors.",31,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",31,[[],["u32"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",31,[[],["u32"]]],[11,"max_element","","Largest vector element value.",31,[[],["u32"]]],[11,"min_element","","Smallest vector element value.",31,[[],["u32"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",31,[[],["u32"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",31,[[],["u32"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",31,[[],["u32"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",31,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",31,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",31,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",31,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",31,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",31,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",31,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",31,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",31,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",31,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",31,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",31,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",31,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",31,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",31,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",31,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",31,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",31,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",31,[[],["m32x2"]]],[11,"ne","","Lane-wise inequality comparison.",31,[[],["m32x2"]]],[11,"lt","","Lane-wise less-than comparison.",31,[[],["m32x2"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",31,[[],["m32x2"]]],[11,"gt","","Lane-wise greater-than comparison.",31,[[],["m32x2"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",31,[[],["m32x2"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",31,[[["self"]],[["u32x2"],["lexicographicallyordered",["u32x2"]]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",31,[[["self"]],[["u32x2"],["lexicographicallyordered",["u32x2"]]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",31,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",33,[[["bool"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",33,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",33,[[["bool"]],["self"]]],[11,"extract","","Extracts the value at `index`.",33,[[["usize"]],["bool"]]],[11,"extract_unchecked","","Extracts the value at `index`.",33,[[["usize"]],["bool"]]],[11,"replace","","Returns a new vector where the value at `index` is…",33,[[["usize"],["bool"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",33,[[["usize"],["bool"]],["self"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",33,[[],["bool"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",33,[[],["bool"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",33,[[],["bool"]]],[11,"all","","Are `all` vector lanes `true`?",33,[[],["bool"]]],[11,"any","","Is `any` vector lane `true`?",33,[[],["bool"]]],[11,"none","","Are `all` vector lanes `false`?",33,[[],["bool"]]],[11,"eq","","Lane-wise equality comparison.",33,[[],["m32x2"]]],[11,"ne","","Lane-wise inequality comparison.",33,[[],["m32x2"]]],[11,"lt","","Lane-wise less-than comparison.",33,[[],["m32x2"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",33,[[],["m32x2"]]],[11,"gt","","Lane-wise greater-than comparison.",33,[[],["m32x2"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",33,[[],["m32x2"]]],[11,"select","","Selects elements of `a` and `b` using mask.",33,[[["simd"]],["simd"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",33,[[["self"]],[["lexicographicallyordered",["m32x2"]],["m32x2"]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",33,[[["self"]],[["lexicographicallyordered",["m32x2"]],["m32x2"]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",33,[[["i"]],["self"]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",33,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",32,[[["f32"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",32,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",32,[[["f32"]],["self"]]],[11,"extract","","Extracts the value at `index`.",32,[[["usize"]],["f32"]]],[11,"extract_unchecked","","Extracts the value at `index`.",32,[[["usize"]],["f32"]]],[11,"replace","","Returns a new vector where the value at `index` is…",32,[[["f32"],["usize"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",32,[[["f32"],["usize"]],["self"]]],[11,"min","","Minimum of two vectors.",32,[[],["self"]]],[11,"max","","Maximum of two vectors.",32,[[],["self"]]],[11,"sum","","Horizontal sum of the vector elements.",32,[[],["f32"]]],[11,"product","","Horizontal product of the vector elements.",32,[[],["f32"]]],[11,"max_element","","Largest vector element value.",32,[[],["f32"]]],[11,"min_element","","Smallest vector element value.",32,[[],["f32"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",32,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",32,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",32,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",32,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",32,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",32,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",32,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",32,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",32,[[["i"]],["self"]]],[18,"EPSILON","","Machine epsilon value.",32,null],[18,"MIN","","Smallest finite value.",32,null],[18,"MIN_POSITIVE","","Smallest positive normal value.",32,null],[18,"MAX","","Largest finite value.",32,null],[18,"NAN","","Not a Number (NaN).",32,null],[18,"INFINITY","","Infinity (∞).",32,null],[18,"NEG_INFINITY","","Negative infinity (-∞).",32,null],[18,"PI","","Archimedes' constant (π)",32,null],[18,"FRAC_PI_2","","π/2",32,null],[18,"FRAC_PI_3","","π/3",32,null],[18,"FRAC_PI_4","","π/4",32,null],[18,"FRAC_PI_6","","π/6",32,null],[18,"FRAC_PI_8","","π/8",32,null],[18,"FRAC_1_PI","","1/π",32,null],[18,"FRAC_2_PI","","2/π",32,null],[18,"FRAC_2_SQRT_PI","","2/sqrt(π)",32,null],[18,"SQRT_2","","sqrt(2)",32,null],[18,"FRAC_1_SQRT_2","","1/sqrt(2)",32,null],[18,"E","","Euler's number (e)",32,null],[18,"LOG2_E","","log2(e)",32,null],[18,"LOG10_E","","log10(e)",32,null],[18,"LN_2","","ln(2)",32,null],[18,"LN_10","","ln(10)",32,null],[11,"is_nan","","",32,[[],["m32x2"]]],[11,"is_infinite","","",32,[[],["m32x2"]]],[11,"is_finite","","",32,[[],["m32x2"]]],[11,"abs","","Absolute value.",32,[[],["self"]]],[11,"cos","","Cosine.",32,[[],["self"]]],[11,"cos_pi","","Cosine of `self * PI`.",32,[[],["self"]]],[11,"exp","","Returns the exponential function of `self`: `e^(self)`.",32,[[],["self"]]],[11,"ln","","Returns the natural logarithm of `self`.",32,[[],["self"]]],[11,"mul_add","","Fused multiply add: `self * y + z`",32,[[],["self"]]],[11,"mul_adde","","Fused multiply add estimate: ~= `self * y + z`",32,[[],["self"]]],[11,"powf","","Raises `self` number to the floating point power of `x`.",32,[[],["self"]]],[11,"recpre","","Reciprocal estimate: `~= 1. / self`.",32,[[],["self"]]],[11,"rsqrte","","Reciprocal square-root estimate: `~= 1. / self.sqrt()`.",32,[[],["self"]]],[11,"sin","","Sine.",32,[[],["self"]]],[11,"sin_pi","","Sine of `self * PI`.",32,[[],["self"]]],[11,"sin_cos_pi","","Sine and cosine of `self * PI`.",32,[[]]],[11,"sqrt","","",32,[[],["self"]]],[11,"sqrte","","Square-root estimate.",32,[[],["self"]]],[11,"tanh","","Tanh.",32,[[],["self"]]],[11,"eq","","Lane-wise equality comparison.",32,[[],["m32x2"]]],[11,"ne","","Lane-wise inequality comparison.",32,[[],["m32x2"]]],[11,"lt","","Lane-wise less-than comparison.",32,[[],["m32x2"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",32,[[],["m32x2"]]],[11,"gt","","Lane-wise greater-than comparison.",32,[[],["m32x2"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",32,[[],["m32x2"]]],[11,"new","","Creates a new instance with each vector elements…",34,[[["i8"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",34,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",34,[[["i8"]],["self"]]],[11,"extract","","Extracts the value at `index`.",34,[[["usize"]],["i8"]]],[11,"extract_unchecked","","Extracts the value at `index`.",34,[[["usize"]],["i8"]]],[11,"replace","","Returns a new vector where the value at `index` is…",34,[[["i8"],["usize"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",34,[[["i8"],["usize"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",34,[[["i8x16"]],["i8x16"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",34,[[["i8x16"]],["i8x16"]]],[11,"min","","Minimum of two vectors.",34,[[],["self"]]],[11,"max","","Maximum of two vectors.",34,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",34,[[],["i8"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",34,[[],["i8"]]],[11,"max_element","","Largest vector element value.",34,[[],["i8"]]],[11,"min_element","","Smallest vector element value.",34,[[],["i8"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",34,[[],["i8"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",34,[[],["i8"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",34,[[],["i8"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",34,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",34,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",34,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",34,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",34,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",34,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",34,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",34,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",34,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",34,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",34,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",34,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",34,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",34,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",34,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",34,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",34,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",34,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",34,[[],["m8x16"]]],[11,"ne","","Lane-wise inequality comparison.",34,[[],["m8x16"]]],[11,"lt","","Lane-wise less-than comparison.",34,[[],["m8x16"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",34,[[],["m8x16"]]],[11,"gt","","Lane-wise greater-than comparison.",34,[[],["m8x16"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",34,[[],["m8x16"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",34,[[["self"]],[["i8x16"],["lexicographicallyordered",["i8x16"]]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",34,[[["self"]],[["i8x16"],["lexicographicallyordered",["i8x16"]]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",34,[[],["u16"]]],[11,"new","","Creates a new instance with each vector elements…",35,[[["u8"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",35,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",35,[[["u8"]],["self"]]],[11,"extract","","Extracts the value at `index`.",35,[[["usize"]],["u8"]]],[11,"extract_unchecked","","Extracts the value at `index`.",35,[[["usize"]],["u8"]]],[11,"replace","","Returns a new vector where the value at `index` is…",35,[[["usize"],["u8"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",35,[[["usize"],["u8"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",35,[[["u8x16"]],["u8x16"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",35,[[["u8x16"]],["u8x16"]]],[11,"min","","Minimum of two vectors.",35,[[],["self"]]],[11,"max","","Maximum of two vectors.",35,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",35,[[],["u8"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",35,[[],["u8"]]],[11,"max_element","","Largest vector element value.",35,[[],["u8"]]],[11,"min_element","","Smallest vector element value.",35,[[],["u8"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",35,[[],["u8"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",35,[[],["u8"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",35,[[],["u8"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",35,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",35,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",35,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",35,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",35,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",35,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",35,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",35,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",35,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",35,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",35,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",35,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",35,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",35,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",35,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",35,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",35,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",35,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",35,[[],["m8x16"]]],[11,"ne","","Lane-wise inequality comparison.",35,[[],["m8x16"]]],[11,"lt","","Lane-wise less-than comparison.",35,[[],["m8x16"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",35,[[],["m8x16"]]],[11,"gt","","Lane-wise greater-than comparison.",35,[[],["m8x16"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",35,[[],["m8x16"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",35,[[["self"]],[["lexicographicallyordered",["u8x16"]],["u8x16"]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",35,[[["self"]],[["lexicographicallyordered",["u8x16"]],["u8x16"]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",35,[[],["u16"]]],[11,"new","","Creates a new instance with each vector elements…",36,[[["bool"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",36,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",36,[[["bool"]],["self"]]],[11,"extract","","Extracts the value at `index`.",36,[[["usize"]],["bool"]]],[11,"extract_unchecked","","Extracts the value at `index`.",36,[[["usize"]],["bool"]]],[11,"replace","","Returns a new vector where the value at `index` is…",36,[[["usize"],["bool"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",36,[[["usize"],["bool"]],["self"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",36,[[],["bool"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",36,[[],["bool"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",36,[[],["bool"]]],[11,"all","","Are `all` vector lanes `true`?",36,[[],["bool"]]],[11,"any","","Is `any` vector lane `true`?",36,[[],["bool"]]],[11,"none","","Are `all` vector lanes `false`?",36,[[],["bool"]]],[11,"eq","","Lane-wise equality comparison.",36,[[],["m8x16"]]],[11,"ne","","Lane-wise inequality comparison.",36,[[],["m8x16"]]],[11,"lt","","Lane-wise less-than comparison.",36,[[],["m8x16"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",36,[[],["m8x16"]]],[11,"gt","","Lane-wise greater-than comparison.",36,[[],["m8x16"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",36,[[],["m8x16"]]],[11,"select","","Selects elements of `a` and `b` using mask.",36,[[["simd"]],["simd"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",36,[[["self"]],[["m8x16"],["lexicographicallyordered",["m8x16"]]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",36,[[["self"]],[["m8x16"],["lexicographicallyordered",["m8x16"]]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",36,[[["i"]],["self"]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",36,[[],["u16"]]],[11,"new","","Creates a new instance with each vector elements…",37,[[["i16"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",37,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",37,[[["i16"]],["self"]]],[11,"extract","","Extracts the value at `index`.",37,[[["usize"]],["i16"]]],[11,"extract_unchecked","","Extracts the value at `index`.",37,[[["usize"]],["i16"]]],[11,"replace","","Returns a new vector where the value at `index` is…",37,[[["usize"],["i16"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",37,[[["usize"],["i16"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",37,[[["i16x8"]],["i16x8"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",37,[[["i16x8"]],["i16x8"]]],[11,"min","","Minimum of two vectors.",37,[[],["self"]]],[11,"max","","Maximum of two vectors.",37,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",37,[[],["i16"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",37,[[],["i16"]]],[11,"max_element","","Largest vector element value.",37,[[],["i16"]]],[11,"min_element","","Smallest vector element value.",37,[[],["i16"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",37,[[],["i16"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",37,[[],["i16"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",37,[[],["i16"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",37,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",37,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",37,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",37,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",37,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",37,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",37,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",37,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",37,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",37,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",37,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",37,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",37,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",37,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",37,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",37,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",37,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",37,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",37,[[],["m16x8"]]],[11,"ne","","Lane-wise inequality comparison.",37,[[],["m16x8"]]],[11,"lt","","Lane-wise less-than comparison.",37,[[],["m16x8"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",37,[[],["m16x8"]]],[11,"gt","","Lane-wise greater-than comparison.",37,[[],["m16x8"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",37,[[],["m16x8"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",37,[[["self"]],[["lexicographicallyordered",["i16x8"]],["i16x8"]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",37,[[["self"]],[["lexicographicallyordered",["i16x8"]],["i16x8"]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",37,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",38,[[["u16"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",38,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",38,[[["u16"]],["self"]]],[11,"extract","","Extracts the value at `index`.",38,[[["usize"]],["u16"]]],[11,"extract_unchecked","","Extracts the value at `index`.",38,[[["usize"]],["u16"]]],[11,"replace","","Returns a new vector where the value at `index` is…",38,[[["u16"],["usize"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",38,[[["u16"],["usize"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",38,[[["u16x8"]],["u16x8"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",38,[[["u16x8"]],["u16x8"]]],[11,"min","","Minimum of two vectors.",38,[[],["self"]]],[11,"max","","Maximum of two vectors.",38,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",38,[[],["u16"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",38,[[],["u16"]]],[11,"max_element","","Largest vector element value.",38,[[],["u16"]]],[11,"min_element","","Smallest vector element value.",38,[[],["u16"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",38,[[],["u16"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",38,[[],["u16"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",38,[[],["u16"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",38,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",38,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",38,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",38,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",38,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",38,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",38,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",38,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",38,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",38,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",38,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",38,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",38,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",38,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",38,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",38,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",38,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",38,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",38,[[],["m16x8"]]],[11,"ne","","Lane-wise inequality comparison.",38,[[],["m16x8"]]],[11,"lt","","Lane-wise less-than comparison.",38,[[],["m16x8"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",38,[[],["m16x8"]]],[11,"gt","","Lane-wise greater-than comparison.",38,[[],["m16x8"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",38,[[],["m16x8"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",38,[[["self"]],[["lexicographicallyordered",["u16x8"]],["u16x8"]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",38,[[["self"]],[["lexicographicallyordered",["u16x8"]],["u16x8"]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",38,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",39,[[["bool"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",39,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",39,[[["bool"]],["self"]]],[11,"extract","","Extracts the value at `index`.",39,[[["usize"]],["bool"]]],[11,"extract_unchecked","","Extracts the value at `index`.",39,[[["usize"]],["bool"]]],[11,"replace","","Returns a new vector where the value at `index` is…",39,[[["usize"],["bool"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",39,[[["usize"],["bool"]],["self"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",39,[[],["bool"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",39,[[],["bool"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",39,[[],["bool"]]],[11,"all","","Are `all` vector lanes `true`?",39,[[],["bool"]]],[11,"any","","Is `any` vector lane `true`?",39,[[],["bool"]]],[11,"none","","Are `all` vector lanes `false`?",39,[[],["bool"]]],[11,"eq","","Lane-wise equality comparison.",39,[[],["m16x8"]]],[11,"ne","","Lane-wise inequality comparison.",39,[[],["m16x8"]]],[11,"lt","","Lane-wise less-than comparison.",39,[[],["m16x8"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",39,[[],["m16x8"]]],[11,"gt","","Lane-wise greater-than comparison.",39,[[],["m16x8"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",39,[[],["m16x8"]]],[11,"select","","Selects elements of `a` and `b` using mask.",39,[[["simd"]],["simd"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",39,[[["self"]],[["m16x8"],["lexicographicallyordered",["m16x8"]]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",39,[[["self"]],[["m16x8"],["lexicographicallyordered",["m16x8"]]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",39,[[["i"]],["self"]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",39,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",40,[[["i32"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",40,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",40,[[["i32"]],["self"]]],[11,"extract","","Extracts the value at `index`.",40,[[["usize"]],["i32"]]],[11,"extract_unchecked","","Extracts the value at `index`.",40,[[["usize"]],["i32"]]],[11,"replace","","Returns a new vector where the value at `index` is…",40,[[["usize"],["i32"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",40,[[["usize"],["i32"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",40,[[["i32x4"]],["i32x4"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",40,[[["i32x4"]],["i32x4"]]],[11,"min","","Minimum of two vectors.",40,[[],["self"]]],[11,"max","","Maximum of two vectors.",40,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",40,[[],["i32"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",40,[[],["i32"]]],[11,"max_element","","Largest vector element value.",40,[[],["i32"]]],[11,"min_element","","Smallest vector element value.",40,[[],["i32"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",40,[[],["i32"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",40,[[],["i32"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",40,[[],["i32"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",40,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",40,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",40,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",40,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",40,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",40,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",40,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",40,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",40,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",40,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",40,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",40,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",40,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",40,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",40,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",40,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",40,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",40,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",40,[[],["m32x4"]]],[11,"ne","","Lane-wise inequality comparison.",40,[[],["m32x4"]]],[11,"lt","","Lane-wise less-than comparison.",40,[[],["m32x4"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",40,[[],["m32x4"]]],[11,"gt","","Lane-wise greater-than comparison.",40,[[],["m32x4"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",40,[[],["m32x4"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",40,[[["self"]],[["i32x4"],["lexicographicallyordered",["i32x4"]]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",40,[[["self"]],[["i32x4"],["lexicographicallyordered",["i32x4"]]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",40,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",41,[[["u32"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",41,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",41,[[["u32"]],["self"]]],[11,"extract","","Extracts the value at `index`.",41,[[["usize"]],["u32"]]],[11,"extract_unchecked","","Extracts the value at `index`.",41,[[["usize"]],["u32"]]],[11,"replace","","Returns a new vector where the value at `index` is…",41,[[["u32"],["usize"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",41,[[["u32"],["usize"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",41,[[["u32x4"]],["u32x4"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",41,[[["u32x4"]],["u32x4"]]],[11,"min","","Minimum of two vectors.",41,[[],["self"]]],[11,"max","","Maximum of two vectors.",41,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",41,[[],["u32"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",41,[[],["u32"]]],[11,"max_element","","Largest vector element value.",41,[[],["u32"]]],[11,"min_element","","Smallest vector element value.",41,[[],["u32"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",41,[[],["u32"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",41,[[],["u32"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",41,[[],["u32"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",41,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",41,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",41,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",41,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",41,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",41,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",41,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",41,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",41,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",41,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",41,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",41,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",41,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",41,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",41,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",41,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",41,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",41,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",41,[[],["m32x4"]]],[11,"ne","","Lane-wise inequality comparison.",41,[[],["m32x4"]]],[11,"lt","","Lane-wise less-than comparison.",41,[[],["m32x4"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",41,[[],["m32x4"]]],[11,"gt","","Lane-wise greater-than comparison.",41,[[],["m32x4"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",41,[[],["m32x4"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",41,[[["self"]],[["u32x4"],["lexicographicallyordered",["u32x4"]]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",41,[[["self"]],[["u32x4"],["lexicographicallyordered",["u32x4"]]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",41,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",42,[[["f32"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",42,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",42,[[["f32"]],["self"]]],[11,"extract","","Extracts the value at `index`.",42,[[["usize"]],["f32"]]],[11,"extract_unchecked","","Extracts the value at `index`.",42,[[["usize"]],["f32"]]],[11,"replace","","Returns a new vector where the value at `index` is…",42,[[["f32"],["usize"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",42,[[["f32"],["usize"]],["self"]]],[11,"min","","Minimum of two vectors.",42,[[],["self"]]],[11,"max","","Maximum of two vectors.",42,[[],["self"]]],[11,"sum","","Horizontal sum of the vector elements.",42,[[],["f32"]]],[11,"product","","Horizontal product of the vector elements.",42,[[],["f32"]]],[11,"max_element","","Largest vector element value.",42,[[],["f32"]]],[11,"min_element","","Smallest vector element value.",42,[[],["f32"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",42,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",42,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",42,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",42,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",42,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",42,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",42,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",42,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",42,[[["i"]],["self"]]],[18,"EPSILON","","Machine epsilon value.",42,null],[18,"MIN","","Smallest finite value.",42,null],[18,"MIN_POSITIVE","","Smallest positive normal value.",42,null],[18,"MAX","","Largest finite value.",42,null],[18,"NAN","","Not a Number (NaN).",42,null],[18,"INFINITY","","Infinity (∞).",42,null],[18,"NEG_INFINITY","","Negative infinity (-∞).",42,null],[18,"PI","","Archimedes' constant (π)",42,null],[18,"FRAC_PI_2","","π/2",42,null],[18,"FRAC_PI_3","","π/3",42,null],[18,"FRAC_PI_4","","π/4",42,null],[18,"FRAC_PI_6","","π/6",42,null],[18,"FRAC_PI_8","","π/8",42,null],[18,"FRAC_1_PI","","1/π",42,null],[18,"FRAC_2_PI","","2/π",42,null],[18,"FRAC_2_SQRT_PI","","2/sqrt(π)",42,null],[18,"SQRT_2","","sqrt(2)",42,null],[18,"FRAC_1_SQRT_2","","1/sqrt(2)",42,null],[18,"E","","Euler's number (e)",42,null],[18,"LOG2_E","","log2(e)",42,null],[18,"LOG10_E","","log10(e)",42,null],[18,"LN_2","","ln(2)",42,null],[18,"LN_10","","ln(10)",42,null],[11,"is_nan","","",42,[[],["m32x4"]]],[11,"is_infinite","","",42,[[],["m32x4"]]],[11,"is_finite","","",42,[[],["m32x4"]]],[11,"abs","","Absolute value.",42,[[],["self"]]],[11,"cos","","Cosine.",42,[[],["self"]]],[11,"cos_pi","","Cosine of `self * PI`.",42,[[],["self"]]],[11,"exp","","Returns the exponential function of `self`: `e^(self)`.",42,[[],["self"]]],[11,"ln","","Returns the natural logarithm of `self`.",42,[[],["self"]]],[11,"mul_add","","Fused multiply add: `self * y + z`",42,[[],["self"]]],[11,"mul_adde","","Fused multiply add estimate: ~= `self * y + z`",42,[[],["self"]]],[11,"powf","","Raises `self` number to the floating point power of `x`.",42,[[],["self"]]],[11,"recpre","","Reciprocal estimate: `~= 1. / self`.",42,[[],["self"]]],[11,"rsqrte","","Reciprocal square-root estimate: `~= 1. / self.sqrt()`.",42,[[],["self"]]],[11,"sin","","Sine.",42,[[],["self"]]],[11,"sin_pi","","Sine of `self * PI`.",42,[[],["self"]]],[11,"sin_cos_pi","","Sine and cosine of `self * PI`.",42,[[]]],[11,"sqrt","","",42,[[],["self"]]],[11,"sqrte","","Square-root estimate.",42,[[],["self"]]],[11,"tanh","","Tanh.",42,[[],["self"]]],[11,"eq","","Lane-wise equality comparison.",42,[[],["m32x4"]]],[11,"ne","","Lane-wise inequality comparison.",42,[[],["m32x4"]]],[11,"lt","","Lane-wise less-than comparison.",42,[[],["m32x4"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",42,[[],["m32x4"]]],[11,"gt","","Lane-wise greater-than comparison.",42,[[],["m32x4"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",42,[[],["m32x4"]]],[11,"new","","Creates a new instance with each vector elements…",43,[[["bool"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",43,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",43,[[["bool"]],["self"]]],[11,"extract","","Extracts the value at `index`.",43,[[["usize"]],["bool"]]],[11,"extract_unchecked","","Extracts the value at `index`.",43,[[["usize"]],["bool"]]],[11,"replace","","Returns a new vector where the value at `index` is…",43,[[["usize"],["bool"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",43,[[["usize"],["bool"]],["self"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",43,[[],["bool"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",43,[[],["bool"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",43,[[],["bool"]]],[11,"all","","Are `all` vector lanes `true`?",43,[[],["bool"]]],[11,"any","","Is `any` vector lane `true`?",43,[[],["bool"]]],[11,"none","","Are `all` vector lanes `false`?",43,[[],["bool"]]],[11,"eq","","Lane-wise equality comparison.",43,[[],["m32x4"]]],[11,"ne","","Lane-wise inequality comparison.",43,[[],["m32x4"]]],[11,"lt","","Lane-wise less-than comparison.",43,[[],["m32x4"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",43,[[],["m32x4"]]],[11,"gt","","Lane-wise greater-than comparison.",43,[[],["m32x4"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",43,[[],["m32x4"]]],[11,"select","","Selects elements of `a` and `b` using mask.",43,[[["simd"]],["simd"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",43,[[["self"]],[["lexicographicallyordered",["m32x4"]],["m32x4"]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",43,[[["self"]],[["lexicographicallyordered",["m32x4"]],["m32x4"]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",43,[[["i"]],["self"]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",43,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",44,[[["i64"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",44,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",44,[[["i64"]],["self"]]],[11,"extract","","Extracts the value at `index`.",44,[[["usize"]],["i64"]]],[11,"extract_unchecked","","Extracts the value at `index`.",44,[[["usize"]],["i64"]]],[11,"replace","","Returns a new vector where the value at `index` is…",44,[[["i64"],["usize"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",44,[[["i64"],["usize"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",44,[[["i64x2"]],["i64x2"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",44,[[["i64x2"]],["i64x2"]]],[11,"min","","Minimum of two vectors.",44,[[],["self"]]],[11,"max","","Maximum of two vectors.",44,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",44,[[],["i64"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",44,[[],["i64"]]],[11,"max_element","","Largest vector element value.",44,[[],["i64"]]],[11,"min_element","","Smallest vector element value.",44,[[],["i64"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",44,[[],["i64"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",44,[[],["i64"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",44,[[],["i64"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",44,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",44,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",44,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",44,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",44,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",44,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",44,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",44,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",44,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",44,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",44,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",44,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",44,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",44,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",44,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",44,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",44,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",44,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",44,[[],["m64x2"]]],[11,"ne","","Lane-wise inequality comparison.",44,[[],["m64x2"]]],[11,"lt","","Lane-wise less-than comparison.",44,[[],["m64x2"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",44,[[],["m64x2"]]],[11,"gt","","Lane-wise greater-than comparison.",44,[[],["m64x2"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",44,[[],["m64x2"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",44,[[["self"]],[["i64x2"],["lexicographicallyordered",["i64x2"]]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",44,[[["self"]],[["i64x2"],["lexicographicallyordered",["i64x2"]]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",44,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",45,[[["u64"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",45,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",45,[[["u64"]],["self"]]],[11,"extract","","Extracts the value at `index`.",45,[[["usize"]],["u64"]]],[11,"extract_unchecked","","Extracts the value at `index`.",45,[[["usize"]],["u64"]]],[11,"replace","","Returns a new vector where the value at `index` is…",45,[[["usize"],["u64"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",45,[[["usize"],["u64"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",45,[[["u64x2"]],["u64x2"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",45,[[["u64x2"]],["u64x2"]]],[11,"min","","Minimum of two vectors.",45,[[],["self"]]],[11,"max","","Maximum of two vectors.",45,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",45,[[],["u64"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",45,[[],["u64"]]],[11,"max_element","","Largest vector element value.",45,[[],["u64"]]],[11,"min_element","","Smallest vector element value.",45,[[],["u64"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",45,[[],["u64"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",45,[[],["u64"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",45,[[],["u64"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",45,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",45,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",45,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",45,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",45,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",45,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",45,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",45,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",45,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",45,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",45,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",45,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",45,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",45,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",45,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",45,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",45,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",45,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",45,[[],["m64x2"]]],[11,"ne","","Lane-wise inequality comparison.",45,[[],["m64x2"]]],[11,"lt","","Lane-wise less-than comparison.",45,[[],["m64x2"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",45,[[],["m64x2"]]],[11,"gt","","Lane-wise greater-than comparison.",45,[[],["m64x2"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",45,[[],["m64x2"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",45,[[["self"]],[["u64x2"],["lexicographicallyordered",["u64x2"]]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",45,[[["self"]],[["u64x2"],["lexicographicallyordered",["u64x2"]]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",45,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",46,[[["f64"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",46,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",46,[[["f64"]],["self"]]],[11,"extract","","Extracts the value at `index`.",46,[[["usize"]],["f64"]]],[11,"extract_unchecked","","Extracts the value at `index`.",46,[[["usize"]],["f64"]]],[11,"replace","","Returns a new vector where the value at `index` is…",46,[[["f64"],["usize"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",46,[[["f64"],["usize"]],["self"]]],[11,"min","","Minimum of two vectors.",46,[[],["self"]]],[11,"max","","Maximum of two vectors.",46,[[],["self"]]],[11,"sum","","Horizontal sum of the vector elements.",46,[[],["f64"]]],[11,"product","","Horizontal product of the vector elements.",46,[[],["f64"]]],[11,"max_element","","Largest vector element value.",46,[[],["f64"]]],[11,"min_element","","Smallest vector element value.",46,[[],["f64"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",46,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",46,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",46,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",46,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",46,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",46,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",46,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",46,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",46,[[["i"]],["self"]]],[18,"EPSILON","","Machine epsilon value.",46,null],[18,"MIN","","Smallest finite value.",46,null],[18,"MIN_POSITIVE","","Smallest positive normal value.",46,null],[18,"MAX","","Largest finite value.",46,null],[18,"NAN","","Not a Number (NaN).",46,null],[18,"INFINITY","","Infinity (∞).",46,null],[18,"NEG_INFINITY","","Negative infinity (-∞).",46,null],[18,"PI","","Archimedes' constant (π)",46,null],[18,"FRAC_PI_2","","π/2",46,null],[18,"FRAC_PI_3","","π/3",46,null],[18,"FRAC_PI_4","","π/4",46,null],[18,"FRAC_PI_6","","π/6",46,null],[18,"FRAC_PI_8","","π/8",46,null],[18,"FRAC_1_PI","","1/π",46,null],[18,"FRAC_2_PI","","2/π",46,null],[18,"FRAC_2_SQRT_PI","","2/sqrt(π)",46,null],[18,"SQRT_2","","sqrt(2)",46,null],[18,"FRAC_1_SQRT_2","","1/sqrt(2)",46,null],[18,"E","","Euler's number (e)",46,null],[18,"LOG2_E","","log2(e)",46,null],[18,"LOG10_E","","log10(e)",46,null],[18,"LN_2","","ln(2)",46,null],[18,"LN_10","","ln(10)",46,null],[11,"is_nan","","",46,[[],["m64x2"]]],[11,"is_infinite","","",46,[[],["m64x2"]]],[11,"is_finite","","",46,[[],["m64x2"]]],[11,"abs","","Absolute value.",46,[[],["self"]]],[11,"cos","","Cosine.",46,[[],["self"]]],[11,"cos_pi","","Cosine of `self * PI`.",46,[[],["self"]]],[11,"exp","","Returns the exponential function of `self`: `e^(self)`.",46,[[],["self"]]],[11,"ln","","Returns the natural logarithm of `self`.",46,[[],["self"]]],[11,"mul_add","","Fused multiply add: `self * y + z`",46,[[],["self"]]],[11,"mul_adde","","Fused multiply add estimate: ~= `self * y + z`",46,[[],["self"]]],[11,"powf","","Raises `self` number to the floating point power of `x`.",46,[[],["self"]]],[11,"recpre","","Reciprocal estimate: `~= 1. / self`.",46,[[],["self"]]],[11,"rsqrte","","Reciprocal square-root estimate: `~= 1. / self.sqrt()`.",46,[[],["self"]]],[11,"sin","","Sine.",46,[[],["self"]]],[11,"sin_pi","","Sine of `self * PI`.",46,[[],["self"]]],[11,"sin_cos_pi","","Sine and cosine of `self * PI`.",46,[[]]],[11,"sqrt","","",46,[[],["self"]]],[11,"sqrte","","Square-root estimate.",46,[[],["self"]]],[11,"tanh","","Tanh.",46,[[],["self"]]],[11,"eq","","Lane-wise equality comparison.",46,[[],["m64x2"]]],[11,"ne","","Lane-wise inequality comparison.",46,[[],["m64x2"]]],[11,"lt","","Lane-wise less-than comparison.",46,[[],["m64x2"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",46,[[],["m64x2"]]],[11,"gt","","Lane-wise greater-than comparison.",46,[[],["m64x2"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",46,[[],["m64x2"]]],[11,"new","","Creates a new instance with each vector elements…",47,[[["bool"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",47,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",47,[[["bool"]],["self"]]],[11,"extract","","Extracts the value at `index`.",47,[[["usize"]],["bool"]]],[11,"extract_unchecked","","Extracts the value at `index`.",47,[[["usize"]],["bool"]]],[11,"replace","","Returns a new vector where the value at `index` is…",47,[[["usize"],["bool"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",47,[[["usize"],["bool"]],["self"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",47,[[],["bool"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",47,[[],["bool"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",47,[[],["bool"]]],[11,"all","","Are `all` vector lanes `true`?",47,[[],["bool"]]],[11,"any","","Is `any` vector lane `true`?",47,[[],["bool"]]],[11,"none","","Are `all` vector lanes `false`?",47,[[],["bool"]]],[11,"eq","","Lane-wise equality comparison.",47,[[],["m64x2"]]],[11,"ne","","Lane-wise inequality comparison.",47,[[],["m64x2"]]],[11,"lt","","Lane-wise less-than comparison.",47,[[],["m64x2"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",47,[[],["m64x2"]]],[11,"gt","","Lane-wise greater-than comparison.",47,[[],["m64x2"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",47,[[],["m64x2"]]],[11,"select","","Selects elements of `a` and `b` using mask.",47,[[["simd"]],["simd"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",47,[[["self"]],[["m64x2"],["lexicographicallyordered",["m64x2"]]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",47,[[["self"]],[["m64x2"],["lexicographicallyordered",["m64x2"]]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",47,[[["i"]],["self"]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",47,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",51,[[["i128"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",51,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",51,[[["i128"]],["self"]]],[11,"extract","","Extracts the value at `index`.",51,[[["usize"]],["i128"]]],[11,"extract_unchecked","","Extracts the value at `index`.",51,[[["usize"]],["i128"]]],[11,"replace","","Returns a new vector where the value at `index` is…",51,[[["i128"],["usize"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",51,[[["i128"],["usize"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",51,[[["i128x1"]],["i128x1"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",51,[[["i128x1"]],["i128x1"]]],[11,"min","","Minimum of two vectors.",51,[[],["self"]]],[11,"max","","Maximum of two vectors.",51,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",51,[[],["i128"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",51,[[],["i128"]]],[11,"max_element","","Largest vector element value.",51,[[],["i128"]]],[11,"min_element","","Smallest vector element value.",51,[[],["i128"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",51,[[],["i128"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",51,[[],["i128"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",51,[[],["i128"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",51,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",51,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",51,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",51,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",51,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",51,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",51,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",51,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",51,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",51,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",51,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",51,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",51,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",51,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",51,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",51,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",51,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",51,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",51,[[],["m128x1"]]],[11,"ne","","Lane-wise inequality comparison.",51,[[],["m128x1"]]],[11,"lt","","Lane-wise less-than comparison.",51,[[],["m128x1"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",51,[[],["m128x1"]]],[11,"gt","","Lane-wise greater-than comparison.",51,[[],["m128x1"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",51,[[],["m128x1"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",51,[[["self"]],[["lexicographicallyordered",["i128x1"]],["i128x1"]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",51,[[["self"]],[["lexicographicallyordered",["i128x1"]],["i128x1"]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",51,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",52,[[["u128"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",52,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",52,[[["u128"]],["self"]]],[11,"extract","","Extracts the value at `index`.",52,[[["usize"]],["u128"]]],[11,"extract_unchecked","","Extracts the value at `index`.",52,[[["usize"]],["u128"]]],[11,"replace","","Returns a new vector where the value at `index` is…",52,[[["usize"],["u128"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",52,[[["usize"],["u128"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",52,[[["u128x1"]],["u128x1"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",52,[[["u128x1"]],["u128x1"]]],[11,"min","","Minimum of two vectors.",52,[[],["self"]]],[11,"max","","Maximum of two vectors.",52,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",52,[[],["u128"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",52,[[],["u128"]]],[11,"max_element","","Largest vector element value.",52,[[],["u128"]]],[11,"min_element","","Smallest vector element value.",52,[[],["u128"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",52,[[],["u128"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",52,[[],["u128"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",52,[[],["u128"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",52,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",52,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",52,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",52,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",52,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",52,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",52,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",52,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",52,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",52,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",52,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",52,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",52,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",52,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",52,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",52,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",52,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",52,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",52,[[],["m128x1"]]],[11,"ne","","Lane-wise inequality comparison.",52,[[],["m128x1"]]],[11,"lt","","Lane-wise less-than comparison.",52,[[],["m128x1"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",52,[[],["m128x1"]]],[11,"gt","","Lane-wise greater-than comparison.",52,[[],["m128x1"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",52,[[],["m128x1"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",52,[[["self"]],[["u128x1"],["lexicographicallyordered",["u128x1"]]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",52,[[["self"]],[["u128x1"],["lexicographicallyordered",["u128x1"]]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",52,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",53,[[["bool"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",53,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",53,[[["bool"]],["self"]]],[11,"extract","","Extracts the value at `index`.",53,[[["usize"]],["bool"]]],[11,"extract_unchecked","","Extracts the value at `index`.",53,[[["usize"]],["bool"]]],[11,"replace","","Returns a new vector where the value at `index` is…",53,[[["usize"],["bool"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",53,[[["usize"],["bool"]],["self"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",53,[[],["bool"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",53,[[],["bool"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",53,[[],["bool"]]],[11,"all","","Are `all` vector lanes `true`?",53,[[],["bool"]]],[11,"any","","Is `any` vector lane `true`?",53,[[],["bool"]]],[11,"none","","Are `all` vector lanes `false`?",53,[[],["bool"]]],[11,"eq","","Lane-wise equality comparison.",53,[[],["m128x1"]]],[11,"ne","","Lane-wise inequality comparison.",53,[[],["m128x1"]]],[11,"lt","","Lane-wise less-than comparison.",53,[[],["m128x1"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",53,[[],["m128x1"]]],[11,"gt","","Lane-wise greater-than comparison.",53,[[],["m128x1"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",53,[[],["m128x1"]]],[11,"select","","Selects elements of `a` and `b` using mask.",53,[[["simd"]],["simd"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",53,[[["self"]],[["m128x1"],["lexicographicallyordered",["m128x1"]]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",53,[[["self"]],[["m128x1"],["lexicographicallyordered",["m128x1"]]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",53,[[["i"]],["self"]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",53,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",54,[[["i8"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",54,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",54,[[["i8"]],["self"]]],[11,"extract","","Extracts the value at `index`.",54,[[["usize"]],["i8"]]],[11,"extract_unchecked","","Extracts the value at `index`.",54,[[["usize"]],["i8"]]],[11,"replace","","Returns a new vector where the value at `index` is…",54,[[["i8"],["usize"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",54,[[["i8"],["usize"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",54,[[["i8x32"]],["i8x32"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",54,[[["i8x32"]],["i8x32"]]],[11,"min","","Minimum of two vectors.",54,[[],["self"]]],[11,"max","","Maximum of two vectors.",54,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",54,[[],["i8"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",54,[[],["i8"]]],[11,"max_element","","Largest vector element value.",54,[[],["i8"]]],[11,"min_element","","Smallest vector element value.",54,[[],["i8"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",54,[[],["i8"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",54,[[],["i8"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",54,[[],["i8"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",54,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",54,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",54,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",54,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",54,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",54,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",54,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",54,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",54,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",54,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",54,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",54,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",54,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",54,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",54,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",54,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",54,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",54,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",54,[[],["m8x32"]]],[11,"ne","","Lane-wise inequality comparison.",54,[[],["m8x32"]]],[11,"lt","","Lane-wise less-than comparison.",54,[[],["m8x32"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",54,[[],["m8x32"]]],[11,"gt","","Lane-wise greater-than comparison.",54,[[],["m8x32"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",54,[[],["m8x32"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",54,[[["self"]],[["i8x32"],["lexicographicallyordered",["i8x32"]]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",54,[[["self"]],[["i8x32"],["lexicographicallyordered",["i8x32"]]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",54,[[],["u32"]]],[11,"new","","Creates a new instance with each vector elements…",55,[[["u8"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",55,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",55,[[["u8"]],["self"]]],[11,"extract","","Extracts the value at `index`.",55,[[["usize"]],["u8"]]],[11,"extract_unchecked","","Extracts the value at `index`.",55,[[["usize"]],["u8"]]],[11,"replace","","Returns a new vector where the value at `index` is…",55,[[["usize"],["u8"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",55,[[["usize"],["u8"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",55,[[["u8x32"]],["u8x32"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",55,[[["u8x32"]],["u8x32"]]],[11,"min","","Minimum of two vectors.",55,[[],["self"]]],[11,"max","","Maximum of two vectors.",55,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",55,[[],["u8"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",55,[[],["u8"]]],[11,"max_element","","Largest vector element value.",55,[[],["u8"]]],[11,"min_element","","Smallest vector element value.",55,[[],["u8"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",55,[[],["u8"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",55,[[],["u8"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",55,[[],["u8"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",55,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",55,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",55,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",55,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",55,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",55,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",55,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",55,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",55,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",55,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",55,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",55,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",55,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",55,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",55,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",55,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",55,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",55,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",55,[[],["m8x32"]]],[11,"ne","","Lane-wise inequality comparison.",55,[[],["m8x32"]]],[11,"lt","","Lane-wise less-than comparison.",55,[[],["m8x32"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",55,[[],["m8x32"]]],[11,"gt","","Lane-wise greater-than comparison.",55,[[],["m8x32"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",55,[[],["m8x32"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",55,[[["self"]],[["lexicographicallyordered",["u8x32"]],["u8x32"]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",55,[[["self"]],[["lexicographicallyordered",["u8x32"]],["u8x32"]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",55,[[],["u32"]]],[11,"new","","Creates a new instance with each vector elements…",56,[[["bool"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",56,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",56,[[["bool"]],["self"]]],[11,"extract","","Extracts the value at `index`.",56,[[["usize"]],["bool"]]],[11,"extract_unchecked","","Extracts the value at `index`.",56,[[["usize"]],["bool"]]],[11,"replace","","Returns a new vector where the value at `index` is…",56,[[["usize"],["bool"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",56,[[["usize"],["bool"]],["self"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",56,[[],["bool"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",56,[[],["bool"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",56,[[],["bool"]]],[11,"all","","Are `all` vector lanes `true`?",56,[[],["bool"]]],[11,"any","","Is `any` vector lane `true`?",56,[[],["bool"]]],[11,"none","","Are `all` vector lanes `false`?",56,[[],["bool"]]],[11,"eq","","Lane-wise equality comparison.",56,[[],["m8x32"]]],[11,"ne","","Lane-wise inequality comparison.",56,[[],["m8x32"]]],[11,"lt","","Lane-wise less-than comparison.",56,[[],["m8x32"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",56,[[],["m8x32"]]],[11,"gt","","Lane-wise greater-than comparison.",56,[[],["m8x32"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",56,[[],["m8x32"]]],[11,"select","","Selects elements of `a` and `b` using mask.",56,[[["simd"]],["simd"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",56,[[["self"]],[["m8x32"],["lexicographicallyordered",["m8x32"]]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",56,[[["self"]],[["m8x32"],["lexicographicallyordered",["m8x32"]]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",56,[[["i"]],["self"]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",56,[[],["u32"]]],[11,"new","","Creates a new instance with each vector elements…",57,[[["i16"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",57,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",57,[[["i16"]],["self"]]],[11,"extract","","Extracts the value at `index`.",57,[[["usize"]],["i16"]]],[11,"extract_unchecked","","Extracts the value at `index`.",57,[[["usize"]],["i16"]]],[11,"replace","","Returns a new vector where the value at `index` is…",57,[[["usize"],["i16"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",57,[[["usize"],["i16"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",57,[[["i16x16"]],["i16x16"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",57,[[["i16x16"]],["i16x16"]]],[11,"min","","Minimum of two vectors.",57,[[],["self"]]],[11,"max","","Maximum of two vectors.",57,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",57,[[],["i16"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",57,[[],["i16"]]],[11,"max_element","","Largest vector element value.",57,[[],["i16"]]],[11,"min_element","","Smallest vector element value.",57,[[],["i16"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",57,[[],["i16"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",57,[[],["i16"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",57,[[],["i16"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",57,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",57,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",57,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",57,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",57,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",57,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",57,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",57,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",57,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",57,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",57,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",57,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",57,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",57,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",57,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",57,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",57,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",57,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",57,[[],["m16x16"]]],[11,"ne","","Lane-wise inequality comparison.",57,[[],["m16x16"]]],[11,"lt","","Lane-wise less-than comparison.",57,[[],["m16x16"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",57,[[],["m16x16"]]],[11,"gt","","Lane-wise greater-than comparison.",57,[[],["m16x16"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",57,[[],["m16x16"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",57,[[["self"]],[["lexicographicallyordered",["i16x16"]],["i16x16"]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",57,[[["self"]],[["lexicographicallyordered",["i16x16"]],["i16x16"]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",57,[[],["u16"]]],[11,"new","","Creates a new instance with each vector elements…",58,[[["u16"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",58,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",58,[[["u16"]],["self"]]],[11,"extract","","Extracts the value at `index`.",58,[[["usize"]],["u16"]]],[11,"extract_unchecked","","Extracts the value at `index`.",58,[[["usize"]],["u16"]]],[11,"replace","","Returns a new vector where the value at `index` is…",58,[[["u16"],["usize"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",58,[[["u16"],["usize"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",58,[[["u16x16"]],["u16x16"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",58,[[["u16x16"]],["u16x16"]]],[11,"min","","Minimum of two vectors.",58,[[],["self"]]],[11,"max","","Maximum of two vectors.",58,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",58,[[],["u16"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",58,[[],["u16"]]],[11,"max_element","","Largest vector element value.",58,[[],["u16"]]],[11,"min_element","","Smallest vector element value.",58,[[],["u16"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",58,[[],["u16"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",58,[[],["u16"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",58,[[],["u16"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",58,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",58,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",58,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",58,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",58,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",58,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",58,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",58,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",58,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",58,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",58,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",58,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",58,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",58,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",58,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",58,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",58,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",58,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",58,[[],["m16x16"]]],[11,"ne","","Lane-wise inequality comparison.",58,[[],["m16x16"]]],[11,"lt","","Lane-wise less-than comparison.",58,[[],["m16x16"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",58,[[],["m16x16"]]],[11,"gt","","Lane-wise greater-than comparison.",58,[[],["m16x16"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",58,[[],["m16x16"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",58,[[["self"]],[["u16x16"],["lexicographicallyordered",["u16x16"]]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",58,[[["self"]],[["u16x16"],["lexicographicallyordered",["u16x16"]]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",58,[[],["u16"]]],[11,"new","","Creates a new instance with each vector elements…",59,[[["bool"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",59,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",59,[[["bool"]],["self"]]],[11,"extract","","Extracts the value at `index`.",59,[[["usize"]],["bool"]]],[11,"extract_unchecked","","Extracts the value at `index`.",59,[[["usize"]],["bool"]]],[11,"replace","","Returns a new vector where the value at `index` is…",59,[[["usize"],["bool"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",59,[[["usize"],["bool"]],["self"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",59,[[],["bool"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",59,[[],["bool"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",59,[[],["bool"]]],[11,"all","","Are `all` vector lanes `true`?",59,[[],["bool"]]],[11,"any","","Is `any` vector lane `true`?",59,[[],["bool"]]],[11,"none","","Are `all` vector lanes `false`?",59,[[],["bool"]]],[11,"eq","","Lane-wise equality comparison.",59,[[],["m16x16"]]],[11,"ne","","Lane-wise inequality comparison.",59,[[],["m16x16"]]],[11,"lt","","Lane-wise less-than comparison.",59,[[],["m16x16"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",59,[[],["m16x16"]]],[11,"gt","","Lane-wise greater-than comparison.",59,[[],["m16x16"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",59,[[],["m16x16"]]],[11,"select","","Selects elements of `a` and `b` using mask.",59,[[["simd"]],["simd"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",59,[[["self"]],[["lexicographicallyordered",["m16x16"]],["m16x16"]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",59,[[["self"]],[["lexicographicallyordered",["m16x16"]],["m16x16"]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",59,[[["i"]],["self"]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",59,[[],["u16"]]],[11,"new","","Creates a new instance with each vector elements…",60,[[["i32"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",60,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",60,[[["i32"]],["self"]]],[11,"extract","","Extracts the value at `index`.",60,[[["usize"]],["i32"]]],[11,"extract_unchecked","","Extracts the value at `index`.",60,[[["usize"]],["i32"]]],[11,"replace","","Returns a new vector where the value at `index` is…",60,[[["usize"],["i32"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",60,[[["usize"],["i32"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",60,[[["i32x8"]],["i32x8"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",60,[[["i32x8"]],["i32x8"]]],[11,"min","","Minimum of two vectors.",60,[[],["self"]]],[11,"max","","Maximum of two vectors.",60,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",60,[[],["i32"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",60,[[],["i32"]]],[11,"max_element","","Largest vector element value.",60,[[],["i32"]]],[11,"min_element","","Smallest vector element value.",60,[[],["i32"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",60,[[],["i32"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",60,[[],["i32"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",60,[[],["i32"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",60,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",60,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",60,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",60,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",60,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",60,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",60,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",60,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",60,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",60,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",60,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",60,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",60,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",60,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",60,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",60,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",60,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",60,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",60,[[],["m32x8"]]],[11,"ne","","Lane-wise inequality comparison.",60,[[],["m32x8"]]],[11,"lt","","Lane-wise less-than comparison.",60,[[],["m32x8"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",60,[[],["m32x8"]]],[11,"gt","","Lane-wise greater-than comparison.",60,[[],["m32x8"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",60,[[],["m32x8"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",60,[[["self"]],[["i32x8"],["lexicographicallyordered",["i32x8"]]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",60,[[["self"]],[["i32x8"],["lexicographicallyordered",["i32x8"]]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",60,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",61,[[["u32"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",61,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",61,[[["u32"]],["self"]]],[11,"extract","","Extracts the value at `index`.",61,[[["usize"]],["u32"]]],[11,"extract_unchecked","","Extracts the value at `index`.",61,[[["usize"]],["u32"]]],[11,"replace","","Returns a new vector where the value at `index` is…",61,[[["u32"],["usize"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",61,[[["u32"],["usize"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",61,[[["u32x8"]],["u32x8"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",61,[[["u32x8"]],["u32x8"]]],[11,"min","","Minimum of two vectors.",61,[[],["self"]]],[11,"max","","Maximum of two vectors.",61,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",61,[[],["u32"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",61,[[],["u32"]]],[11,"max_element","","Largest vector element value.",61,[[],["u32"]]],[11,"min_element","","Smallest vector element value.",61,[[],["u32"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",61,[[],["u32"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",61,[[],["u32"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",61,[[],["u32"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",61,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",61,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",61,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",61,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",61,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",61,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",61,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",61,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",61,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",61,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",61,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",61,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",61,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",61,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",61,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",61,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",61,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",61,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",61,[[],["m32x8"]]],[11,"ne","","Lane-wise inequality comparison.",61,[[],["m32x8"]]],[11,"lt","","Lane-wise less-than comparison.",61,[[],["m32x8"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",61,[[],["m32x8"]]],[11,"gt","","Lane-wise greater-than comparison.",61,[[],["m32x8"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",61,[[],["m32x8"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",61,[[["self"]],[["lexicographicallyordered",["u32x8"]],["u32x8"]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",61,[[["self"]],[["lexicographicallyordered",["u32x8"]],["u32x8"]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",61,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",62,[[["f32"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",62,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",62,[[["f32"]],["self"]]],[11,"extract","","Extracts the value at `index`.",62,[[["usize"]],["f32"]]],[11,"extract_unchecked","","Extracts the value at `index`.",62,[[["usize"]],["f32"]]],[11,"replace","","Returns a new vector where the value at `index` is…",62,[[["f32"],["usize"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",62,[[["f32"],["usize"]],["self"]]],[11,"min","","Minimum of two vectors.",62,[[],["self"]]],[11,"max","","Maximum of two vectors.",62,[[],["self"]]],[11,"sum","","Horizontal sum of the vector elements.",62,[[],["f32"]]],[11,"product","","Horizontal product of the vector elements.",62,[[],["f32"]]],[11,"max_element","","Largest vector element value.",62,[[],["f32"]]],[11,"min_element","","Smallest vector element value.",62,[[],["f32"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",62,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",62,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",62,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",62,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",62,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",62,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",62,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",62,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",62,[[["i"]],["self"]]],[18,"EPSILON","","Machine epsilon value.",62,null],[18,"MIN","","Smallest finite value.",62,null],[18,"MIN_POSITIVE","","Smallest positive normal value.",62,null],[18,"MAX","","Largest finite value.",62,null],[18,"NAN","","Not a Number (NaN).",62,null],[18,"INFINITY","","Infinity (∞).",62,null],[18,"NEG_INFINITY","","Negative infinity (-∞).",62,null],[18,"PI","","Archimedes' constant (π)",62,null],[18,"FRAC_PI_2","","π/2",62,null],[18,"FRAC_PI_3","","π/3",62,null],[18,"FRAC_PI_4","","π/4",62,null],[18,"FRAC_PI_6","","π/6",62,null],[18,"FRAC_PI_8","","π/8",62,null],[18,"FRAC_1_PI","","1/π",62,null],[18,"FRAC_2_PI","","2/π",62,null],[18,"FRAC_2_SQRT_PI","","2/sqrt(π)",62,null],[18,"SQRT_2","","sqrt(2)",62,null],[18,"FRAC_1_SQRT_2","","1/sqrt(2)",62,null],[18,"E","","Euler's number (e)",62,null],[18,"LOG2_E","","log2(e)",62,null],[18,"LOG10_E","","log10(e)",62,null],[18,"LN_2","","ln(2)",62,null],[18,"LN_10","","ln(10)",62,null],[11,"is_nan","","",62,[[],["m32x8"]]],[11,"is_infinite","","",62,[[],["m32x8"]]],[11,"is_finite","","",62,[[],["m32x8"]]],[11,"abs","","Absolute value.",62,[[],["self"]]],[11,"cos","","Cosine.",62,[[],["self"]]],[11,"cos_pi","","Cosine of `self * PI`.",62,[[],["self"]]],[11,"exp","","Returns the exponential function of `self`: `e^(self)`.",62,[[],["self"]]],[11,"ln","","Returns the natural logarithm of `self`.",62,[[],["self"]]],[11,"mul_add","","Fused multiply add: `self * y + z`",62,[[],["self"]]],[11,"mul_adde","","Fused multiply add estimate: ~= `self * y + z`",62,[[],["self"]]],[11,"powf","","Raises `self` number to the floating point power of `x`.",62,[[],["self"]]],[11,"recpre","","Reciprocal estimate: `~= 1. / self`.",62,[[],["self"]]],[11,"rsqrte","","Reciprocal square-root estimate: `~= 1. / self.sqrt()`.",62,[[],["self"]]],[11,"sin","","Sine.",62,[[],["self"]]],[11,"sin_pi","","Sine of `self * PI`.",62,[[],["self"]]],[11,"sin_cos_pi","","Sine and cosine of `self * PI`.",62,[[]]],[11,"sqrt","","",62,[[],["self"]]],[11,"sqrte","","Square-root estimate.",62,[[],["self"]]],[11,"tanh","","Tanh.",62,[[],["self"]]],[11,"eq","","Lane-wise equality comparison.",62,[[],["m32x8"]]],[11,"ne","","Lane-wise inequality comparison.",62,[[],["m32x8"]]],[11,"lt","","Lane-wise less-than comparison.",62,[[],["m32x8"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",62,[[],["m32x8"]]],[11,"gt","","Lane-wise greater-than comparison.",62,[[],["m32x8"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",62,[[],["m32x8"]]],[11,"new","","Creates a new instance with each vector elements…",63,[[["bool"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",63,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",63,[[["bool"]],["self"]]],[11,"extract","","Extracts the value at `index`.",63,[[["usize"]],["bool"]]],[11,"extract_unchecked","","Extracts the value at `index`.",63,[[["usize"]],["bool"]]],[11,"replace","","Returns a new vector where the value at `index` is…",63,[[["usize"],["bool"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",63,[[["usize"],["bool"]],["self"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",63,[[],["bool"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",63,[[],["bool"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",63,[[],["bool"]]],[11,"all","","Are `all` vector lanes `true`?",63,[[],["bool"]]],[11,"any","","Is `any` vector lane `true`?",63,[[],["bool"]]],[11,"none","","Are `all` vector lanes `false`?",63,[[],["bool"]]],[11,"eq","","Lane-wise equality comparison.",63,[[],["m32x8"]]],[11,"ne","","Lane-wise inequality comparison.",63,[[],["m32x8"]]],[11,"lt","","Lane-wise less-than comparison.",63,[[],["m32x8"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",63,[[],["m32x8"]]],[11,"gt","","Lane-wise greater-than comparison.",63,[[],["m32x8"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",63,[[],["m32x8"]]],[11,"select","","Selects elements of `a` and `b` using mask.",63,[[["simd"]],["simd"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",63,[[["self"]],[["m32x8"],["lexicographicallyordered",["m32x8"]]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",63,[[["self"]],[["m32x8"],["lexicographicallyordered",["m32x8"]]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",63,[[["i"]],["self"]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",63,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",64,[[["i64"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",64,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",64,[[["i64"]],["self"]]],[11,"extract","","Extracts the value at `index`.",64,[[["usize"]],["i64"]]],[11,"extract_unchecked","","Extracts the value at `index`.",64,[[["usize"]],["i64"]]],[11,"replace","","Returns a new vector where the value at `index` is…",64,[[["i64"],["usize"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",64,[[["i64"],["usize"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",64,[[["i64x4"]],["i64x4"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",64,[[["i64x4"]],["i64x4"]]],[11,"min","","Minimum of two vectors.",64,[[],["self"]]],[11,"max","","Maximum of two vectors.",64,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",64,[[],["i64"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",64,[[],["i64"]]],[11,"max_element","","Largest vector element value.",64,[[],["i64"]]],[11,"min_element","","Smallest vector element value.",64,[[],["i64"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",64,[[],["i64"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",64,[[],["i64"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",64,[[],["i64"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",64,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",64,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",64,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",64,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",64,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",64,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",64,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",64,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",64,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",64,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",64,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",64,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",64,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",64,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",64,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",64,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",64,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",64,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",64,[[],["m64x4"]]],[11,"ne","","Lane-wise inequality comparison.",64,[[],["m64x4"]]],[11,"lt","","Lane-wise less-than comparison.",64,[[],["m64x4"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",64,[[],["m64x4"]]],[11,"gt","","Lane-wise greater-than comparison.",64,[[],["m64x4"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",64,[[],["m64x4"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",64,[[["self"]],[["i64x4"],["lexicographicallyordered",["i64x4"]]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",64,[[["self"]],[["i64x4"],["lexicographicallyordered",["i64x4"]]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",64,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",65,[[["u64"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",65,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",65,[[["u64"]],["self"]]],[11,"extract","","Extracts the value at `index`.",65,[[["usize"]],["u64"]]],[11,"extract_unchecked","","Extracts the value at `index`.",65,[[["usize"]],["u64"]]],[11,"replace","","Returns a new vector where the value at `index` is…",65,[[["usize"],["u64"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",65,[[["usize"],["u64"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",65,[[["u64x4"]],["u64x4"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",65,[[["u64x4"]],["u64x4"]]],[11,"min","","Minimum of two vectors.",65,[[],["self"]]],[11,"max","","Maximum of two vectors.",65,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",65,[[],["u64"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",65,[[],["u64"]]],[11,"max_element","","Largest vector element value.",65,[[],["u64"]]],[11,"min_element","","Smallest vector element value.",65,[[],["u64"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",65,[[],["u64"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",65,[[],["u64"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",65,[[],["u64"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",65,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",65,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",65,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",65,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",65,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",65,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",65,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",65,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",65,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",65,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",65,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",65,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",65,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",65,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",65,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",65,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",65,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",65,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",65,[[],["m64x4"]]],[11,"ne","","Lane-wise inequality comparison.",65,[[],["m64x4"]]],[11,"lt","","Lane-wise less-than comparison.",65,[[],["m64x4"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",65,[[],["m64x4"]]],[11,"gt","","Lane-wise greater-than comparison.",65,[[],["m64x4"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",65,[[],["m64x4"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",65,[[["self"]],[["u64x4"],["lexicographicallyordered",["u64x4"]]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",65,[[["self"]],[["u64x4"],["lexicographicallyordered",["u64x4"]]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",65,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",66,[[["f64"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",66,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",66,[[["f64"]],["self"]]],[11,"extract","","Extracts the value at `index`.",66,[[["usize"]],["f64"]]],[11,"extract_unchecked","","Extracts the value at `index`.",66,[[["usize"]],["f64"]]],[11,"replace","","Returns a new vector where the value at `index` is…",66,[[["f64"],["usize"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",66,[[["f64"],["usize"]],["self"]]],[11,"min","","Minimum of two vectors.",66,[[],["self"]]],[11,"max","","Maximum of two vectors.",66,[[],["self"]]],[11,"sum","","Horizontal sum of the vector elements.",66,[[],["f64"]]],[11,"product","","Horizontal product of the vector elements.",66,[[],["f64"]]],[11,"max_element","","Largest vector element value.",66,[[],["f64"]]],[11,"min_element","","Smallest vector element value.",66,[[],["f64"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",66,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",66,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",66,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",66,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",66,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",66,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",66,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",66,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",66,[[["i"]],["self"]]],[18,"EPSILON","","Machine epsilon value.",66,null],[18,"MIN","","Smallest finite value.",66,null],[18,"MIN_POSITIVE","","Smallest positive normal value.",66,null],[18,"MAX","","Largest finite value.",66,null],[18,"NAN","","Not a Number (NaN).",66,null],[18,"INFINITY","","Infinity (∞).",66,null],[18,"NEG_INFINITY","","Negative infinity (-∞).",66,null],[18,"PI","","Archimedes' constant (π)",66,null],[18,"FRAC_PI_2","","π/2",66,null],[18,"FRAC_PI_3","","π/3",66,null],[18,"FRAC_PI_4","","π/4",66,null],[18,"FRAC_PI_6","","π/6",66,null],[18,"FRAC_PI_8","","π/8",66,null],[18,"FRAC_1_PI","","1/π",66,null],[18,"FRAC_2_PI","","2/π",66,null],[18,"FRAC_2_SQRT_PI","","2/sqrt(π)",66,null],[18,"SQRT_2","","sqrt(2)",66,null],[18,"FRAC_1_SQRT_2","","1/sqrt(2)",66,null],[18,"E","","Euler's number (e)",66,null],[18,"LOG2_E","","log2(e)",66,null],[18,"LOG10_E","","log10(e)",66,null],[18,"LN_2","","ln(2)",66,null],[18,"LN_10","","ln(10)",66,null],[11,"is_nan","","",66,[[],["m64x4"]]],[11,"is_infinite","","",66,[[],["m64x4"]]],[11,"is_finite","","",66,[[],["m64x4"]]],[11,"abs","","Absolute value.",66,[[],["self"]]],[11,"cos","","Cosine.",66,[[],["self"]]],[11,"cos_pi","","Cosine of `self * PI`.",66,[[],["self"]]],[11,"exp","","Returns the exponential function of `self`: `e^(self)`.",66,[[],["self"]]],[11,"ln","","Returns the natural logarithm of `self`.",66,[[],["self"]]],[11,"mul_add","","Fused multiply add: `self * y + z`",66,[[],["self"]]],[11,"mul_adde","","Fused multiply add estimate: ~= `self * y + z`",66,[[],["self"]]],[11,"powf","","Raises `self` number to the floating point power of `x`.",66,[[],["self"]]],[11,"recpre","","Reciprocal estimate: `~= 1. / self`.",66,[[],["self"]]],[11,"rsqrte","","Reciprocal square-root estimate: `~= 1. / self.sqrt()`.",66,[[],["self"]]],[11,"sin","","Sine.",66,[[],["self"]]],[11,"sin_pi","","Sine of `self * PI`.",66,[[],["self"]]],[11,"sin_cos_pi","","Sine and cosine of `self * PI`.",66,[[]]],[11,"sqrt","","",66,[[],["self"]]],[11,"sqrte","","Square-root estimate.",66,[[],["self"]]],[11,"tanh","","Tanh.",66,[[],["self"]]],[11,"eq","","Lane-wise equality comparison.",66,[[],["m64x4"]]],[11,"ne","","Lane-wise inequality comparison.",66,[[],["m64x4"]]],[11,"lt","","Lane-wise less-than comparison.",66,[[],["m64x4"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",66,[[],["m64x4"]]],[11,"gt","","Lane-wise greater-than comparison.",66,[[],["m64x4"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",66,[[],["m64x4"]]],[11,"new","","Creates a new instance with each vector elements…",67,[[["bool"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",67,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",67,[[["bool"]],["self"]]],[11,"extract","","Extracts the value at `index`.",67,[[["usize"]],["bool"]]],[11,"extract_unchecked","","Extracts the value at `index`.",67,[[["usize"]],["bool"]]],[11,"replace","","Returns a new vector where the value at `index` is…",67,[[["usize"],["bool"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",67,[[["usize"],["bool"]],["self"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",67,[[],["bool"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",67,[[],["bool"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",67,[[],["bool"]]],[11,"all","","Are `all` vector lanes `true`?",67,[[],["bool"]]],[11,"any","","Is `any` vector lane `true`?",67,[[],["bool"]]],[11,"none","","Are `all` vector lanes `false`?",67,[[],["bool"]]],[11,"eq","","Lane-wise equality comparison.",67,[[],["m64x4"]]],[11,"ne","","Lane-wise inequality comparison.",67,[[],["m64x4"]]],[11,"lt","","Lane-wise less-than comparison.",67,[[],["m64x4"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",67,[[],["m64x4"]]],[11,"gt","","Lane-wise greater-than comparison.",67,[[],["m64x4"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",67,[[],["m64x4"]]],[11,"select","","Selects elements of `a` and `b` using mask.",67,[[["simd"]],["simd"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",67,[[["self"]],[["lexicographicallyordered",["m64x4"]],["m64x4"]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",67,[[["self"]],[["lexicographicallyordered",["m64x4"]],["m64x4"]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",67,[[["i"]],["self"]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",67,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",68,[[["i128"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",68,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",68,[[["i128"]],["self"]]],[11,"extract","","Extracts the value at `index`.",68,[[["usize"]],["i128"]]],[11,"extract_unchecked","","Extracts the value at `index`.",68,[[["usize"]],["i128"]]],[11,"replace","","Returns a new vector where the value at `index` is…",68,[[["i128"],["usize"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",68,[[["i128"],["usize"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",68,[[["i128x2"]],["i128x2"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",68,[[["i128x2"]],["i128x2"]]],[11,"min","","Minimum of two vectors.",68,[[],["self"]]],[11,"max","","Maximum of two vectors.",68,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",68,[[],["i128"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",68,[[],["i128"]]],[11,"max_element","","Largest vector element value.",68,[[],["i128"]]],[11,"min_element","","Smallest vector element value.",68,[[],["i128"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",68,[[],["i128"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",68,[[],["i128"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",68,[[],["i128"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",68,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",68,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",68,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",68,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",68,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",68,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",68,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",68,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",68,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",68,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",68,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",68,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",68,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",68,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",68,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",68,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",68,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",68,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",68,[[],["m128x2"]]],[11,"ne","","Lane-wise inequality comparison.",68,[[],["m128x2"]]],[11,"lt","","Lane-wise less-than comparison.",68,[[],["m128x2"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",68,[[],["m128x2"]]],[11,"gt","","Lane-wise greater-than comparison.",68,[[],["m128x2"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",68,[[],["m128x2"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",68,[[["self"]],[["lexicographicallyordered",["i128x2"]],["i128x2"]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",68,[[["self"]],[["lexicographicallyordered",["i128x2"]],["i128x2"]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",68,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",69,[[["u128"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",69,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",69,[[["u128"]],["self"]]],[11,"extract","","Extracts the value at `index`.",69,[[["usize"]],["u128"]]],[11,"extract_unchecked","","Extracts the value at `index`.",69,[[["usize"]],["u128"]]],[11,"replace","","Returns a new vector where the value at `index` is…",69,[[["usize"],["u128"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",69,[[["usize"],["u128"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",69,[[["u128x2"]],["u128x2"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",69,[[["u128x2"]],["u128x2"]]],[11,"min","","Minimum of two vectors.",69,[[],["self"]]],[11,"max","","Maximum of two vectors.",69,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",69,[[],["u128"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",69,[[],["u128"]]],[11,"max_element","","Largest vector element value.",69,[[],["u128"]]],[11,"min_element","","Smallest vector element value.",69,[[],["u128"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",69,[[],["u128"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",69,[[],["u128"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",69,[[],["u128"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",69,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",69,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",69,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",69,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",69,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",69,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",69,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",69,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",69,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",69,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",69,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",69,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",69,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",69,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",69,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",69,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",69,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",69,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",69,[[],["m128x2"]]],[11,"ne","","Lane-wise inequality comparison.",69,[[],["m128x2"]]],[11,"lt","","Lane-wise less-than comparison.",69,[[],["m128x2"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",69,[[],["m128x2"]]],[11,"gt","","Lane-wise greater-than comparison.",69,[[],["m128x2"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",69,[[],["m128x2"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",69,[[["self"]],[["u128x2"],["lexicographicallyordered",["u128x2"]]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",69,[[["self"]],[["u128x2"],["lexicographicallyordered",["u128x2"]]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",69,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",70,[[["bool"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",70,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",70,[[["bool"]],["self"]]],[11,"extract","","Extracts the value at `index`.",70,[[["usize"]],["bool"]]],[11,"extract_unchecked","","Extracts the value at `index`.",70,[[["usize"]],["bool"]]],[11,"replace","","Returns a new vector where the value at `index` is…",70,[[["usize"],["bool"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",70,[[["usize"],["bool"]],["self"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",70,[[],["bool"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",70,[[],["bool"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",70,[[],["bool"]]],[11,"all","","Are `all` vector lanes `true`?",70,[[],["bool"]]],[11,"any","","Is `any` vector lane `true`?",70,[[],["bool"]]],[11,"none","","Are `all` vector lanes `false`?",70,[[],["bool"]]],[11,"eq","","Lane-wise equality comparison.",70,[[],["m128x2"]]],[11,"ne","","Lane-wise inequality comparison.",70,[[],["m128x2"]]],[11,"lt","","Lane-wise less-than comparison.",70,[[],["m128x2"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",70,[[],["m128x2"]]],[11,"gt","","Lane-wise greater-than comparison.",70,[[],["m128x2"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",70,[[],["m128x2"]]],[11,"select","","Selects elements of `a` and `b` using mask.",70,[[["simd"]],["simd"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",70,[[["self"]],[["lexicographicallyordered",["m128x2"]],["m128x2"]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",70,[[["self"]],[["lexicographicallyordered",["m128x2"]],["m128x2"]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",70,[[["i"]],["self"]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",70,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",74,[[["i8"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",74,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",74,[[["i8"]],["self"]]],[11,"extract","","Extracts the value at `index`.",74,[[["usize"]],["i8"]]],[11,"extract_unchecked","","Extracts the value at `index`.",74,[[["usize"]],["i8"]]],[11,"replace","","Returns a new vector where the value at `index` is…",74,[[["i8"],["usize"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",74,[[["i8"],["usize"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",74,[[["i8x64"]],["i8x64"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",74,[[["i8x64"]],["i8x64"]]],[11,"min","","Minimum of two vectors.",74,[[],["self"]]],[11,"max","","Maximum of two vectors.",74,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",74,[[],["i8"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",74,[[],["i8"]]],[11,"max_element","","Largest vector element value.",74,[[],["i8"]]],[11,"min_element","","Smallest vector element value.",74,[[],["i8"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",74,[[],["i8"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",74,[[],["i8"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",74,[[],["i8"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",74,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",74,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",74,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",74,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",74,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",74,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",74,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",74,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",74,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",74,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",74,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",74,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",74,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",74,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",74,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",74,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",74,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",74,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",74,[[],["m8x64"]]],[11,"ne","","Lane-wise inequality comparison.",74,[[],["m8x64"]]],[11,"lt","","Lane-wise less-than comparison.",74,[[],["m8x64"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",74,[[],["m8x64"]]],[11,"gt","","Lane-wise greater-than comparison.",74,[[],["m8x64"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",74,[[],["m8x64"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",74,[[["self"]],[["lexicographicallyordered",["i8x64"]],["i8x64"]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",74,[[["self"]],[["lexicographicallyordered",["i8x64"]],["i8x64"]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",74,[[],["u64"]]],[11,"new","","Creates a new instance with each vector elements…",75,[[["u8"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",75,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",75,[[["u8"]],["self"]]],[11,"extract","","Extracts the value at `index`.",75,[[["usize"]],["u8"]]],[11,"extract_unchecked","","Extracts the value at `index`.",75,[[["usize"]],["u8"]]],[11,"replace","","Returns a new vector where the value at `index` is…",75,[[["usize"],["u8"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",75,[[["usize"],["u8"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",75,[[["u8x64"]],["u8x64"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",75,[[["u8x64"]],["u8x64"]]],[11,"min","","Minimum of two vectors.",75,[[],["self"]]],[11,"max","","Maximum of two vectors.",75,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",75,[[],["u8"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",75,[[],["u8"]]],[11,"max_element","","Largest vector element value.",75,[[],["u8"]]],[11,"min_element","","Smallest vector element value.",75,[[],["u8"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",75,[[],["u8"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",75,[[],["u8"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",75,[[],["u8"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",75,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",75,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",75,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",75,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",75,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",75,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",75,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",75,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",75,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",75,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",75,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",75,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",75,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",75,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",75,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",75,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",75,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",75,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",75,[[],["m8x64"]]],[11,"ne","","Lane-wise inequality comparison.",75,[[],["m8x64"]]],[11,"lt","","Lane-wise less-than comparison.",75,[[],["m8x64"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",75,[[],["m8x64"]]],[11,"gt","","Lane-wise greater-than comparison.",75,[[],["m8x64"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",75,[[],["m8x64"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",75,[[["self"]],[["lexicographicallyordered",["u8x64"]],["u8x64"]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",75,[[["self"]],[["lexicographicallyordered",["u8x64"]],["u8x64"]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",75,[[],["u64"]]],[11,"new","","Creates a new instance with each vector elements…",76,[[["bool"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",76,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",76,[[["bool"]],["self"]]],[11,"extract","","Extracts the value at `index`.",76,[[["usize"]],["bool"]]],[11,"extract_unchecked","","Extracts the value at `index`.",76,[[["usize"]],["bool"]]],[11,"replace","","Returns a new vector where the value at `index` is…",76,[[["usize"],["bool"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",76,[[["usize"],["bool"]],["self"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",76,[[],["bool"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",76,[[],["bool"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",76,[[],["bool"]]],[11,"all","","Are `all` vector lanes `true`?",76,[[],["bool"]]],[11,"any","","Is `any` vector lane `true`?",76,[[],["bool"]]],[11,"none","","Are `all` vector lanes `false`?",76,[[],["bool"]]],[11,"eq","","Lane-wise equality comparison.",76,[[],["m8x64"]]],[11,"ne","","Lane-wise inequality comparison.",76,[[],["m8x64"]]],[11,"lt","","Lane-wise less-than comparison.",76,[[],["m8x64"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",76,[[],["m8x64"]]],[11,"gt","","Lane-wise greater-than comparison.",76,[[],["m8x64"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",76,[[],["m8x64"]]],[11,"select","","Selects elements of `a` and `b` using mask.",76,[[["simd"]],["simd"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",76,[[["self"]],[["lexicographicallyordered",["m8x64"]],["m8x64"]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",76,[[["self"]],[["lexicographicallyordered",["m8x64"]],["m8x64"]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",76,[[["i"]],["self"]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",76,[[],["u64"]]],[11,"new","","Creates a new instance with each vector elements…",77,[[["i16"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",77,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",77,[[["i16"]],["self"]]],[11,"extract","","Extracts the value at `index`.",77,[[["usize"]],["i16"]]],[11,"extract_unchecked","","Extracts the value at `index`.",77,[[["usize"]],["i16"]]],[11,"replace","","Returns a new vector where the value at `index` is…",77,[[["usize"],["i16"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",77,[[["usize"],["i16"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",77,[[["i16x32"]],["i16x32"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",77,[[["i16x32"]],["i16x32"]]],[11,"min","","Minimum of two vectors.",77,[[],["self"]]],[11,"max","","Maximum of two vectors.",77,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",77,[[],["i16"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",77,[[],["i16"]]],[11,"max_element","","Largest vector element value.",77,[[],["i16"]]],[11,"min_element","","Smallest vector element value.",77,[[],["i16"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",77,[[],["i16"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",77,[[],["i16"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",77,[[],["i16"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",77,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",77,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",77,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",77,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",77,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",77,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",77,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",77,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",77,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",77,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",77,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",77,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",77,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",77,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",77,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",77,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",77,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",77,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",77,[[],["m16x32"]]],[11,"ne","","Lane-wise inequality comparison.",77,[[],["m16x32"]]],[11,"lt","","Lane-wise less-than comparison.",77,[[],["m16x32"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",77,[[],["m16x32"]]],[11,"gt","","Lane-wise greater-than comparison.",77,[[],["m16x32"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",77,[[],["m16x32"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",77,[[["self"]],[["lexicographicallyordered",["i16x32"]],["i16x32"]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",77,[[["self"]],[["lexicographicallyordered",["i16x32"]],["i16x32"]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",77,[[],["u32"]]],[11,"new","","Creates a new instance with each vector elements…",78,[[["u16"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",78,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",78,[[["u16"]],["self"]]],[11,"extract","","Extracts the value at `index`.",78,[[["usize"]],["u16"]]],[11,"extract_unchecked","","Extracts the value at `index`.",78,[[["usize"]],["u16"]]],[11,"replace","","Returns a new vector where the value at `index` is…",78,[[["u16"],["usize"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",78,[[["u16"],["usize"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",78,[[["u16x32"]],["u16x32"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",78,[[["u16x32"]],["u16x32"]]],[11,"min","","Minimum of two vectors.",78,[[],["self"]]],[11,"max","","Maximum of two vectors.",78,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",78,[[],["u16"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",78,[[],["u16"]]],[11,"max_element","","Largest vector element value.",78,[[],["u16"]]],[11,"min_element","","Smallest vector element value.",78,[[],["u16"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",78,[[],["u16"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",78,[[],["u16"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",78,[[],["u16"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",78,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",78,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",78,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",78,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",78,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",78,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",78,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",78,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",78,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",78,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",78,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",78,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",78,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",78,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",78,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",78,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",78,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",78,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",78,[[],["m16x32"]]],[11,"ne","","Lane-wise inequality comparison.",78,[[],["m16x32"]]],[11,"lt","","Lane-wise less-than comparison.",78,[[],["m16x32"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",78,[[],["m16x32"]]],[11,"gt","","Lane-wise greater-than comparison.",78,[[],["m16x32"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",78,[[],["m16x32"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",78,[[["self"]],[["lexicographicallyordered",["u16x32"]],["u16x32"]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",78,[[["self"]],[["lexicographicallyordered",["u16x32"]],["u16x32"]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",78,[[],["u32"]]],[11,"new","","Creates a new instance with each vector elements…",79,[[["bool"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",79,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",79,[[["bool"]],["self"]]],[11,"extract","","Extracts the value at `index`.",79,[[["usize"]],["bool"]]],[11,"extract_unchecked","","Extracts the value at `index`.",79,[[["usize"]],["bool"]]],[11,"replace","","Returns a new vector where the value at `index` is…",79,[[["usize"],["bool"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",79,[[["usize"],["bool"]],["self"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",79,[[],["bool"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",79,[[],["bool"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",79,[[],["bool"]]],[11,"all","","Are `all` vector lanes `true`?",79,[[],["bool"]]],[11,"any","","Is `any` vector lane `true`?",79,[[],["bool"]]],[11,"none","","Are `all` vector lanes `false`?",79,[[],["bool"]]],[11,"eq","","Lane-wise equality comparison.",79,[[],["m16x32"]]],[11,"ne","","Lane-wise inequality comparison.",79,[[],["m16x32"]]],[11,"lt","","Lane-wise less-than comparison.",79,[[],["m16x32"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",79,[[],["m16x32"]]],[11,"gt","","Lane-wise greater-than comparison.",79,[[],["m16x32"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",79,[[],["m16x32"]]],[11,"select","","Selects elements of `a` and `b` using mask.",79,[[["simd"]],["simd"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",79,[[["self"]],[["lexicographicallyordered",["m16x32"]],["m16x32"]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",79,[[["self"]],[["lexicographicallyordered",["m16x32"]],["m16x32"]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",79,[[["i"]],["self"]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",79,[[],["u32"]]],[11,"new","","Creates a new instance with each vector elements…",80,[[["i32"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",80,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",80,[[["i32"]],["self"]]],[11,"extract","","Extracts the value at `index`.",80,[[["usize"]],["i32"]]],[11,"extract_unchecked","","Extracts the value at `index`.",80,[[["usize"]],["i32"]]],[11,"replace","","Returns a new vector where the value at `index` is…",80,[[["usize"],["i32"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",80,[[["usize"],["i32"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",80,[[["i32x16"]],["i32x16"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",80,[[["i32x16"]],["i32x16"]]],[11,"min","","Minimum of two vectors.",80,[[],["self"]]],[11,"max","","Maximum of two vectors.",80,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",80,[[],["i32"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",80,[[],["i32"]]],[11,"max_element","","Largest vector element value.",80,[[],["i32"]]],[11,"min_element","","Smallest vector element value.",80,[[],["i32"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",80,[[],["i32"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",80,[[],["i32"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",80,[[],["i32"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",80,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",80,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",80,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",80,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",80,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",80,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",80,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",80,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",80,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",80,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",80,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",80,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",80,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",80,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",80,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",80,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",80,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",80,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",80,[[],["m32x16"]]],[11,"ne","","Lane-wise inequality comparison.",80,[[],["m32x16"]]],[11,"lt","","Lane-wise less-than comparison.",80,[[],["m32x16"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",80,[[],["m32x16"]]],[11,"gt","","Lane-wise greater-than comparison.",80,[[],["m32x16"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",80,[[],["m32x16"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",80,[[["self"]],[["i32x16"],["lexicographicallyordered",["i32x16"]]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",80,[[["self"]],[["i32x16"],["lexicographicallyordered",["i32x16"]]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",80,[[],["u16"]]],[11,"new","","Creates a new instance with each vector elements…",81,[[["u32"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",81,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",81,[[["u32"]],["self"]]],[11,"extract","","Extracts the value at `index`.",81,[[["usize"]],["u32"]]],[11,"extract_unchecked","","Extracts the value at `index`.",81,[[["usize"]],["u32"]]],[11,"replace","","Returns a new vector where the value at `index` is…",81,[[["u32"],["usize"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",81,[[["u32"],["usize"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",81,[[["u32x16"]],["u32x16"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",81,[[["u32x16"]],["u32x16"]]],[11,"min","","Minimum of two vectors.",81,[[],["self"]]],[11,"max","","Maximum of two vectors.",81,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",81,[[],["u32"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",81,[[],["u32"]]],[11,"max_element","","Largest vector element value.",81,[[],["u32"]]],[11,"min_element","","Smallest vector element value.",81,[[],["u32"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",81,[[],["u32"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",81,[[],["u32"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",81,[[],["u32"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",81,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",81,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",81,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",81,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",81,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",81,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",81,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",81,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",81,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",81,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",81,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",81,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",81,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",81,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",81,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",81,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",81,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",81,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",81,[[],["m32x16"]]],[11,"ne","","Lane-wise inequality comparison.",81,[[],["m32x16"]]],[11,"lt","","Lane-wise less-than comparison.",81,[[],["m32x16"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",81,[[],["m32x16"]]],[11,"gt","","Lane-wise greater-than comparison.",81,[[],["m32x16"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",81,[[],["m32x16"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",81,[[["self"]],[["lexicographicallyordered",["u32x16"]],["u32x16"]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",81,[[["self"]],[["lexicographicallyordered",["u32x16"]],["u32x16"]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",81,[[],["u16"]]],[11,"new","","Creates a new instance with each vector elements…",82,[[["f32"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",82,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",82,[[["f32"]],["self"]]],[11,"extract","","Extracts the value at `index`.",82,[[["usize"]],["f32"]]],[11,"extract_unchecked","","Extracts the value at `index`.",82,[[["usize"]],["f32"]]],[11,"replace","","Returns a new vector where the value at `index` is…",82,[[["f32"],["usize"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",82,[[["f32"],["usize"]],["self"]]],[11,"min","","Minimum of two vectors.",82,[[],["self"]]],[11,"max","","Maximum of two vectors.",82,[[],["self"]]],[11,"sum","","Horizontal sum of the vector elements.",82,[[],["f32"]]],[11,"product","","Horizontal product of the vector elements.",82,[[],["f32"]]],[11,"max_element","","Largest vector element value.",82,[[],["f32"]]],[11,"min_element","","Smallest vector element value.",82,[[],["f32"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",82,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",82,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",82,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",82,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",82,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",82,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",82,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",82,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",82,[[["i"]],["self"]]],[18,"EPSILON","","Machine epsilon value.",82,null],[18,"MIN","","Smallest finite value.",82,null],[18,"MIN_POSITIVE","","Smallest positive normal value.",82,null],[18,"MAX","","Largest finite value.",82,null],[18,"NAN","","Not a Number (NaN).",82,null],[18,"INFINITY","","Infinity (∞).",82,null],[18,"NEG_INFINITY","","Negative infinity (-∞).",82,null],[18,"PI","","Archimedes' constant (π)",82,null],[18,"FRAC_PI_2","","π/2",82,null],[18,"FRAC_PI_3","","π/3",82,null],[18,"FRAC_PI_4","","π/4",82,null],[18,"FRAC_PI_6","","π/6",82,null],[18,"FRAC_PI_8","","π/8",82,null],[18,"FRAC_1_PI","","1/π",82,null],[18,"FRAC_2_PI","","2/π",82,null],[18,"FRAC_2_SQRT_PI","","2/sqrt(π)",82,null],[18,"SQRT_2","","sqrt(2)",82,null],[18,"FRAC_1_SQRT_2","","1/sqrt(2)",82,null],[18,"E","","Euler's number (e)",82,null],[18,"LOG2_E","","log2(e)",82,null],[18,"LOG10_E","","log10(e)",82,null],[18,"LN_2","","ln(2)",82,null],[18,"LN_10","","ln(10)",82,null],[11,"is_nan","","",82,[[],["m32x16"]]],[11,"is_infinite","","",82,[[],["m32x16"]]],[11,"is_finite","","",82,[[],["m32x16"]]],[11,"abs","","Absolute value.",82,[[],["self"]]],[11,"cos","","Cosine.",82,[[],["self"]]],[11,"cos_pi","","Cosine of `self * PI`.",82,[[],["self"]]],[11,"exp","","Returns the exponential function of `self`: `e^(self)`.",82,[[],["self"]]],[11,"ln","","Returns the natural logarithm of `self`.",82,[[],["self"]]],[11,"mul_add","","Fused multiply add: `self * y + z`",82,[[],["self"]]],[11,"mul_adde","","Fused multiply add estimate: ~= `self * y + z`",82,[[],["self"]]],[11,"powf","","Raises `self` number to the floating point power of `x`.",82,[[],["self"]]],[11,"recpre","","Reciprocal estimate: `~= 1. / self`.",82,[[],["self"]]],[11,"rsqrte","","Reciprocal square-root estimate: `~= 1. / self.sqrt()`.",82,[[],["self"]]],[11,"sin","","Sine.",82,[[],["self"]]],[11,"sin_pi","","Sine of `self * PI`.",82,[[],["self"]]],[11,"sin_cos_pi","","Sine and cosine of `self * PI`.",82,[[]]],[11,"sqrt","","",82,[[],["self"]]],[11,"sqrte","","Square-root estimate.",82,[[],["self"]]],[11,"tanh","","Tanh.",82,[[],["self"]]],[11,"eq","","Lane-wise equality comparison.",82,[[],["m32x16"]]],[11,"ne","","Lane-wise inequality comparison.",82,[[],["m32x16"]]],[11,"lt","","Lane-wise less-than comparison.",82,[[],["m32x16"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",82,[[],["m32x16"]]],[11,"gt","","Lane-wise greater-than comparison.",82,[[],["m32x16"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",82,[[],["m32x16"]]],[11,"new","","Creates a new instance with each vector elements…",83,[[["bool"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",83,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",83,[[["bool"]],["self"]]],[11,"extract","","Extracts the value at `index`.",83,[[["usize"]],["bool"]]],[11,"extract_unchecked","","Extracts the value at `index`.",83,[[["usize"]],["bool"]]],[11,"replace","","Returns a new vector where the value at `index` is…",83,[[["usize"],["bool"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",83,[[["usize"],["bool"]],["self"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",83,[[],["bool"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",83,[[],["bool"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",83,[[],["bool"]]],[11,"all","","Are `all` vector lanes `true`?",83,[[],["bool"]]],[11,"any","","Is `any` vector lane `true`?",83,[[],["bool"]]],[11,"none","","Are `all` vector lanes `false`?",83,[[],["bool"]]],[11,"eq","","Lane-wise equality comparison.",83,[[],["m32x16"]]],[11,"ne","","Lane-wise inequality comparison.",83,[[],["m32x16"]]],[11,"lt","","Lane-wise less-than comparison.",83,[[],["m32x16"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",83,[[],["m32x16"]]],[11,"gt","","Lane-wise greater-than comparison.",83,[[],["m32x16"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",83,[[],["m32x16"]]],[11,"select","","Selects elements of `a` and `b` using mask.",83,[[["simd"]],["simd"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",83,[[["self"]],[["lexicographicallyordered",["m32x16"]],["m32x16"]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",83,[[["self"]],[["lexicographicallyordered",["m32x16"]],["m32x16"]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",83,[[["i"]],["self"]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",83,[[],["u16"]]],[11,"new","","Creates a new instance with each vector elements…",84,[[["i64"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",84,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",84,[[["i64"]],["self"]]],[11,"extract","","Extracts the value at `index`.",84,[[["usize"]],["i64"]]],[11,"extract_unchecked","","Extracts the value at `index`.",84,[[["usize"]],["i64"]]],[11,"replace","","Returns a new vector where the value at `index` is…",84,[[["i64"],["usize"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",84,[[["i64"],["usize"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",84,[[["i64x8"]],["i64x8"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",84,[[["i64x8"]],["i64x8"]]],[11,"min","","Minimum of two vectors.",84,[[],["self"]]],[11,"max","","Maximum of two vectors.",84,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",84,[[],["i64"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",84,[[],["i64"]]],[11,"max_element","","Largest vector element value.",84,[[],["i64"]]],[11,"min_element","","Smallest vector element value.",84,[[],["i64"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",84,[[],["i64"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",84,[[],["i64"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",84,[[],["i64"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",84,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",84,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",84,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",84,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",84,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",84,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",84,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",84,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",84,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",84,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",84,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",84,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",84,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",84,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",84,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",84,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",84,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",84,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",84,[[],["m64x8"]]],[11,"ne","","Lane-wise inequality comparison.",84,[[],["m64x8"]]],[11,"lt","","Lane-wise less-than comparison.",84,[[],["m64x8"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",84,[[],["m64x8"]]],[11,"gt","","Lane-wise greater-than comparison.",84,[[],["m64x8"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",84,[[],["m64x8"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",84,[[["self"]],[["i64x8"],["lexicographicallyordered",["i64x8"]]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",84,[[["self"]],[["i64x8"],["lexicographicallyordered",["i64x8"]]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",84,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",85,[[["u64"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",85,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",85,[[["u64"]],["self"]]],[11,"extract","","Extracts the value at `index`.",85,[[["usize"]],["u64"]]],[11,"extract_unchecked","","Extracts the value at `index`.",85,[[["usize"]],["u64"]]],[11,"replace","","Returns a new vector where the value at `index` is…",85,[[["usize"],["u64"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",85,[[["usize"],["u64"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",85,[[["u64x8"]],["u64x8"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",85,[[["u64x8"]],["u64x8"]]],[11,"min","","Minimum of two vectors.",85,[[],["self"]]],[11,"max","","Maximum of two vectors.",85,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",85,[[],["u64"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",85,[[],["u64"]]],[11,"max_element","","Largest vector element value.",85,[[],["u64"]]],[11,"min_element","","Smallest vector element value.",85,[[],["u64"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",85,[[],["u64"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",85,[[],["u64"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",85,[[],["u64"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",85,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",85,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",85,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",85,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",85,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",85,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",85,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",85,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",85,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",85,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",85,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",85,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",85,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",85,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",85,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",85,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",85,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",85,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",85,[[],["m64x8"]]],[11,"ne","","Lane-wise inequality comparison.",85,[[],["m64x8"]]],[11,"lt","","Lane-wise less-than comparison.",85,[[],["m64x8"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",85,[[],["m64x8"]]],[11,"gt","","Lane-wise greater-than comparison.",85,[[],["m64x8"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",85,[[],["m64x8"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",85,[[["self"]],[["lexicographicallyordered",["u64x8"]],["u64x8"]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",85,[[["self"]],[["lexicographicallyordered",["u64x8"]],["u64x8"]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",85,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",86,[[["f64"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",86,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",86,[[["f64"]],["self"]]],[11,"extract","","Extracts the value at `index`.",86,[[["usize"]],["f64"]]],[11,"extract_unchecked","","Extracts the value at `index`.",86,[[["usize"]],["f64"]]],[11,"replace","","Returns a new vector where the value at `index` is…",86,[[["f64"],["usize"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",86,[[["f64"],["usize"]],["self"]]],[11,"min","","Minimum of two vectors.",86,[[],["self"]]],[11,"max","","Maximum of two vectors.",86,[[],["self"]]],[11,"sum","","Horizontal sum of the vector elements.",86,[[],["f64"]]],[11,"product","","Horizontal product of the vector elements.",86,[[],["f64"]]],[11,"max_element","","Largest vector element value.",86,[[],["f64"]]],[11,"min_element","","Smallest vector element value.",86,[[],["f64"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",86,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",86,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",86,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",86,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",86,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",86,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",86,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",86,[[]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",86,[[["i"]],["self"]]],[18,"EPSILON","","Machine epsilon value.",86,null],[18,"MIN","","Smallest finite value.",86,null],[18,"MIN_POSITIVE","","Smallest positive normal value.",86,null],[18,"MAX","","Largest finite value.",86,null],[18,"NAN","","Not a Number (NaN).",86,null],[18,"INFINITY","","Infinity (∞).",86,null],[18,"NEG_INFINITY","","Negative infinity (-∞).",86,null],[18,"PI","","Archimedes' constant (π)",86,null],[18,"FRAC_PI_2","","π/2",86,null],[18,"FRAC_PI_3","","π/3",86,null],[18,"FRAC_PI_4","","π/4",86,null],[18,"FRAC_PI_6","","π/6",86,null],[18,"FRAC_PI_8","","π/8",86,null],[18,"FRAC_1_PI","","1/π",86,null],[18,"FRAC_2_PI","","2/π",86,null],[18,"FRAC_2_SQRT_PI","","2/sqrt(π)",86,null],[18,"SQRT_2","","sqrt(2)",86,null],[18,"FRAC_1_SQRT_2","","1/sqrt(2)",86,null],[18,"E","","Euler's number (e)",86,null],[18,"LOG2_E","","log2(e)",86,null],[18,"LOG10_E","","log10(e)",86,null],[18,"LN_2","","ln(2)",86,null],[18,"LN_10","","ln(10)",86,null],[11,"is_nan","","",86,[[],["m64x8"]]],[11,"is_infinite","","",86,[[],["m64x8"]]],[11,"is_finite","","",86,[[],["m64x8"]]],[11,"abs","","Absolute value.",86,[[],["self"]]],[11,"cos","","Cosine.",86,[[],["self"]]],[11,"cos_pi","","Cosine of `self * PI`.",86,[[],["self"]]],[11,"exp","","Returns the exponential function of `self`: `e^(self)`.",86,[[],["self"]]],[11,"ln","","Returns the natural logarithm of `self`.",86,[[],["self"]]],[11,"mul_add","","Fused multiply add: `self * y + z`",86,[[],["self"]]],[11,"mul_adde","","Fused multiply add estimate: ~= `self * y + z`",86,[[],["self"]]],[11,"powf","","Raises `self` number to the floating point power of `x`.",86,[[],["self"]]],[11,"recpre","","Reciprocal estimate: `~= 1. / self`.",86,[[],["self"]]],[11,"rsqrte","","Reciprocal square-root estimate: `~= 1. / self.sqrt()`.",86,[[],["self"]]],[11,"sin","","Sine.",86,[[],["self"]]],[11,"sin_pi","","Sine of `self * PI`.",86,[[],["self"]]],[11,"sin_cos_pi","","Sine and cosine of `self * PI`.",86,[[]]],[11,"sqrt","","",86,[[],["self"]]],[11,"sqrte","","Square-root estimate.",86,[[],["self"]]],[11,"tanh","","Tanh.",86,[[],["self"]]],[11,"eq","","Lane-wise equality comparison.",86,[[],["m64x8"]]],[11,"ne","","Lane-wise inequality comparison.",86,[[],["m64x8"]]],[11,"lt","","Lane-wise less-than comparison.",86,[[],["m64x8"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",86,[[],["m64x8"]]],[11,"gt","","Lane-wise greater-than comparison.",86,[[],["m64x8"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",86,[[],["m64x8"]]],[11,"new","","Creates a new instance with each vector elements…",87,[[["bool"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",87,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",87,[[["bool"]],["self"]]],[11,"extract","","Extracts the value at `index`.",87,[[["usize"]],["bool"]]],[11,"extract_unchecked","","Extracts the value at `index`.",87,[[["usize"]],["bool"]]],[11,"replace","","Returns a new vector where the value at `index` is…",87,[[["usize"],["bool"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",87,[[["usize"],["bool"]],["self"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",87,[[],["bool"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",87,[[],["bool"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",87,[[],["bool"]]],[11,"all","","Are `all` vector lanes `true`?",87,[[],["bool"]]],[11,"any","","Is `any` vector lane `true`?",87,[[],["bool"]]],[11,"none","","Are `all` vector lanes `false`?",87,[[],["bool"]]],[11,"eq","","Lane-wise equality comparison.",87,[[],["m64x8"]]],[11,"ne","","Lane-wise inequality comparison.",87,[[],["m64x8"]]],[11,"lt","","Lane-wise less-than comparison.",87,[[],["m64x8"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",87,[[],["m64x8"]]],[11,"gt","","Lane-wise greater-than comparison.",87,[[],["m64x8"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",87,[[],["m64x8"]]],[11,"select","","Selects elements of `a` and `b` using mask.",87,[[["simd"]],["simd"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",87,[[["self"]],[["lexicographicallyordered",["m64x8"]],["m64x8"]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",87,[[["self"]],[["lexicographicallyordered",["m64x8"]],["m64x8"]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",87,[[["i"]],["self"]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",87,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",88,[[["i128"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",88,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",88,[[["i128"]],["self"]]],[11,"extract","","Extracts the value at `index`.",88,[[["usize"]],["i128"]]],[11,"extract_unchecked","","Extracts the value at `index`.",88,[[["usize"]],["i128"]]],[11,"replace","","Returns a new vector where the value at `index` is…",88,[[["i128"],["usize"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",88,[[["i128"],["usize"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",88,[[["i128x4"]],["i128x4"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",88,[[["i128x4"]],["i128x4"]]],[11,"min","","Minimum of two vectors.",88,[[],["self"]]],[11,"max","","Maximum of two vectors.",88,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",88,[[],["i128"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",88,[[],["i128"]]],[11,"max_element","","Largest vector element value.",88,[[],["i128"]]],[11,"min_element","","Smallest vector element value.",88,[[],["i128"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",88,[[],["i128"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",88,[[],["i128"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",88,[[],["i128"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",88,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",88,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",88,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",88,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",88,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",88,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",88,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",88,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",88,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",88,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",88,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",88,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",88,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",88,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",88,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",88,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",88,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",88,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",88,[[],["m128x4"]]],[11,"ne","","Lane-wise inequality comparison.",88,[[],["m128x4"]]],[11,"lt","","Lane-wise less-than comparison.",88,[[],["m128x4"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",88,[[],["m128x4"]]],[11,"gt","","Lane-wise greater-than comparison.",88,[[],["m128x4"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",88,[[],["m128x4"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",88,[[["self"]],[["i128x4"],["lexicographicallyordered",["i128x4"]]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",88,[[["self"]],[["i128x4"],["lexicographicallyordered",["i128x4"]]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",88,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",89,[[["u128"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",89,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",89,[[["u128"]],["self"]]],[11,"extract","","Extracts the value at `index`.",89,[[["usize"]],["u128"]]],[11,"extract_unchecked","","Extracts the value at `index`.",89,[[["usize"]],["u128"]]],[11,"replace","","Returns a new vector where the value at `index` is…",89,[[["usize"],["u128"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",89,[[["usize"],["u128"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",89,[[["u128x4"]],["u128x4"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",89,[[["u128x4"]],["u128x4"]]],[11,"min","","Minimum of two vectors.",89,[[],["self"]]],[11,"max","","Maximum of two vectors.",89,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",89,[[],["u128"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",89,[[],["u128"]]],[11,"max_element","","Largest vector element value.",89,[[],["u128"]]],[11,"min_element","","Smallest vector element value.",89,[[],["u128"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",89,[[],["u128"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",89,[[],["u128"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",89,[[],["u128"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",89,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",89,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",89,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",89,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",89,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",89,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",89,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",89,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",89,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",89,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",89,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",89,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",89,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",89,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",89,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",89,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",89,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",89,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",89,[[],["m128x4"]]],[11,"ne","","Lane-wise inequality comparison.",89,[[],["m128x4"]]],[11,"lt","","Lane-wise less-than comparison.",89,[[],["m128x4"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",89,[[],["m128x4"]]],[11,"gt","","Lane-wise greater-than comparison.",89,[[],["m128x4"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",89,[[],["m128x4"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",89,[[["self"]],[["u128x4"],["lexicographicallyordered",["u128x4"]]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",89,[[["self"]],[["u128x4"],["lexicographicallyordered",["u128x4"]]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",89,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",90,[[["bool"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",90,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",90,[[["bool"]],["self"]]],[11,"extract","","Extracts the value at `index`.",90,[[["usize"]],["bool"]]],[11,"extract_unchecked","","Extracts the value at `index`.",90,[[["usize"]],["bool"]]],[11,"replace","","Returns a new vector where the value at `index` is…",90,[[["usize"],["bool"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",90,[[["usize"],["bool"]],["self"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",90,[[],["bool"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",90,[[],["bool"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",90,[[],["bool"]]],[11,"all","","Are `all` vector lanes `true`?",90,[[],["bool"]]],[11,"any","","Is `any` vector lane `true`?",90,[[],["bool"]]],[11,"none","","Are `all` vector lanes `false`?",90,[[],["bool"]]],[11,"eq","","Lane-wise equality comparison.",90,[[],["m128x4"]]],[11,"ne","","Lane-wise inequality comparison.",90,[[],["m128x4"]]],[11,"lt","","Lane-wise less-than comparison.",90,[[],["m128x4"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",90,[[],["m128x4"]]],[11,"gt","","Lane-wise greater-than comparison.",90,[[],["m128x4"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",90,[[],["m128x4"]]],[11,"select","","Selects elements of `a` and `b` using mask.",90,[[["simd"]],["simd"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",90,[[["self"]],[["lexicographicallyordered",["m128x4"]],["m128x4"]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",90,[[["self"]],[["lexicographicallyordered",["m128x4"]],["m128x4"]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",90,[[["i"]],["self"]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",90,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",48,[[["isize"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",48,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",48,[[["isize"]],["self"]]],[11,"extract","","Extracts the value at `index`.",48,[[["usize"]],["isize"]]],[11,"extract_unchecked","","Extracts the value at `index`.",48,[[["usize"]],["isize"]]],[11,"replace","","Returns a new vector where the value at `index` is…",48,[[["isize"],["usize"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",48,[[["isize"],["usize"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",48,[[["isizex2"]],["isizex2"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",48,[[["isizex2"]],["isizex2"]]],[11,"min","","Minimum of two vectors.",48,[[],["self"]]],[11,"max","","Maximum of two vectors.",48,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",48,[[],["isize"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",48,[[],["isize"]]],[11,"max_element","","Largest vector element value.",48,[[],["isize"]]],[11,"min_element","","Smallest vector element value.",48,[[],["isize"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",48,[[],["isize"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",48,[[],["isize"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",48,[[],["isize"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",48,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",48,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",48,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",48,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",48,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",48,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",48,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",48,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",48,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",48,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",48,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",48,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",48,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",48,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",48,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",48,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",48,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",48,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",48,[[],["msizex2"]]],[11,"ne","","Lane-wise inequality comparison.",48,[[],["msizex2"]]],[11,"lt","","Lane-wise less-than comparison.",48,[[],["msizex2"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",48,[[],["msizex2"]]],[11,"gt","","Lane-wise greater-than comparison.",48,[[],["msizex2"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",48,[[],["msizex2"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",48,[[["self"]],[["isizex2"],["lexicographicallyordered",["isizex2"]]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",48,[[["self"]],[["isizex2"],["lexicographicallyordered",["isizex2"]]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",48,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",49,[[["usize"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",49,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",49,[[["usize"]],["self"]]],[11,"extract","","Extracts the value at `index`.",49,[[["usize"]],["usize"]]],[11,"extract_unchecked","","Extracts the value at `index`.",49,[[["usize"]],["usize"]]],[11,"replace","","Returns a new vector where the value at `index` is…",49,[[["usize"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",49,[[["usize"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",49,[[["usizex2"]],["usizex2"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",49,[[["usizex2"]],["usizex2"]]],[11,"min","","Minimum of two vectors.",49,[[],["self"]]],[11,"max","","Maximum of two vectors.",49,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",49,[[],["usize"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",49,[[],["usize"]]],[11,"max_element","","Largest vector element value.",49,[[],["usize"]]],[11,"min_element","","Smallest vector element value.",49,[[],["usize"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",49,[[],["usize"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",49,[[],["usize"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",49,[[],["usize"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",49,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",49,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",49,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",49,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",49,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",49,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",49,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",49,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",49,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",49,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",49,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",49,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",49,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",49,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",49,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",49,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",49,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",49,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",49,[[],["msizex2"]]],[11,"ne","","Lane-wise inequality comparison.",49,[[],["msizex2"]]],[11,"lt","","Lane-wise less-than comparison.",49,[[],["msizex2"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",49,[[],["msizex2"]]],[11,"gt","","Lane-wise greater-than comparison.",49,[[],["msizex2"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",49,[[],["msizex2"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",49,[[["self"]],[["usizex2"],["lexicographicallyordered",["usizex2"]]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",49,[[["self"]],[["usizex2"],["lexicographicallyordered",["usizex2"]]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",49,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",50,[[["bool"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",50,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",50,[[["bool"]],["self"]]],[11,"extract","","Extracts the value at `index`.",50,[[["usize"]],["bool"]]],[11,"extract_unchecked","","Extracts the value at `index`.",50,[[["usize"]],["bool"]]],[11,"replace","","Returns a new vector where the value at `index` is…",50,[[["usize"],["bool"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",50,[[["usize"],["bool"]],["self"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",50,[[],["bool"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",50,[[],["bool"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",50,[[],["bool"]]],[11,"all","","Are `all` vector lanes `true`?",50,[[],["bool"]]],[11,"any","","Is `any` vector lane `true`?",50,[[],["bool"]]],[11,"none","","Are `all` vector lanes `false`?",50,[[],["bool"]]],[11,"eq","","Lane-wise equality comparison.",50,[[],["msizex2"]]],[11,"ne","","Lane-wise inequality comparison.",50,[[],["msizex2"]]],[11,"lt","","Lane-wise less-than comparison.",50,[[],["msizex2"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",50,[[],["msizex2"]]],[11,"gt","","Lane-wise greater-than comparison.",50,[[],["msizex2"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",50,[[],["msizex2"]]],[11,"select","","Selects elements of `a` and `b` using mask.",50,[[["simd"]],["simd"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",50,[[["self"]],[["lexicographicallyordered",["msizex2"]],["msizex2"]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",50,[[["self"]],[["lexicographicallyordered",["msizex2"]],["msizex2"]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",50,[[["i"]],["self"]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",50,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",71,[[["isize"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",71,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",71,[[["isize"]],["self"]]],[11,"extract","","Extracts the value at `index`.",71,[[["usize"]],["isize"]]],[11,"extract_unchecked","","Extracts the value at `index`.",71,[[["usize"]],["isize"]]],[11,"replace","","Returns a new vector where the value at `index` is…",71,[[["isize"],["usize"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",71,[[["isize"],["usize"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",71,[[["isizex4"]],["isizex4"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",71,[[["isizex4"]],["isizex4"]]],[11,"min","","Minimum of two vectors.",71,[[],["self"]]],[11,"max","","Maximum of two vectors.",71,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",71,[[],["isize"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",71,[[],["isize"]]],[11,"max_element","","Largest vector element value.",71,[[],["isize"]]],[11,"min_element","","Smallest vector element value.",71,[[],["isize"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",71,[[],["isize"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",71,[[],["isize"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",71,[[],["isize"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",71,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",71,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",71,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",71,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",71,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",71,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",71,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",71,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",71,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",71,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",71,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",71,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",71,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",71,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",71,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",71,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",71,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",71,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",71,[[],["msizex4"]]],[11,"ne","","Lane-wise inequality comparison.",71,[[],["msizex4"]]],[11,"lt","","Lane-wise less-than comparison.",71,[[],["msizex4"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",71,[[],["msizex4"]]],[11,"gt","","Lane-wise greater-than comparison.",71,[[],["msizex4"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",71,[[],["msizex4"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",71,[[["self"]],[["isizex4"],["lexicographicallyordered",["isizex4"]]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",71,[[["self"]],[["isizex4"],["lexicographicallyordered",["isizex4"]]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",71,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",72,[[["usize"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",72,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",72,[[["usize"]],["self"]]],[11,"extract","","Extracts the value at `index`.",72,[[["usize"]],["usize"]]],[11,"extract_unchecked","","Extracts the value at `index`.",72,[[["usize"]],["usize"]]],[11,"replace","","Returns a new vector where the value at `index` is…",72,[[["usize"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",72,[[["usize"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",72,[[["usizex4"]],["usizex4"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",72,[[["usizex4"]],["usizex4"]]],[11,"min","","Minimum of two vectors.",72,[[],["self"]]],[11,"max","","Maximum of two vectors.",72,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",72,[[],["usize"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",72,[[],["usize"]]],[11,"max_element","","Largest vector element value.",72,[[],["usize"]]],[11,"min_element","","Smallest vector element value.",72,[[],["usize"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",72,[[],["usize"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",72,[[],["usize"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",72,[[],["usize"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",72,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",72,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",72,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",72,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",72,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",72,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",72,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",72,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",72,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",72,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",72,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",72,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",72,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",72,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",72,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",72,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",72,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",72,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",72,[[],["msizex4"]]],[11,"ne","","Lane-wise inequality comparison.",72,[[],["msizex4"]]],[11,"lt","","Lane-wise less-than comparison.",72,[[],["msizex4"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",72,[[],["msizex4"]]],[11,"gt","","Lane-wise greater-than comparison.",72,[[],["msizex4"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",72,[[],["msizex4"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",72,[[["self"]],[["usizex4"],["lexicographicallyordered",["usizex4"]]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",72,[[["self"]],[["usizex4"],["lexicographicallyordered",["usizex4"]]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",72,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",73,[[["bool"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",73,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",73,[[["bool"]],["self"]]],[11,"extract","","Extracts the value at `index`.",73,[[["usize"]],["bool"]]],[11,"extract_unchecked","","Extracts the value at `index`.",73,[[["usize"]],["bool"]]],[11,"replace","","Returns a new vector where the value at `index` is…",73,[[["usize"],["bool"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",73,[[["usize"],["bool"]],["self"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",73,[[],["bool"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",73,[[],["bool"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",73,[[],["bool"]]],[11,"all","","Are `all` vector lanes `true`?",73,[[],["bool"]]],[11,"any","","Is `any` vector lane `true`?",73,[[],["bool"]]],[11,"none","","Are `all` vector lanes `false`?",73,[[],["bool"]]],[11,"eq","","Lane-wise equality comparison.",73,[[],["msizex4"]]],[11,"ne","","Lane-wise inequality comparison.",73,[[],["msizex4"]]],[11,"lt","","Lane-wise less-than comparison.",73,[[],["msizex4"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",73,[[],["msizex4"]]],[11,"gt","","Lane-wise greater-than comparison.",73,[[],["msizex4"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",73,[[],["msizex4"]]],[11,"select","","Selects elements of `a` and `b` using mask.",73,[[["simd"]],["simd"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",73,[[["self"]],[["lexicographicallyordered",["msizex4"]],["msizex4"]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",73,[[["self"]],[["lexicographicallyordered",["msizex4"]],["msizex4"]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",73,[[["i"]],["self"]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",73,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",91,[[["isize"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",91,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",91,[[["isize"]],["self"]]],[11,"extract","","Extracts the value at `index`.",91,[[["usize"]],["isize"]]],[11,"extract_unchecked","","Extracts the value at `index`.",91,[[["usize"]],["isize"]]],[11,"replace","","Returns a new vector where the value at `index` is…",91,[[["isize"],["usize"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",91,[[["isize"],["usize"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",91,[[["isizex8"]],["isizex8"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",91,[[["isizex8"]],["isizex8"]]],[11,"min","","Minimum of two vectors.",91,[[],["self"]]],[11,"max","","Maximum of two vectors.",91,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",91,[[],["isize"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",91,[[],["isize"]]],[11,"max_element","","Largest vector element value.",91,[[],["isize"]]],[11,"min_element","","Smallest vector element value.",91,[[],["isize"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",91,[[],["isize"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",91,[[],["isize"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",91,[[],["isize"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",91,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",91,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",91,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",91,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",91,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",91,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",91,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",91,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",91,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",91,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",91,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",91,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",91,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",91,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",91,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",91,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",91,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",91,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",91,[[],["msizex8"]]],[11,"ne","","Lane-wise inequality comparison.",91,[[],["msizex8"]]],[11,"lt","","Lane-wise less-than comparison.",91,[[],["msizex8"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",91,[[],["msizex8"]]],[11,"gt","","Lane-wise greater-than comparison.",91,[[],["msizex8"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",91,[[],["msizex8"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",91,[[["self"]],[["lexicographicallyordered",["isizex8"]],["isizex8"]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",91,[[["self"]],[["lexicographicallyordered",["isizex8"]],["isizex8"]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",91,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",92,[[["usize"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",92,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",92,[[["usize"]],["self"]]],[11,"extract","","Extracts the value at `index`.",92,[[["usize"]],["usize"]]],[11,"extract_unchecked","","Extracts the value at `index`.",92,[[["usize"]],["usize"]]],[11,"replace","","Returns a new vector where the value at `index` is…",92,[[["usize"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",92,[[["usize"]],["self"]]],[11,"rotate_left","","Shifts the bits of each lane to the left by the specified…",92,[[["usizex8"]],["usizex8"]]],[11,"rotate_right","","Shifts the bits of each lane to the right by the specified…",92,[[["usizex8"]],["usizex8"]]],[11,"min","","Minimum of two vectors.",92,[[],["self"]]],[11,"max","","Maximum of two vectors.",92,[[],["self"]]],[11,"wrapping_sum","","Horizontal wrapping sum of the vector elements.",92,[[],["usize"]]],[11,"wrapping_product","","Horizontal wrapping product of the vector elements.",92,[[],["usize"]]],[11,"max_element","","Largest vector element value.",92,[[],["usize"]]],[11,"min_element","","Smallest vector element value.",92,[[],["usize"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",92,[[],["usize"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",92,[[],["usize"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",92,[[],["usize"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",92,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",92,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",92,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",92,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",92,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",92,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",92,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",92,[[]]],[11,"swap_bytes","","Reverses the byte order of the vector.",92,[[],["self"]]],[11,"to_le","","Converts self to little endian from the target's endianness.",92,[[],["self"]]],[11,"to_be","","Converts self to big endian from the target's endianness.",92,[[],["self"]]],[11,"from_le","","Converts a vector from little endian to the target's…",92,[[],["self"]]],[11,"from_be","","Converts a vector from big endian to the target's…",92,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of…",92,[[],["self"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation…",92,[[],["self"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary…",92,[[],["self"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary…",92,[[],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",92,[[["i"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",92,[[],["msizex8"]]],[11,"ne","","Lane-wise inequality comparison.",92,[[],["msizex8"]]],[11,"lt","","Lane-wise less-than comparison.",92,[[],["msizex8"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",92,[[],["msizex8"]]],[11,"gt","","Lane-wise greater-than comparison.",92,[[],["msizex8"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",92,[[],["msizex8"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",92,[[["self"]],[["usizex8"],["lexicographicallyordered",["usizex8"]]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",92,[[["self"]],[["usizex8"],["lexicographicallyordered",["usizex8"]]]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",92,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",93,[[["bool"]],["self"]]],[11,"lanes","","Returns the number of vector lanes.",93,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",93,[[["bool"]],["self"]]],[11,"extract","","Extracts the value at `index`.",93,[[["usize"]],["bool"]]],[11,"extract_unchecked","","Extracts the value at `index`.",93,[[["usize"]],["bool"]]],[11,"replace","","Returns a new vector where the value at `index` is…",93,[[["usize"],["bool"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",93,[[["usize"],["bool"]],["self"]]],[11,"and","","Lane-wise bitwise `and` of the vector elements.",93,[[],["bool"]]],[11,"or","","Lane-wise bitwise `or` of the vector elements.",93,[[],["bool"]]],[11,"xor","","Lane-wise bitwise `xor` of the vector elements.",93,[[],["bool"]]],[11,"all","","Are `all` vector lanes `true`?",93,[[],["bool"]]],[11,"any","","Is `any` vector lane `true`?",93,[[],["bool"]]],[11,"none","","Are `all` vector lanes `false`?",93,[[],["bool"]]],[11,"eq","","Lane-wise equality comparison.",93,[[],["msizex8"]]],[11,"ne","","Lane-wise inequality comparison.",93,[[],["msizex8"]]],[11,"lt","","Lane-wise less-than comparison.",93,[[],["msizex8"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",93,[[],["msizex8"]]],[11,"gt","","Lane-wise greater-than comparison.",93,[[],["msizex8"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",93,[[],["msizex8"]]],[11,"select","","Selects elements of `a` and `b` using mask.",93,[[["simd"]],["simd"]]],[11,"partial_lex_ord","","Returns a wrapper that implements `PartialOrd`.",93,[[["self"]],[["lexicographicallyordered",["msizex8"]],["msizex8"]]]],[11,"lex_ord","","Returns a wrapper that implements `Ord`.",93,[[["self"]],[["lexicographicallyordered",["msizex8"]],["msizex8"]]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",93,[[["i"]],["self"]]],[11,"bitmask","","Creates a bitmask with the MSB of each vector lane.",93,[[],["u8"]]],[11,"new","","Creates a new instance with each vector elements…",94,[[],["self"]]],[11,"lanes","","Returns the number of vector lanes.",94,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",94,[[],["self"]]],[11,"null","","Constructs a new instance with each element initialized to…",94,[[],["self"]]],[11,"is_null","","Returns a mask that selects those lanes that contain…",94,[[],["msizex2"]]],[11,"extract","","Extracts the value at `index`.",94,[[["usize"]]]],[11,"extract_unchecked","","Extracts the value at `index`.",94,[[["usize"]]]],[11,"replace","","Returns a new vector where the value at `index` is…",94,[[["usize"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",94,[[["usize"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",94,[[],["msizex2"]]],[11,"ne","","Lane-wise inequality comparison.",94,[[],["msizex2"]]],[11,"lt","","Lane-wise less-than comparison.",94,[[],["msizex2"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",94,[[],["msizex2"]]],[11,"gt","","Lane-wise greater-than comparison.",94,[[],["msizex2"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",94,[[],["msizex2"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",94,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",94,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",94,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",94,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",94,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",94,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",94,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",94,[[]]],[11,"offset","","Calculates the offset from a pointer.",94,[[["isizex2"]],["self"]]],[11,"wrapping_offset","","Calculates the offset from a pointer using wrapping…",94,[[["isizex2"]],["self"]]],[11,"offset_from","","Calculates the distance between two pointers.",94,[[],["isizex2"]]],[11,"wrapping_offset_from","","Calculates the distance between two pointers.",94,[[],["isizex2"]]],[11,"add","","Calculates the offset from a pointer (convenience for…",94,[[["usizex2"]],["self"]]],[11,"sub","","Calculates the offset from a pointer (convenience for…",94,[[["usizex2"]],["self"]]],[11,"wrapping_add","","Calculates the offset from a pointer using wrapping…",94,[[["usizex2"]],["self"]]],[11,"wrapping_sub","","Calculates the offset from a pointer using wrapping…",94,[[["usizex2"]],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",94,[[["i"]],["self"]]],[11,"read","","Reads selected vector elements from memory.",94,[[["simd"],["simd"]],["simd"]]],[11,"new","","Creates a new instance with each vector elements…",95,[[],["self"]]],[11,"lanes","","Returns the number of vector lanes.",95,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",95,[[],["self"]]],[11,"null","","Constructs a new instance with each element initialized to…",95,[[],["self"]]],[11,"is_null","","Returns a mask that selects those lanes that contain…",95,[[],["msizex2"]]],[11,"extract","","Extracts the value at `index`.",95,[[["usize"]]]],[11,"extract_unchecked","","Extracts the value at `index`.",95,[[["usize"]]]],[11,"replace","","Returns a new vector where the value at `index` is…",95,[[["usize"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",95,[[["usize"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",95,[[],["msizex2"]]],[11,"ne","","Lane-wise inequality comparison.",95,[[],["msizex2"]]],[11,"lt","","Lane-wise less-than comparison.",95,[[],["msizex2"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",95,[[],["msizex2"]]],[11,"gt","","Lane-wise greater-than comparison.",95,[[],["msizex2"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",95,[[],["msizex2"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",95,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",95,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",95,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",95,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",95,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",95,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",95,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",95,[[]]],[11,"offset","","Calculates the offset from a pointer.",95,[[["isizex2"]],["self"]]],[11,"wrapping_offset","","Calculates the offset from a pointer using wrapping…",95,[[["isizex2"]],["self"]]],[11,"offset_from","","Calculates the distance between two pointers.",95,[[],["isizex2"]]],[11,"wrapping_offset_from","","Calculates the distance between two pointers.",95,[[],["isizex2"]]],[11,"add","","Calculates the offset from a pointer (convenience for…",95,[[["usizex2"]],["self"]]],[11,"sub","","Calculates the offset from a pointer (convenience for…",95,[[["usizex2"]],["self"]]],[11,"wrapping_add","","Calculates the offset from a pointer using wrapping…",95,[[["usizex2"]],["self"]]],[11,"wrapping_sub","","Calculates the offset from a pointer using wrapping…",95,[[["usizex2"]],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",95,[[["i"]],["self"]]],[11,"read","","Reads selected vector elements from memory.",95,[[["simd"],["simd"]],["simd"]]],[11,"write","","Writes selected vector elements to memory.",95,[[["simd"],["simd"]]]],[11,"new","","Creates a new instance with each vector elements…",96,[[],["self"]]],[11,"lanes","","Returns the number of vector lanes.",96,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",96,[[],["self"]]],[11,"null","","Constructs a new instance with each element initialized to…",96,[[],["self"]]],[11,"is_null","","Returns a mask that selects those lanes that contain…",96,[[],["msizex4"]]],[11,"extract","","Extracts the value at `index`.",96,[[["usize"]]]],[11,"extract_unchecked","","Extracts the value at `index`.",96,[[["usize"]]]],[11,"replace","","Returns a new vector where the value at `index` is…",96,[[["usize"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",96,[[["usize"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",96,[[],["msizex4"]]],[11,"ne","","Lane-wise inequality comparison.",96,[[],["msizex4"]]],[11,"lt","","Lane-wise less-than comparison.",96,[[],["msizex4"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",96,[[],["msizex4"]]],[11,"gt","","Lane-wise greater-than comparison.",96,[[],["msizex4"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",96,[[],["msizex4"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",96,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",96,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",96,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",96,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",96,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",96,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",96,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",96,[[]]],[11,"offset","","Calculates the offset from a pointer.",96,[[["isizex4"]],["self"]]],[11,"wrapping_offset","","Calculates the offset from a pointer using wrapping…",96,[[["isizex4"]],["self"]]],[11,"offset_from","","Calculates the distance between two pointers.",96,[[],["isizex4"]]],[11,"wrapping_offset_from","","Calculates the distance between two pointers.",96,[[],["isizex4"]]],[11,"add","","Calculates the offset from a pointer (convenience for…",96,[[["usizex4"]],["self"]]],[11,"sub","","Calculates the offset from a pointer (convenience for…",96,[[["usizex4"]],["self"]]],[11,"wrapping_add","","Calculates the offset from a pointer using wrapping…",96,[[["usizex4"]],["self"]]],[11,"wrapping_sub","","Calculates the offset from a pointer using wrapping…",96,[[["usizex4"]],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",96,[[["i"]],["self"]]],[11,"read","","Reads selected vector elements from memory.",96,[[["simd"],["simd"]],["simd"]]],[11,"new","","Creates a new instance with each vector elements…",97,[[],["self"]]],[11,"lanes","","Returns the number of vector lanes.",97,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",97,[[],["self"]]],[11,"null","","Constructs a new instance with each element initialized to…",97,[[],["self"]]],[11,"is_null","","Returns a mask that selects those lanes that contain…",97,[[],["msizex4"]]],[11,"extract","","Extracts the value at `index`.",97,[[["usize"]]]],[11,"extract_unchecked","","Extracts the value at `index`.",97,[[["usize"]]]],[11,"replace","","Returns a new vector where the value at `index` is…",97,[[["usize"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",97,[[["usize"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",97,[[],["msizex4"]]],[11,"ne","","Lane-wise inequality comparison.",97,[[],["msizex4"]]],[11,"lt","","Lane-wise less-than comparison.",97,[[],["msizex4"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",97,[[],["msizex4"]]],[11,"gt","","Lane-wise greater-than comparison.",97,[[],["msizex4"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",97,[[],["msizex4"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",97,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",97,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",97,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",97,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",97,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",97,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",97,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",97,[[]]],[11,"offset","","Calculates the offset from a pointer.",97,[[["isizex4"]],["self"]]],[11,"wrapping_offset","","Calculates the offset from a pointer using wrapping…",97,[[["isizex4"]],["self"]]],[11,"offset_from","","Calculates the distance between two pointers.",97,[[],["isizex4"]]],[11,"wrapping_offset_from","","Calculates the distance between two pointers.",97,[[],["isizex4"]]],[11,"add","","Calculates the offset from a pointer (convenience for…",97,[[["usizex4"]],["self"]]],[11,"sub","","Calculates the offset from a pointer (convenience for…",97,[[["usizex4"]],["self"]]],[11,"wrapping_add","","Calculates the offset from a pointer using wrapping…",97,[[["usizex4"]],["self"]]],[11,"wrapping_sub","","Calculates the offset from a pointer using wrapping…",97,[[["usizex4"]],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",97,[[["i"]],["self"]]],[11,"read","","Reads selected vector elements from memory.",97,[[["simd"],["simd"]],["simd"]]],[11,"write","","Writes selected vector elements to memory.",97,[[["simd"],["simd"]]]],[11,"new","","Creates a new instance with each vector elements…",98,[[],["self"]]],[11,"lanes","","Returns the number of vector lanes.",98,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",98,[[],["self"]]],[11,"null","","Constructs a new instance with each element initialized to…",98,[[],["self"]]],[11,"is_null","","Returns a mask that selects those lanes that contain…",98,[[],["msizex8"]]],[11,"extract","","Extracts the value at `index`.",98,[[["usize"]]]],[11,"extract_unchecked","","Extracts the value at `index`.",98,[[["usize"]]]],[11,"replace","","Returns a new vector where the value at `index` is…",98,[[["usize"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",98,[[["usize"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",98,[[],["msizex8"]]],[11,"ne","","Lane-wise inequality comparison.",98,[[],["msizex8"]]],[11,"lt","","Lane-wise less-than comparison.",98,[[],["msizex8"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",98,[[],["msizex8"]]],[11,"gt","","Lane-wise greater-than comparison.",98,[[],["msizex8"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",98,[[],["msizex8"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",98,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",98,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",98,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",98,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",98,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",98,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",98,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",98,[[]]],[11,"offset","","Calculates the offset from a pointer.",98,[[["isizex8"]],["self"]]],[11,"wrapping_offset","","Calculates the offset from a pointer using wrapping…",98,[[["isizex8"]],["self"]]],[11,"offset_from","","Calculates the distance between two pointers.",98,[[],["isizex8"]]],[11,"wrapping_offset_from","","Calculates the distance between two pointers.",98,[[],["isizex8"]]],[11,"add","","Calculates the offset from a pointer (convenience for…",98,[[["usizex8"]],["self"]]],[11,"sub","","Calculates the offset from a pointer (convenience for…",98,[[["usizex8"]],["self"]]],[11,"wrapping_add","","Calculates the offset from a pointer using wrapping…",98,[[["usizex8"]],["self"]]],[11,"wrapping_sub","","Calculates the offset from a pointer using wrapping…",98,[[["usizex8"]],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",98,[[["i"]],["self"]]],[11,"read","","Reads selected vector elements from memory.",98,[[["simd"],["simd"]],["simd"]]],[11,"new","","Creates a new instance with each vector elements…",99,[[],["self"]]],[11,"lanes","","Returns the number of vector lanes.",99,[[],["usize"]]],[11,"splat","","Constructs a new instance with each element initialized to…",99,[[],["self"]]],[11,"null","","Constructs a new instance with each element initialized to…",99,[[],["self"]]],[11,"is_null","","Returns a mask that selects those lanes that contain…",99,[[],["msizex8"]]],[11,"extract","","Extracts the value at `index`.",99,[[["usize"]]]],[11,"extract_unchecked","","Extracts the value at `index`.",99,[[["usize"]]]],[11,"replace","","Returns a new vector where the value at `index` is…",99,[[["usize"]],["self"]]],[11,"replace_unchecked","","Returns a new vector where the value at `index` is…",99,[[["usize"]],["self"]]],[11,"eq","","Lane-wise equality comparison.",99,[[],["msizex8"]]],[11,"ne","","Lane-wise inequality comparison.",99,[[],["msizex8"]]],[11,"lt","","Lane-wise less-than comparison.",99,[[],["msizex8"]]],[11,"le","","Lane-wise less-than-or-equals comparison.",99,[[],["msizex8"]]],[11,"gt","","Lane-wise greater-than comparison.",99,[[],["msizex8"]]],[11,"ge","","Lane-wise greater-than-or-equals comparison.",99,[[],["msizex8"]]],[11,"from_slice_aligned","","Instantiates a new vector with the values of the `slice`.",99,[[],["self"]]],[11,"from_slice_unaligned","","Instantiates a new vector with the values of the `slice`.",99,[[],["self"]]],[11,"from_slice_aligned_unchecked","","Instantiates a new vector with the values of the `slice`.",99,[[],["self"]]],[11,"from_slice_unaligned_unchecked","","Instantiates a new vector with the values of the `slice`.",99,[[],["self"]]],[11,"write_to_slice_aligned","","Writes the values of the vector to the `slice`.",99,[[]]],[11,"write_to_slice_unaligned","","Writes the values of the vector to the `slice`.",99,[[]]],[11,"write_to_slice_aligned_unchecked","","Writes the values of the vector to the `slice`.",99,[[]]],[11,"write_to_slice_unaligned_unchecked","","Writes the values of the vector to the `slice`.",99,[[]]],[11,"offset","","Calculates the offset from a pointer.",99,[[["isizex8"]],["self"]]],[11,"wrapping_offset","","Calculates the offset from a pointer using wrapping…",99,[[["isizex8"]],["self"]]],[11,"offset_from","","Calculates the distance between two pointers.",99,[[],["isizex8"]]],[11,"wrapping_offset_from","","Calculates the distance between two pointers.",99,[[],["isizex8"]]],[11,"add","","Calculates the offset from a pointer (convenience for…",99,[[["usizex8"]],["self"]]],[11,"sub","","Calculates the offset from a pointer (convenience for…",99,[[["usizex8"]],["self"]]],[11,"wrapping_add","","Calculates the offset from a pointer using wrapping…",99,[[["usizex8"]],["self"]]],[11,"wrapping_sub","","Calculates the offset from a pointer using wrapping…",99,[[["usizex8"]],["self"]]],[11,"shuffle1_dyn","","Shuffle vector elements according to `indices`.",99,[[["i"]],["self"]]],[11,"read","","Reads selected vector elements from memory.",99,[[["simd"],["simd"]],["simd"]]],[11,"write","","Writes selected vector elements to memory.",99,[[["simd"],["simd"]]]]],"p":[[3,"m8"],[3,"m16"],[3,"m32"],[3,"m64"],[3,"m128"],[3,"msize"],[3,"Simd"],[8,"SimdVector"],[8,"SimdArray"],[8,"Mask"],[8,"FromCast"],[8,"Cast"],[8,"FromBits"],[8,"IntoBits"],[3,"LexicographicallyOrdered"],[6,"i8x2"],[6,"u8x2"],[6,"m8x2"],[6,"i8x4"],[6,"u8x4"],[6,"m8x4"],[6,"i16x2"],[6,"u16x2"],[6,"m16x2"],[6,"i8x8"],[6,"u8x8"],[6,"m8x8"],[6,"i16x4"],[6,"u16x4"],[6,"m16x4"],[6,"i32x2"],[6,"u32x2"],[6,"f32x2"],[6,"m32x2"],[6,"i8x16"],[6,"u8x16"],[6,"m8x16"],[6,"i16x8"],[6,"u16x8"],[6,"m16x8"],[6,"i32x4"],[6,"u32x4"],[6,"f32x4"],[6,"m32x4"],[6,"i64x2"],[6,"u64x2"],[6,"f64x2"],[6,"m64x2"],[6,"isizex2"],[6,"usizex2"],[6,"msizex2"],[6,"i128x1"],[6,"u128x1"],[6,"m128x1"],[6,"i8x32"],[6,"u8x32"],[6,"m8x32"],[6,"i16x16"],[6,"u16x16"],[6,"m16x16"],[6,"i32x8"],[6,"u32x8"],[6,"f32x8"],[6,"m32x8"],[6,"i64x4"],[6,"u64x4"],[6,"f64x4"],[6,"m64x4"],[6,"i128x2"],[6,"u128x2"],[6,"m128x2"],[6,"isizex4"],[6,"usizex4"],[6,"msizex4"],[6,"i8x64"],[6,"u8x64"],[6,"m8x64"],[6,"i16x32"],[6,"u16x32"],[6,"m16x32"],[6,"i32x16"],[6,"u32x16"],[6,"f32x16"],[6,"m32x16"],[6,"i64x8"],[6,"u64x8"],[6,"f64x8"],[6,"m64x8"],[6,"i128x4"],[6,"u128x4"],[6,"m128x4"],[6,"isizex8"],[6,"usizex8"],[6,"msizex8"],[6,"cptrx2"],[6,"mptrx2"],[6,"cptrx4"],[6,"mptrx4"],[6,"cptrx8"],[6,"mptrx8"]]};
addSearchOptions(searchIndex);initSearch(searchIndex);